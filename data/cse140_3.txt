 Good morning everybody. Welcome back to class. See you again. In case you're wondering about my new background. This is political international lakes in Croatia where I'm from. And it's literally about 20 lakes connected by waterfalls and walkways. You can see picture of the walkways that go across the lakes. And the color that you see actually is real. It really does look like that. That's because of a special sediment that exists. So onwards and upwards to new things in class are actually more of review, hopefully for most of you from CDC 30. What we've covered so far has been the number system cmos transistors helped to build gates and how to do delay. What we're going to focus on today is more of logic gates, Boolean algebra, and getting started with specifying logic functions. Make deadline coming up is homework one, which is due this Thursday. It is due on great scope. Let me get started. I want to quickly review some of the common logic gates. The first one that we've already covered in class is an inverter, which basically takes a single input only and provides a single output that is inverted. So if the input was 0, output will be one. If input is one, output will be a 0, a basic symbol for it as a triangle, but the little bubble in front of it. And as you know already, this is two transistors. I have one pMOS and one n MOS type transistor. And we talked about the buffer. And buffer consists of two inverters back to back. So if I put the logic 0 into the buffer, output will be a logic 0 input if I am, but the logic 12, the buffer output will be a logic one. And what we use the buffer for is to strengthen the signal. So it's faster. And also to recreate or recharge logic one and logic 0. The reason why we need to strengthen them or recreate them is because the pure, remember, the NMOS transistor does not pass logic ones all that well, and PMOS transistor does not pathologic dealers all that well. So using a buffer would allow us to actually fix that problem. The other gates we talked about in class is a NAND gate, which outputs a logic 0 only when both inputs are one. In a NAND gate, you will have two PMOS transistors in parallel and two NMOS transistors in series. It consists of a total of four transistors. Notice that if I want to build a single AND gate, which outputs a logic one, only when both inputs are logic 11. I actually have to do is I have to build in cmos NAND gate with an inverter. So NAND gate is how many transistors for and an inverter is. Two transistors for total love, six transistors for a NAND gate. So that's a fairly expensive gate to build. Now I forgot to talk about the buffer. Just to remind you, for buffer we need four transistors because we have two inverters. Okay. The next gate I want to introduce you to and review is a NOR gate. Nor gate will give a logic one output only when both inputs are 0. In all other cases, it gives a logic 0. Nor gate has a similar situation as the NAND gate in that it has, in this case. The two PMOS transistors in parallel and series, sorry. So this is in serious, but now it's PMOS. So that's dual of the previous one. And it has two NMOS transistors in parallel. Ok. It is also for transistor gate to be into n-type transistors. Now if I want to build a single OR gate, I have to use a NOR gate and add an inverter. So NOR gate, this four transistors, inverters, two transistors for total off six transistors. So you can see that also an OR gate, there's a fairly expensive gate to build in cmos. Notice that the r gets a logic 0 output only when both inputs are 0. In all other cases, it gives a logic one output. So expected these logic gates, There's symbols and their truth tables are nothing new to you. The only novelty is the transistor apart. So make sure you're super comfortable with both symbols and the truth tables. We'll be using that in the rest of the class. The last two gates that I want to cover are the XOR, XNOR gate. Xor gate tells us when two outputs are different from each other. So if two outputs to inputs are different, then the output is a logic one. And this can also be represented by specifying that the output is a logic one. If either a is 0 and B is a one, or a is a one and B is a 0. That's what this equation says. An ultimate way to express this is by using this expression a little plus in the little circle that tells us that it's an exon. And notice that the XOR gate has this additional line on top open ORF. And somebody asked the first question in your homework or Well, that may be in which case I'm helping you except I'm not solving for U, the delay delays the hard part. The other interesting thing about the both XOR XNOR gate, notice that text nor is the same as x or accept it as a bubble at the output. And in XNOR, what we detect is when two variables are the same. So that's when you get a logic one output, and that is what's represented by these two terms. So your feet are both a and B are one or both a and B are 0. The output will be a logic one. Xnor is represented by putting a little bar over the XOR. The interesting thing here is that we have a situation in which both XNOR, an XOR gate can be represented by using. Completely symmetric transistor representation. I'm actually not asking you to know this particular representation. All I need you to know is the inverter, the NAND gate, and the NOR gate. Those are the three things you need to know it transistor level. And you need to be able to build more complex gates using those transistors. Okay? Now notice if I was actually building this using OR gates and NAND gates, what I will have here is a single or at the output. And then I will have an end, 2nds of which one has to complemented inputs. So for each of these three gates, I use six transistors for total of 18, plus the two NOT gates, which are each two transistors. So plus four more, which gives me 22 transistors. That's a lot of transistors compared to what we have here. Okay? So you will never build an XNOR or an XOR using these Boolean equations, you would always do it in C mos direct one. Just remember that the number of transistors is going to be much smaller. Gap. Any questions on this? Okay, let's move on to Boolean algebra. So Boolean algebra is defined on a set which consists of only two values, logic 0 and logic one. Variables can only take one of those two values and operators can also only return one of those values. In contrast to cmos gates in which we want inverter, NAND and NOR. Here basic operators are AND, OR and NOT gate. So here's what the end didn't like. Here's what the ore is like. This is your NOT gate. In Boolean algebra. Everything else is derived from this basic operations. So for Boolean algebra perspective, NAND is a combination of a single and whether or not, the funny thing is that in fact, that's exactly not what you will do in hardware. What you'd do in hardware is you build a NAND gate and then you would represent the end as a combination of NAND and not. So this is one example where theory and practice are very different from each other. Okay? Okay, so that brings me to the exciting question of universal gate and why NAND and NOR a universal gates. The reason why they're universal gates is because I can actually implement any Boolean equation by using those gates. Now, we already talked about the fact that Boolean algebra uses and, or and not as its basic operators. So if I can implement and, or and not using, and then, then I can implement any Boolean equation because Boolean algebra just needs those three operators. Notice that not can be implemented by simply connecting the two inputs together. So here is my Nan. If I have a B. 00011011. So we have 1110. And notice if I connect the two inputs, if both inputs are 0, the output will be inverted. There'll be a one. If both inputs are one, the output will be a 0. So that's your basic inverter. Now what they actually want to implement it like this in the hardware? The answer is no, because this is four transistors where they really want is an inverter, which has two transistors. So my homework or an exam asks you to implement something using dance you want to do in the end and not. Okay? So you're going to use those two gates. And somebody asked, can I bumped any logic using then the answer is yes. Now let's discuss how we can do a AND gate and that we've already talked about that super simple, right? They can, they end and then just add an inverter. And that gives me a single AND gate. Okay. More complicated part is how do you do an OR gate? So, OR gate or, or function? Looks like this. If I now put double inversion on here, I can use DeMorgan's theorem. And what, I'm going to get something that looks like this. And in about, in about two slides, you will see how DeMorgan's theorem works. And hopefully this is all review because I expect that you've covered at NCSE 30. So notice that here I have two inverters plus a single land. Okay? So how my aura looks like is I have a NAND fanned with inputs that have both been inverted. Alternate way of drawing this is to do this. But little bubbles instead of the whole inverter. Okay? So the question of can you use NOT gates on the homework? The answer is yes. And this here is an example of how you would implement NOT AND, and, OR gate using dance. Let's do the same thing using Norse. And again, the same rule applies. If for the homework assignments says only Norse, then really what it's saying is NOR and not. Let's review a NOR gate quickly. So here 00011011. So if I have a NOR gate, I'm going to have a logic out with the obs 0 in all cases except when both inputs are 0. Got not. Would be implemented just by connecting the two inputs together. And notice that that is exactly how this works. So if I have a NOR gate, then I connect two inputs. What I'm going to get that the output is a not got. Now what I wanna do it, No, because it takes four transistors, will not will do is instead an inverter, which takes only two transistors. If I want to implement an OR gate that we already discussed, I will take a NOR gate and that would add an inverted to the output. So this gives me a or B and the output. Okay? And the last piece is a NAND gate. So what if y is equal to a and b? I would again use the same trick. I will do double inversion. And that then gives me, again might be Morgan's theorem. And notice that here I have two inverters and I have a single NOR. So again, I will draw it like this. I would have two inverters at the inputs and a single nor that combines them to give me y equals to a and b. The same thing will be, you can do just by drawing little bubbles. So here is a and b, and here is y equal to a and B. Got. So if I'm asking you to implement something using only Norse, you're gonna use n4 and NOT gates. And you will remember that you will replace n gate with the NOR gate and inputs complemented. And this you can derive by using DeMorgan's theorem. Organic, you're going to replace with a NOR gate and an inverter at the output and not give it will just be a NOT gate. Okay? Same story goes for if you have to implement something just by using NAND gates, Do you have any question on either NOR or NAND does a universal gate before I move on to Boolean axioms and theorems. So there is a question on how many gates is and in terms of Nora and not. So, yeah, actually let's talk about the transistors. That's a good point. So in this example, it takes how many transistors for our NOR gate? This is four transistors and then inverter is how many? Two transistors, n2. So the total here is eight transistors. The same is the case here. Each of these bubbles is two. And the NOR gate itself as eight. Over here. We have four transistors, two transistors for thermal off, six transistors. And if we talk about how many gates we have this as one NOR gate, this is two inverters. So for total of three gates. So eight transistors and three gates in this case. Same is the case here. Here we have two gates and here we have, we're not, we have just one gate. Okay? I am moving on to Boolean axioms and theorems. So if we look at Boolean axioms, the first one just tells you what Boolean algebra is, that it's a binary field, consists of two elements, 01. And if you have, if a variable is a 0, it can't be a one and vice versa. It also defines for you basic operations and how they work. So basic operations OR NOT, AND, and, OR, and this explains to you how those operations work. More interesting part is actually the bottom table and the table on the next page, all of this I got straight out of your textbook. So the first one is, and these are the theorems that I need you to use on the homework. So the first is that the big theorem, which basically tells you if you combine a variable width logic one, If you ended with the Huan, You get that variable back. If you or that variable with the 0, you get the same variable back. No element tells you that if you, if you add variable with the 0, you're gonna get a 0. So variable won't matter effectively. And if you are variable, when the one you're going to get a one, it then put that c gives you, it tells you that if you combine variable with itself, you get the variable back. Involution tells you if you do double negation, you're gonna get the same variable. Complement is interesting because if you combined variable when its compliment in case of ending, you're going to get a 0 in case of, or you're gonna get a one. So these are all fairly straightforward. I expect that you all know them. More interesting ones are here. So the first two, commutativity and associativity. I've, I think you guys should know, printed well, Distributivity, you want to be a little bit of attention to what happens. And on the right-hand side here. So for example, with distributivity here, you're not going to have B and B because it simplifies down to just B. And then covering similar story happens in both cases. You can simplify the equation. So make sure you're very comfortable with both of these because that can be super-useful when simplifying both combining. And this is actually super helpful. And it's usually very easy to notice when it's in the form of B and C, or B and C not. But it's a little less easy for people to notice it when it's in the second form or when three variables are used as it is in consensus. And in a second, I'll show you how we can prove consensus theorem. The last piece is the mortgage theorem, which is super important because we use it all the time. So in DeMorgan's theorum, if they have any number of variables added together and then complement it with, you're going to get this off those accomplishments of each of those variables ored together. Vice versa. If you have bunch of variables or together and then complement it, you're gonna get compliments of those variables all ANDed together. We got. So make sure you feel super comfortable with all of these theorems. And on homework you're asked to use, use them and write the name of each theorem that you've used. So for example, if you're using the dual of distributivity, you as Right? Distributivity old me. You don't have to tell me that you were using a dual, okay? Okay, moving on to duality. So in Boolean algebra BC that we use duality when we can derive a dual of an expression by replacing ads with the ors, ors width and zeros with ones, ones with zeros, and we leave variable's unchanged. And this actually works even with a few variables. It works also in a very generalized way. Notice that this is not the same as DeMorgan's law at all. So be aware of both duality and DeMorgan's law. So let me give you an example of what I mean by proving theorems with Boolean algebra. So if I wrote the Pru of consensus theorem, what I would be doing is I would start with the left hand side, and I would want to apply theorems of Boolean algebra to transform it to the right hand side. So first in this case, I would use distributivity. The next would be complimentarity, which allows me to effectively get read of y or y naught. And then identity which allows me to arrive to the right-hand side of the equation. So if this was your homework assignment, I would expect each of these steps shown and labeled with the name of the theorem. Same thing happens in covering theorem. So I would start with a then that the use distributivity using dented the again. And now I have shown that left hand side and right hand side are the same. Now. And it's only this homework that I'm going to ask you to write names of the theorems. And I'm doing this just to make sure that you have looked up the tables and you're very comfortable in remembering all these. On the exam. You're not going to be asked for names, but you will need to know how to use these theorems to MIT and my logic functions. Ok, so let me give you a little bit more complex example, and this is with consensus theorem. So again, we want to start from the left hand side. And First way would use identity because that allows us to expand that middle term using complementarity. Once we'd have expanded that, we can apply distributivity, because now I can get terms that I can more easily combine. So after I switch the position of the terms with kmeans activity, I can now combine the first two terms and the second two terms together to simplify them. So here i after the simplification and not brick and the application of the Null, I actually get the right-hand side. Okay. So this is an example of what that would want if I go through proving consensus theorem using Boolean algebra. And that'll it's writing down the names of various theorems. Okay, so that brings me to DeMorgan's theorem or bubble pushing. Does anybody have questions on any material up to now before I move into bubble pushing. Okay, so, oops, sorry. So for bubble pushing, all we're doing is just implementing DeMorgan's theorem. So transforming left side of the equation into the right side of the equation. But we're doing it directly to logic gates. So what I'm doing is I'm taking a bubble, I'm pushing it through the gate, which means that two bubbles are going to appear at the inputs. And then I change the gate, gate was an end. I change it to an OR. Here are my mental bubbles then have appeared and I've changed the gate to or. The same thing happens with the NOR version of this theorem. I'm gonna take the bubble that's at the output. I am going to push it through to put two bubbles at the input. So those are the two bubbles. And then the next thing I'm gonna do is I'm going to transform the gate. So he votes that are up there. It's going to now be an and. So somebody's asking, is a B equal to a dot B? And the answer is yes. So that's the same thing as a and B, or it's the same thing as assembly function and a b and y also. Yeah, thanks for checking, double-checking. Ok. Any questions on the bubble pushing over here, I'll do an example on the very next slide. So really old bubble pushing does is it transforms the gate. If it was a NAND, it's going to be an OR gate and it moves bubbles to the input. Okay, so let's do a bubble pushing example. Whenever there is an assignment that says implement this using bubble pushing, what you're gonna do is you're going to start from the output and you're going to push the bubble through. So if I push the bubble through, I'm going to generate two. Oops, sorry, I should have drawn the gate. I'm going to generate inversion at the inputs, right? The other thing I'm gonna do is I'm going to change the shape of the gate. So instead of an AND gate, this is going to become my OR gate gap. So now this is my input D0. Now I'm at the gate C, and I gotta take this bubble and push it through. So I'm going to get two bubbles at the inputs. And I have to replace this also with the NOR gate. So here's my OR gate. And here my bubbles are the inputs. And this is my input C. And now I'm at this gate over here. I'm going to push bubbles out again. I get two bubbles at the inputs. But this here is an OR gate to. So now I want an AND gate. And I put my two bubbles at the input. And here my a and b. Okay, so this will be the first step. The second step would be to realize that I have a bubble here. Then I can combine with the gate before. And same thing over here. So what I would really want to draw is something that looks like this, a, b, this now becomes a NAND gate that feeds into an OR gate which has c complement and the input. And this becomes a NOR gate because I use this bubble here. So now I don't have a bubble coming in over here, but I do have a bubble at the input D0. Okay? So that's an example of bubble pushing. Now, will they ever do this kind of thing in hardware? In this particular example, the answer is no, I would not do it in the hardware because on top, I had 444 transistors for a total of 12 transistor design. On the bottom here, I have how many, how many transistor is my OR gate? So, OR gate is six transistors. This bubble costs me two transistors. How about NOR gate? How many transistors do I have in the nor? It is four transistors. Here is a bubble that caused me to how many in a NAND gate. Also for, and I got to bubbles for two transistors each. So this is super expensive. Check it out. 2468 plus eight is 16 plus six is 22 transistors. Crazy, you will never do it. So Babu, pushing generally would be implemented only in situations in which it allows you to go from more transistors to less transistors. Or in a situation where a professor gets you an assignment to do bubble pushing for practice. We've got somebody asked, do you only push once? So when you're asked to transform the circuit using bubble pushing, you're gonna push bubbles through each of the gates that you have in that circuit. So if there is no bubble, then you're not going to push. Okay. Any other questions before we move on to DeMorgan's theorum? And nor only implementation. Okay, let me get to the next example. So this is an example where we implement using only Norse. Somebody asked, when do we realize we can stop bubble pushing? In the previous example, when you've got bubbles through all of the gates through which you could push a bubble. That was that was when you know that you're done on just the pushing part. And the second step that we did as we, once we apply this to simplify the gates, meaning to get gates to have less transistors if possible. So that would be when you would stop. Okay, back to our nurse. So when I say people make using only Norse, What I always mean is NOR and not gate. So if I have an example like this in which function of x, y and z is equal to x bar y or z. My first step would be to put doubling version on this because that allows me to start getting the nor that I need, right. It allows me to go from an or that I have here to a NOR. No over here. To simplify this, I'm going to call this a variable D. So this thing here is the same as me writing the nor z. So this is my n4. And this here is a not gate. So this is my first step. Here is a NOR. And here's the here z. Ok. Now I'm gonna look at what my D is. Maldi is x bar y. And this clear clearly is not a normal operation. So again, to get a NOR operation, I'm going to do a double negation. This allows me to apply DeMorgan's theorem. So now what's going to happen is I'm going to keep the top negation. Here's my DeMorgan's theorum. And when I apply DeMorgan's Theorem, I'm going to change the operator from an end to an r. And I complement the variable since x was already compliment it, it just becomes x. Y was not complement it, so it becomes y bar. So now I'm ready to implement my gate. So I'll have a NOR gate to which one the input is. The other input will be y complement that. I can draw that either been a bubble or I can also draw instead of a bubble, I can draw a NOT gate. Both are correct. Ok. So this will be your final implementation that uses only Norse and NOT gates. Notice that you have to show this inverter at the output. So combining inverter with a nor would not be a correct answer to a question that thus only NOR based implementation. Okay, there are no questions. I'm going to move on to the next slide. So we can also prove theorems using perfect induction, but this works really only for very small sized problems. And here I'm going to show you how to do proof of DeMorgan's theorem. And we're gonna do it by simply doing each component. So if I want to implement X or Y, my extra y would be 0 for the first combination and then one for all others. That complement that. Over here is 1000. Okay? If I want to implement x knot and y naught, I will just be looking at the end of these two variables. And in that case I would have one for the first one because one ended with one is a one. And now we have 0 for all of the other ones. So this effectively proofs DeMorgan's theorem. It shows that left side is equal to the right side. Same happens on the second example, except now I'm going to do an end so far and I'm going to have 0. But for all combinations except for the last one. If to complement this, I'm gonna have ones for everything except for situation when both inputs are one. If I'm doing an or, I'm gonna do an OR of x knot or why not? In which case I will also have one output for all situations in which I have at least one of those or logic one. And then a 0 for the final, where both are logic 0. And in this case, I have proven that left side of the burdens is equal to the right side. So that will be proving theorems that perfect induction. So I have a question that we always dumped on the gate for transforming expressions in totally NOR and only NAND. Not necessarily depends on how the expression looks like. If you already have an expression that looks like a N14, then you don't need to double negate. We do it opportunistically. Is the correct answer. Any questions on any of this? Is perfect induction, just evaluating both sides in a way that shows equality. Yes, that's correct. And using a truth table effectively, Yep. So again, this is something you will do for maybe two or three variables, maybe four if you really feel like it. But anything beyond that becomes a little crazy. And I would not recommend that there are better ways to do it. Okay, I'm going to move on to the next slide deck. I have uploaded that slide deck into the other into the website, I believe, and also into Canvas. Let me just open it so I can start sharing it. Give me a second to transition. In the meantime, if you have any other questions, this is your chance to ask that because I can talk while getting the slides up. So there was a question when the hallmark says that really affected my zoom beau Just the second I lost my zoom. Don't wanna lose Mahzarin meeting. Picture. Isn't doing this crazy thing. Okay? Huh? Okay, I'm just searching for my screens or nothing. All that exciting is happening. But thanks for reminding me that the mirror it. Okay. So it says when the homework says the state in unambiguous terms, what gate does is it sufficient to say this is a NAND gate, for example, would be sufficient? Yeah. Okay. So moving on. Using inverter, but I've oxide using inverters and two-input gates were only referring to two nor gates that I will need to read the homework assignments. So I'll get back to that after I'm done with the lecture. So remind me please. I just want to double-check that we 3D correctly. Alright, so what I would like to do next is talk about how to specify logic functions. So here is an example of how we can specify a logic function by using a truth table. In this example, I'm actually doing an addition. So I'm going to do an ad of a, b and I'm going to provide output of a sum. So sum is going to be equal to a, oops, ay plus b, where this is an add function. Gap. It's not an OR function. And this is called a half father because it takes as an input a and b and produces outputs sum and carry out full other days as an input, a, b, and c carry in and produces sum and carry out gf. So half either, what we're doing is we're just adding these two values together. So if I add 0 to 0, I'm gonna get the sum 0. If I add 0 to one or one to 0. My final output is going to be Boolean one. If I add 11, 121, My final output, this 1-0 and Boolean, that means that the sum is going to be 0, but I'm going to have a carry out of logic one cap. And this here is a symbol for half adder. Full adder has a slightly different symbol. And oftentimes we actually put h a to symbolize happy either to just remind us that this is just a half-hour. You obviously don't have to do it because you can recognize it by the fact that carry in is not the input. Okay, so how do we go from truth table to Boolean equations? It's really quite simple. In case of carry, you just look at the point in which carries a logic one. And you look for input combination for which that is true. So in this case it is true if both a and B are, is logic one. So in that case, carry will be a logic one. In case of some, this happens if either a or B or logic one. So we represent that by stating if a is a 0 and B is a one, that's this first term is a 0 and B is a one. And, or if a is a one or B is a 0, that is a second term. In either situation, Some will be a logic one. Ok? So that is how we would go from a truth table to Boolean equation. And I assume that all of this is review from CSC turning. So to actually go to standardize the implementation of logic functions, we need to define a few things. First of all, when I say compliment of a variable, what I mean is variable that's digging it. So a bar or a prime are the same thing. Literal, I mean either variable or its complement. So either a or a prime implicate current is a product or an and of literals. So this would be an important amply cat, a sum or an, OR of literals. So this here is an implicate. Notice the difference is very small couple of ladders right here. Sorry, I circled the wrong letters and T and T0. But big difference in what we actually write. Min term is a product or an and that includes all input variables. This is super important. So if I have a function of a, B, and C, then all a, B, and C have to be implemented in a minterm. Same thing for max term except now it's an or. So in this case I would have to have also all a, B, and C in a max term. Max term we represent with a capital I'm min term with a small m. And I'll get to this in a second when I get into a little more details. Ok, so these are just definitions. How do these definitions apply specifying in terms of two input functions? Well, pretty simply, if we have combination of 0-0, this really means that a is going to be complimented and B is going to be complimented. If that is true, then the output of the function will be logic one. Same thing here, but except a is complemented and B is not. Then for a equals one, B equals 0, we have a not complemented, then B compliment it. And finally we have a and B not complemented. So that is what the minterms would look like for a simple function. That is a function of two variables only. This generalizes to 34 and any number of variables. So let's talk a little bit about canonical representation than when I have a canonical representation. I mean a standard representation in which we can be sure that we haven't forgotten to specify anything. In regular algebra. If I have polynomials, I would group them by power. So for example, if I'm trying to express a polynomial second power, my standard or canonical form would be a ax squared plus bx plus c. If I have that representation that we'll cover all possible versions of second-order polynomials. In Boolean and algebra, we have a similar situation. So if for example, I have a function of a and b, I would want to represent all situations in which that function is a logic one. So this, for example, would be a canonical representation because I've represented all cases in which function isn't one. And in all, in all of the components of it, all variables are present. This function here would also be canonical representation as what? This as well. These are all canonical. This function is this canonical. Is that canonical? What do you think? Do I have one now? Now remember, it has to be combination of main terms or max terms. Max terms we have ours. So all of these would be max terms. So this in fact is canonical. Got you guys are doing great so far. You're ready for our poll. So the question here is, is this function in canonical form? And that will give you a little bit of time to answer. Remember what canonical form means? Canonical forms are forms that include midterms or max terms. So ask yourself, does this include min terms of maxims in does it represent all of the variables correctly? We got 15 more seconds and buy more seconds. And that's at the end of the exciting poll. And then it's really close. Like almost half, half. So we better talk about the quake. Otherwise, only have half. Very confused student. Yeah, and I have somebody with a good sense of humor. It's definitely not c. Okay, so is this canonical? Whoops, sorry. We said that form is canonical. If all variables are present in each term. Here, not all variables are present. So this is not a canonical form. Okay? Now, could I make it canonical? Yes, I could. I could make it canonical by using a little bit of Boolean algebra. So to make it canonical, I just have to expand here. And I would end up with a situation in which I have all of the terms of the min terms. Okay? Now this is canonical. And these here, minterms. Got an excellent question. Why do we use this form over non-canonical? Yeah, I think we use this form to program computers with basically is the answer. And to have a standardized way to express functions. Canonical forms are definitely not the smallest possible representation. Usually, sometimes, rarely they are. So an example where f of a is equal to a, that's definitely the minimum representation. It also happens to be canonical representation. F of a equals to one is canonical because it fully expresses the function. And in this case, the function is true regardless of what variable AS. So, in those exceptional cases, canonical form can be, if you say f of a equals to one or 20. Ok. I had one other question. Oh, what is a midterm? So midterms we've talked about a little while ago. Midterms or products that include all input variables that basically have an end of all input variables. And they express when Function is a logic one. So we went over the midterms here. Okay, so let me move on past this two sum of products form, otherwise known as SOP form. For short. In this case. In this, uh, before we do ants to represent them in terms. And we do ours to combine the min terms. Now notice that here it does matter what the order of variables is. So in a second, we're going to see why this matters, that a is the most significant and b is the least significant bit. Here. Notice that sum of product expression implements when Function is a logic one. And here function is a logic one in these cases. So in the first case, I have a situation where a is a 0, B is a 0 and C is a one. This is why I have a bar B bar C as the first term. On the other end, if because function is a 11, all three variables or one, that's why the combinations is a, B, and C. In order to implement this logic function, I need to combine all of the min terms using an or to finally get the correct output for my function that I have. Now notice that I can also pretty easily get the prime of F simply by looking at where f is 0 and f is a 0 in these cases. Okay? So it is very straightforward. So mentor is just a way to call the way we represent the term for which function is a logic one. So let's go through this of how minterms actually work. So if we have any general logic function, then we could represent each one of the min terms using the variables as follows. Associate. When all three variables are 0, the equivalent mid-term would be a bar, B bar, C bar. If they have A1, B1, and C1, equivalent mid-term would be a, b prime c. Now what is this, this column here is the decimal numbers of min terms, and here is where it matters. What is the most significant bit and what is the least significant bit. So for example, for this case, we have a situation in which we have one times an a is the most significant bit. So this is two to the power of two plus 0 times two to the power of one plus one times two to the power of 0. This is equal to one times four plus 0 times two. Plus one time one, which gives me four plus 0 plus one, which is five. And this is what you see in this min term here. So this allows us to effectively express the function f that we saw on the previous slide using this simplified expression where some really just means or between the min terms 13567. So that is because function f was 1413567 and it was 0 for the other ones. Okay? And again, this maps directly into the same min terms that we wrote on the previous slide. Now notice that canonical form is not the same thing as minimal form. In fact, if I take this canonical form and I simplify using Boolean algebra, we'll end up with something that's much smaller. Canonical form we use to ensure that we have consistent representation of power functions. Ok, so let's do an example. We would like to do some of products canonical form for both sum and carry. And since I'm a little lazy of would like to start first with that carry because Carrie has only a single place where it implements a logic one. So here it will be a logic one when a and B are both true. So for carry, this would be a and B. That is the same. I'm saying that I have a midterm in which men term isn't going to be. Let's label our minterms. So the first midterm, notice that a is a most significant bit. How do I know that? I know it because a's on the first place here. Okay? So 00 in binary it gives me a decimal, 001 in binary it gives me a decimal what? So 0-1 and binary gives me a decimal 110 in binary it gives me a decimal two. So that means that 11 is decimal three. So this is some of minterm three only where some really means and, or. Ok. And I had a few other questions. On the previous slide. Does f equal to a prime b prime, c prime equals 0 for a, B and C equal to 0. So if a, B and C are equal to 0, then function f should output 0. So that would really be like saying that f prime is equal to a prime, B prime, C prime over. A prime, b, c prime, or, and this is the third one, a b prime, c prime. And summation in this case really just means that we're doing or between min terms. Okay, so let's do the, some part of this slide. In case of sum, we have logic one output for two minterms. Minterm a prime b, or min term a b prime, which is equal to I actually, which meant turns. What should I put in these parentheses? There are two of them, right? Exactly. So minterm one, minterm two. That's because this and this are min terms 12. Got. Excellent. Any other questions on this? Okay, that means you guys are ready for yet another pole in the class. Let's see if everybody got it. I would like you to tell me what is the sum of products canonical form for this particular example. Oh, wow. Hey, we got five seconds. This is your chance to get your BATNA in 43210. And here are the results. We got pretty large majority betting on b. And then we have some that have sprinkled. All about. C was definitely not favorite. So let's look at what actually is going on in here and make sure that we all understand. So first of all, we know that the function, whoops, sorry, that the, in this function a is the most significant bit. So let's write out water, our little men terms. The first one is going to be 0, then 123. So when we say 23, really we're talking about these two. So this is correct. So that's the happy news, at least the problem statement make sense. Now we look at what are those min terms over here. So in the first case we have a is a logic one, and B is a logic 0. In the second case we have a is a logic one and B is a logic one. And those two have to be all together. So that means that this is definitely correct. Right? Now, if I take this expression and I tried to simplify it, can I simplify it further? And the answer is, sure, this as equal to a. So is this true? Yes, this is the same function. Right? But is this canonical? No, not canonical. So that is why a is not true and B is true. C is not even the same function. So that is definitely incorrect and this is incorrect because B is correct. And a is not correct. Yeah, so a is not true because we asked for canonical form. And canonical form requires that both inputs be correct and small m. So this minterm representation will always be the decimal value. That's just the shorthand version of implement of specification to make your life a little easier when we have larger functions. Ok, so let's move on to the product of sums canonical form. And this is very similar to what we just talked about, except now we're using max terms. And in max terms we implement zeros of a function. So to implement zeros of a function, we first look where the function is a 0. And then we express that particular input combination using and, or by making sure that the variable that is represented as a 0 is represented as itself and variable that's represented as a one is complement that. Notice that this is a dual up sum of products form. So this is known as POS form. Then it's a dual of sum of products form. So in sum of products, we've looked at PR function is one. Here we look at barrier function, this Hazara. Okay? And function is 0 and only three instances. This is why we have only three max terms. Max terms are represented with a big capital N. And notice that f prime corresponds to a situation in which the sum of products was a one. So now product of sums will implement that prime. And you can see a one-to-one mapping here, again of each of the terms. Okay? Okay. So to give a quick overview of how this all works, max terms again represent when Function is a 0 and the inputs are ored together. So they're 4D. And then everything is connected together by using a product or a pie that equals and together. So we will have these terms and that together like this. Okay? So if I want to express a max term, 1-0-0, I would have to compliment a because a is a logic quantity here. And leave B and C on compliment that the labeling happens the same way that's present at four minterms, except now we use the capital M to express the fact that we're doing max terms. So because a is most significant bit, For example, in which we're doing, for example, for what we will be implementing is one times two to the power two plus 0 times two to the power one plus 0 times two to the power 0, which is equal to one times four plus 0 times x2 plus 0 times one, which is equal to four plus 0 plus 0, which is equal to four. And this is why this is the max term for. Now remember my f function before had three zeros. It had 0 at 0 at two, and it for all the rest were one. So this is why I have this representation in POS form, product of sums form. So it tells me that I'm gonna be multiplying or anding together max term 024. And then all I have to do is just look up what are those max terms in my cheat table that I have right here? And I just right amount. Notice. And again here canonical form is not the same as minimal form. I can again simplify, but notice the interesting thing that after simplification, I got the slightly different expression. This expression still is correct. It still gives me correct output for the function. It just doesn't look the same as it did when we did sum of products. So the question and messages on m 0. So m 0 is a or B or C, regardless of what order variables you have, the order of variables is going to matter when there's asymmetry. So for example, if you have four than it does matter that the order of variables is a prime a BC, because then a is the only one that gets primed. All right, let's move on. You super excited, I know to implement product of sums canonical form for the carry. So let's first talk about what do our max terms look like? So if both variables are 0, what is going to be my max term? Am I going to have complemented variables are just variables as they are mature. They put in this first one for the max term as they are. So it's going to be a or B. How about the next one? What should I write here? A or B prime, correct? Then the next one is going to be a prime or b. And what is my last time? Last one. A prime or b prime. Now if I want to implement product of sums, am I going to be looking at zeros are the one. Which one is by product of sums. Zeros, ones are sum of products. So if I want to do carry in SOP form, that would be equal to a, b, which is the same S carry off three, right? Now if I'm doing the max term switches product of sums, I would have product of sums. Which ones? What do I put in parentheses here? When is this function 0? It's 0 for max term 012. And I can also write it like this. And I can write it like this. A or b. A or b, not a or b. All of these are canonical expressions. In the questions. We got. Let's move on here as Back to our carrion, some instance you life you guys just went over du carry. How about you tell me all about how one would implement the sum? And I'm going to start the pole. Pole is going. You got a minute to think about this. What is a POS expression? And bear POS stands for product of sum, otherwise known as max term version, or situation in which year take or it's ours are variables and you add them together. Think about the fact whether we're implementing zeros or ones in product of sums. Sum of products was implementing ones. What are we doing here? Zeros or ones? Cap, faker, well into past the minute, I'm going to end the poll and share results. So here is what the results are. Majority really likes answer D and a slight minor, and right after that is minority that likes answer a. So let's see who is right at the eighth or the d xz. It's an exciting moment in life. Okay, let's first talk about, first of all, we're not going to be doing a carry, so let's not worry about this. We're going to look at the sun. We aren't going to do max terms and max terms. We already know what they look like. So these ones are a or B, a or B not a, not a or B and a knot or be not. Got. The next question is, are we doing, what? Are we doing zeros. What do we think zeros or ones it as zeros. That's per POS. So if we're doing 0, us, we're going to be taking this max term and this max term. So here is the zeros version. And that turns out this correct. So majority seems to be ruling yet again, yay. Now this here actually implements some, not. In fact. So if you want not sum, that's what you got under a does be implement some business equal to some yes. But not product of sums. What is this? This is some sum of products gap. So that's why b is not true. B is the correct function, but it's in sum of products form not product of sums point C as even an incorrect function. And d is not true because, sorry, e is not true because d is true. Ok. Any questions on this? Right? We did not consider carrying this problem, Carrie. We did on the last slide. I could have just not shown it by moving on. So here's another, a super duper exciting poll. And the question is, when would you use sum of products instead of product of sums to represent the function? Now remember, you always want to represent a function using the smallest number of transistors. The smaller implementation always wins over bigger implementation. So what do you do? Sum of products when the output of the function is true? For many input combinations, would you do it when the output is not true for many input combinations? What you always do it because you like sum of products or none of the above, correct? And I'll give you guys a minute to think about this. Okay. Give me a 543210. And here we go. Here's what the results look. It's a slight majority for option B. So let see if B wins today. So far it's been a pretty good majority has pretty much ruled, I think today overall. So the question is, oops, sorry, sum of products, not product of sums. So think about it this way. If we have a lot of situations in which there is a logic one at the output. So for example, if I have three variables and I have for many, many cases situation where it's a logic one, but only two cases where it's a logic 0, I'll likely end up with an equation F. That is, then has lots of terms over here, right? And that leads to big gates. So that is why Option one is actually option a is not true. If instead of that, we have only one situation where the function is u1 and in all other cases is a 0, then my output is really just one gate. So in the extreme, they would have just a single gate with some inverters. So that's my B would be true. We definitely don't always prefer sum of products form we're going to go for whichever form gets us a smaller implementation. So when you look at the logic function, if you have less one, less once, go for several products, less. Zeros go for product of sums. And this is just a rule of thumb. This is not a role that's going to give you always minimum implementation, but oftentimes it does. Okay. Any questions that you guys have that I can answer in the last few minutes, the classes officially ended about a minute ago. But if you have any questions, I'm happy to answer them. At professor and question two of the homeworks and learning. And can we use more than two input gates? Gets a hammer enchanted? Yep, thanks for reminding me. I totally forgot about that question. So let me look at the homework what it says just to be sure. Those it's, so question two says, isn't universal gates, as it says, implement only not the NAND. In part a and part b says not men nor he doesn't say it has to be only two input. So you, you would be okay using more than two input. And just make sure that they're not the NAND gates. The only tricky part in this question, we're not asking you how many transistors, but, but three input gates. You have different number of transistors obviously. Okay. Thank you. You're welcome. So when the problem doesn't specify, it is okay to use more than two input. And homework can be handwritten. There's no problem with that. You just need to scan it or take a picture of it and posted tin grade scope. In question to your are trying the circuit. Some people may find it easier to do a bit of Boolean algebra to get it in a form that's just NAND than not. But that's really up to you as long as it's very clear to us how you arrived at the final design that will maximize your partial credit. Any other questions? In question four? As fall, I am using inverters and to implicate cite those two implicate doesn't have to be necessarily have to inaugurate. It can be any. That's correct, but they have to be only two-input elk. Thank you. That's in part a and obviously in part C tells you it has to be two input NOR gate. And you can use inverters in part C. Okay. Any other questions? Okay. Thank you all. It's been a great morning and good luck with homework. I hope it goes great. I am definitely available if you guys have any further questions. We have plenty of office hours and the discussion session on this Wednesday will go over questions similar to the homework. So feel free to ask all the hard questions. Discussion session. Thanks, bye everybody. Good luck. In the rest of your classes. It's been a pleasure.