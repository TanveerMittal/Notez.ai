Okay, we are recording now. Okay, so it just a motivation for sorting. we'll talk about what kind of operations are are are reasonable for sorting. Then we'll talk about how to sort of permutation which is really kind of like at the essence of what sorting is because. sorting a list that list is jumbled right or it's it's rearrange somehow and we already know how to count the number of different rearrangements which is n factorial the number of permutations so they there, there is some link there. sorting in general sorting algorithms and then I forgot to put this on here searching. algorithms. Alright, so we'll get to that. Alright sorting or ordering. um so the picture on the left is somebody's room a child's room and you can see the child here i've already highlighted him a few times he's highlighted in red. He might have not even known that he was there and then you have these dolls that fit inside of each other, now the dolls it's very obvious they're sorted in decreasing order of height right this child's room is this sorted. kind of depends on who you ask right if you ask me, it doesn't look sorry it looks completely out of order right it looks like. You know the you need to put in considerable time to put everything back in the place where it's supposed to be, but maybe to this kid. This is exactly where everything is supposed to be. You know, maybe he has it maybe this is sorted for him. So, for example, maybe he wants the. Maybe he wants the pizza box or exactly right there on the floor, you know. I don't know what he's doing. With his computer. The numbers on the chalkboard look pretty sorted yeah so. Anyhow, I just wanted to kind of give you an idea that sorted is kind of like in the eye of the beholder. yeah he's pretty creative okay so let's do a poll here. That being said. Which of the following collections of elements is inserted hoarder. How is he going to. How are you going to. feed the fish and then what else he eats chips and muffins out of dog food trays. I think that's the name of his dog. How is he going to feed the all the fish, all the way up there, oh yeah. Okay, what other kind of jokes we got. here's a good artist he's on zoom. he's napping on his desk okay good all right back to the thing which of the following collections of elements is listed in sorted order. Alright, so most people are saying D, some people are saying be some people are saying see nobody's saying hey okay so be. Be we're going to say is sorted. In increasing order. In this class when we talk about sorting we're we're mainly going to be talking about increasing order sorting and increasing order. Okay, how is see sorted. This is sorted. In decreasing order. So do you need um. Do you need different like completely different algorithms to sort a list in increasing order, rather than sort of in decreasing order. You can generally use the same idea what's the difference. The comparison, so all you have to do is change the definition of comparison right. And you can use the same exact algorithm to sort it in these two orders right. Just change. definition. of comparison. Right what comes before. What. What comes before what if it's a decreasing order a bigger number of comes before a smaller number if it's an increasing order a smaller number comes before a bigger number, so if you just have that simple idea of comparison. Okay, how about a does anybody know how a sorted. Or is a just not sorted at all. Oh, it is a comparison that you do know. It is a lightning bolt permutation but remember that you already counted how many lightning bolt permutations there are right, so there. The thing about increasing and decreasing is there as a unique way to arrange them in increasing order there's a unique way to arrange them in decreasing order so in order to sort something you need a unique way to order them. And remember, there are more than one lightning permutation so. that's not going to be a way to sort it. out them out. Okay Max mean second maximum second men, so this is true that it follows that but. You need to have a complete ordering. What would you say Alphabetically okay exactly right if you write out the numbers. 42 1020. Oh sorry 30. Again, you can use the same algorithm. All you have to do is change the definition of which one comes before the other one in this case it's alphabetical order which one comes before the other one in the dictionary. Okay. So why do we sort sorting is organizing and organizing is good organizing means that you can find things easier. In algorithm designs sorting is a common sub routine to organize the input it's common it happens all the time, your phones or computers they're sorting things thousands and thousands of times per second just so that you can access them easier. Any problems or easier on data that has been sorted searching we're going to see that today, of course, finding the minimum and maximum now is trivial. Finding duplicates is really good if you sort it, because all the duplicates kind of clump together. Set intersection or Union is also easier when things are sorted, because you can when you do in the set intersection in Union, you need to figure out when. Two lists share the same element and it's easier to do that if they're if they're in sorted order. Okay, but in this class also sorting is a great way to introduce. students to certain algorithms we're gonna we're gonna look at sorting algorithms that are iterative that are recursive that are divide and conquer. And that a randomized. Okay, so we'll see the iterative algorithm will see men sort, among others, will see recursive men sort. divide and conquer will see something called merge sort. And randomize will see something called quick sort we won't really spend so much time on quick store but it's good to know that it exists. Okay sorting also aids and ranking what is ranking remember we just did this last week ranking is just putting things in a particular order sorting them lexicographical order and then using that order to encode them, so it all comes back to sorting. Okay, what kind of operations help you sort. What do you all, what would you all, what kind of operations, would you all want to have okay good so we definitely need some something about comparison. And we need something about swapping. So we're going to. we're going to split swapping into two different categories. Are you allowed to swap any two positions. Or are you only allowed to swap adjacent positions. Is one better than the other, is there a way, is there a. scenario where. You would want to use one more than the other, depending on the kind of hardware you're using. I don't actually don't know if this is a question for you all anybody who's taken any kind of like hardware classes, all you electrical engineer computer engineers, is there is it harder to swap two things far away or to swap two things that are close together. Maybe it's easier to swap things that are closer so you'd rather use that but maybe it's a trade off right. Okay yeah, this is the kind of. This is the kind of information, I was looking for. Okay anyhow. Oh God, I do. Alright, so we talked about swapping what I should put comparison here too that's definitely. How about this moving and inserting. Like if I wanted to sort a deck of cards, I could take a card out right and insert it into the place where. i'm. into the place where it's supposed to go is this easy to do in a computer. it's kind of it's kind of a pain right because you have to put something in you have to move everybody over right so it's kind of annoying it's possible but annoying right annoying. To do. In a array. Right it's kind of easy to do if you have a linked list right. So all of these things I think are good to think about we're not going to dwell a lot on. The data structure and which one is better than the other we're just going to kind of consider them all and see which one you know which one kind of. lends itself to which algorithm so but I think it's good to think about. Okay splitting the list and reorganizing This is something that will be doing with with merge sort. Now, how is it easy to split the list again it kind of depends on the data structure, maybe it's a linked list, and you can just break one of the links and then you have these two different things, but maybe it's an array where you have to. do in order to split the list you have to copy the second half over to another array and then erase all the things or copy both So there are a lot of things that that you have to do like under the hood. we're going to kind of sweep all that stuff under the rug for the most part. All that kind of hardware stuff. Okay, so. let's talk about sorting permutations suppose the only operation that we can do, I mean we can compare but the only like physical movement so i'll call it like a movement operation. Is swap any two positions that you want you and let's say that you have all the time in the world, and you can look at the. The permutation all you want and do as many comparisons, as you want, how would you sort the following permutations, in other words what sequence of swaps, would you use so that the result is the list in increasing order okay how about for this first one. Okay, I would swap. four and three now. We are. OK we'll swap four and three Okay, so this requires. Only one swap. Okay, how about this one. This requires two swaps right swap. To one then swap for three right. Okay, how about this one. You need three swaps. You to swaps. What do you do. First swap. For with two. right then. Two with one. Okay. And these are swapping the numbers right, not the position, so the numbers. Okay, so. These two things are both both require two swamps they're kind of a little bit different right. here. Does the order matter the order of swamps. It doesn't matter right because you could you could swap the foreign the three first and then the two and the one. What about here, what happens if you swap the two and the one first and then the four and the two. that's going to be bad right, so the order. Of the swaps. Right, can you kind of see the difference in those things. I mean, of course, for the first one you just do one swamp. Okay, so let's talk about where does that come from and what is the what is the property that that second one, has it the first one doesn't. Okay we're going to do that in a minute so worst case, in the best case, so if we're using this sorting algorithm that you can you can do any of these swaps. Which permutation requires the fewest number of swaps, this is easy right. sorted. Already sorted. i'm requiring. Zero swaps. Okay, which permutation requires the greatest number of swaps. reverse order so let's do 432 and one. You can swap. One four and 2342 swaps. So, is that the worst in with if you only have four numbers is that the is that the worst possible thing, or is there a link for permutation that requires three swaps. i'll give you all a minute to think about that. Okay yeah What about this 12341. Okay, so in this one we'd have to swap. The one in the two right. Then the two in the three so you swap the one of the two you get 1342, then the two and three, and you get 1243 right, then the three in the four. Can you sort this with fewer swaps. must take three swamps. yeah, so this is there are there are a few others that take three swaps, but this is one of them, so. The which permutation requires the greatest number of swaps and we'll talk about it it's a. i'm going to call a. single cycle permutation. And how many swaps in in general, does it take. And minus one. So to for a length for permutation the worst possible case is going to take three swamps and we found one that did take three swaps. Okay, so. How are we going to let's say that we have this permutation here. So this, this is the position. And this is the permutation. Okay, so I want to sort this whole permutation with the fewest number of swaps. This is what i'm going to do is i'm going to write the permutation in cycle notate. Okay, do you all remember how to do that. One way was to. To draw the graph. Right, do we want to do it that way. So one goes to eight. Eight goes 299 goes to seven and seven goes to one. To goes to six. Six goes to 1212 goes two to. Three goes to three. Four goes to five. Five goes to 1111 goes to 1010 goes to four. Okay, so this permutation has four cycles now when you swap things. Do you ever want to swap to things that are in different cycles. know. right because you're going to kind of jumble it up more what you want to do is you want to work on each cycle. themselves Okay, so let me write the cycles in there in the other way, so write them as. i'll just write them up here. So the cycle notation. is going to be 18972 612. Three and. Four 511 10. Right. You need right, you need K minus one swaps for every cycle of length K. Right and every time you swap you will decrease the length of that cycle by one Okay, so what you're what you're going to do is you're going to. You essentially right each cycle cycle backwards okay so. we're going to write each cycle backwards So these are the swaps i'm going to make seven nine comma nine eight comma eight one. Okay that's going to kind of on or whatever sort just that cycle and it's going to leave everything else, as they are right So the first thing is to swap seven and nine. and i'm sorry that I did this, but these are these are positional swaps. So swap position, seven and nine. So positions, seven and nine so swap those and you get eight six so i'll just go like this position 798-635-1112 791 410 two. Right now, if you if you write the cycle notation of this you'll see that seven. isn't a cycle by itself now. And one nine and eight are now in a cycle so we've kind of taken that cycle of like four and. Take basically kind of plucked seven out of that cycle right, because now, one goes to eight eight goes to nine and nine goes to one. Okay, so that was the first swap the second swap is nine eight. And remember, these are positional swaps so i'm going to swap the positions nine and eight. Alright, so that's going to be that's going to result in 863-511-1271 nine 410 two. Now you can see that nine is in its own position and then we're going we're going to swap positions eight and one. So that's positions eight and one or one eight and we get 1635 1112 789 410 two so we've kind of like taken this cycle and sorted just the cycle using three swaps. Okay, so, then, if we want to keep on going, then we would you know right each cycle backwards so 12 662. You don't need any swaps for a cycle of length one right it's already in its position, so you just keep it there and then 10 1111 554. Okay, any questions. So this particular permutation requires 12345678 swaps right. This example requires. A swaps. How do you calculate this eight. How do I know that it requires eight swaps what is that number from. Okay, good you sum up all the cycle length minus one, so you are cycle length are. We have 431 and four, so a sum up the number of swaps is equal to four minus one plus three minus one plus one minus one plus four minus one. Okay, good. So you can finish this sorting as an exercise. Okay, so here's a theorem let Sigma be a permutation of one through and then let Sigma B. C one C two ck be the cycles of Sigma then Sigma can be sorted using the sum of all the. I shouldn't have done it like that I should do it like this size of Sigma minus what size of see size of the cycle minus one and use some of them all up. And the theorem here is that. This is the minimum. And we're not going to go through the proof of it, but it would be kind of a nice exercise to kind of think about why this is the minimum and what what is the what is the reason. Like why can't you do it in fewer and fewer swaps and the end part of the argument is that. it's really bad to swap two. elements in different cycles right, because when you do that, you sort of linked the cycles together they kind of come together and that's not good. really what we want to do is, we want to kind of work on cycle and kind of do each cycle, one by one and sort them all and I guess the the other part of the proof would be to prove that in order to sort a cycle, it requires a cycle of length K let's say it requires K minus one. swaps minimum. Okay questions or comments. Okay, so that was sorting permutations permutations have this really nice property that the numbers that you're sorting are exactly the numbers one through n. And that made it easy for us to build the cycles now if you just are if you're just given sort of a random list of numbers. You don't know how to build the cycles beforehand, because, in order to know how to build the cycles, you need to know the relative order of all the numbers. I mean, this is a small list here, but if I just told you, you know if I just gave you 14 it would take you a minute to figure out that 14 is the second. smallest number in the list right it's not as immediate as having a permutation, and so we want to develop an out of rhythm that that still uses this minimum number of swaps but doesn't rely on knowing the relative order of the elements. Okay, so the difference here is that we don't know at first glance, which is the smallest element or in general, where the elements are supposed to go sorting algorithms figure this out along the way. And sorts them as you go and idea for sorting algorithm okay so let's think about this. let's think about the big picture, what is it we're trying to do, given a list. i'm a one through eight and we want to arrange the value so that a one is less than or equal to a two is less than or equal to all the way up to a N and I put less than or equal to this is increasing order. Excuse me, but you could change this relationship. To be whatever you want, maybe it's alphabetical order. Maybe it's decreasing order right whatever you need and the values really can be of any type that have an underlying total order. But for simplicity we're going to just use integers in this class, for the most part. Okay. Good. Okay, so if swapping any two positions isn't available operation, then we can use something called selection store selection sort of what it does, is it. It finds the smallest number and it swaps it with position one right, because we know that the smallest number has to go in position one, so we just swap it like that. Then that number, the first number is locked in place. And then we just do it with the next smallest number and swap it with position to the next smallest number swap it with position so on. Here is the pseudo code. hey you have a list of integers. You have a for loop that loops from one to N minus one you don't have to go all the way up to end because once you've sorted, the first and minus one smallest numbers, the end number has to go in the last position. Okay, you said, am to be the minimum of all of the number, starting at a I right we're going to start at one so that's going to be the entire list during the first iteration and then. And so on so on, as you go and then you swap am with Ai is going to be like the minimum element you're putting into place. here's more of like a low level. pseudo code. With. Finding. A minimum. spelled out. Right. I have a animation for you Okay, so how does Min sort work. The first thing it does is it finds the smallest element this case it's six and you swap that with the. element in the first position. Okay next smallest element seven. swab with the second position keep those smaller numbers in green because those are already in there sorted position okay next smallest is nine swap it with 32 okay next smallest is 11 swap it with. Next smallest is 14. swap that with 18 right next smallest is 16 swap that next small city teen swap that next smallest 20 to swap that next mile is just 24 so that just just just stays where it is. And then you have 32 you don't need to move right because it's already in place. So how many swaps did that require. hey you did one swap. To swaps. Three swaps. For swaps. 56788 swaps right and how long is this permutation 1-234-567-8910 requires. A swaps. Right and so it's N minus one of the worst case, but N minus one is nine So this was able to do it in eight So what does that tell you it tells you that. There is a cycle of length nine somewhere in there. When we go back. If we. If we talk about the permutation that the underlying permutation. it's going to be 1-234-567-8910. Right. Six is the lowest so that's a one than seven than 934-567-8910. Okay So what are the cycles, here we have one that goes to eight. Eight goes to nine. Nine goes to five five goes to four four goes to seven. Seven goes to six and six goes back to 110 10 goes to three three goes back to two so notice that we have one cycle of length 1234567 into the cycle of length three so that's seven minus one plus three minus one is equal to. six plus two is equal to eight so that's where those eight swaps come from, in fact, the the this sorting algorithm will do the fewest number of swaps. Okay, any questions or comments about that. So it is eight the minimum. eight is the minimum number of swamps yeah. And this procedure requires eight swaps, so it it actually did it actually did the minimum number of swamps, and this would be important if if swapping things were really. Intensive or you know resource intensive right let's say that uh. let's say that you're trying to sort cars right and moving cars is you know takes a lot of time and effort, so you know, maybe that maybe you want to figure out the best way to do it first. And selection sort is a really good way to go, because you're going to you're going to do it using the fewest number of swaps let's say that you only have two people and you're trying to sort sort cars. On like a busy road, so you know they always have to be parked right, so the only way that you can really do it is to sort them. Two at a time or swap them two at a time. I don't know, maybe that's not really like a real scenario, but. But does it do the minimum number of comparisons so that's we're going to talk about the comparisons. required and that's going to be a little bit more of a. it's a good it's going to be kind of a different problem to think about. When we're considering best and worst case, are we only counting swaps, for now, are only counting swaps but, but we are going to kind of move on to comparisons, because even though it didn't swap 24 right remember that it. It just 24 cut kept its position, it still had to compare. Right, it still had to find that comparison so it's not like we got that for free it's just like kind of in a certain scenario where you would need to wear a be very Labor intensive to do these swaps, this would be a great way to to do it. I don't think you need to care about the maximum number of swaps. yeah comparisons can also be Labor intensive so we'll talk about how many comparisons does it take. Actually that's The next thing right so on a list of length and how many swaps does this algorithm do it actually does the minimum. number. Of swaps. Which is equal to the some I equals one up to K see I minus one right where see I are the length of the cycles, is there, another operation, we should count yes. comparisons. And how many comparisons does it require. n times N minus one or two. groups. Okay, I guess i'll do it right here n times N minus one over to. So where does that come from. Well, in order to. In order to find. The minimum. of a list of length let's say. let's say a linked list of length are right requires. Our minus one comparisons. Right. So the way that you do it right is you kind of keep this running minimum and you update it every time you find something smaller, but how do you know it's smaller, you have to do a comparison and you only do it. Because the first the first element you just set as the minimum and then every subsequent element is a comparison. So. How many comparisons total does this algorithm make. Right, it makes. And minus one comparisons. When is equal to one in the first iteration because you're finding the minimum of the whole list and minus two when I is equal to two and minus three is equal to three all the way down to one comparison when is equal to N minus one, so you have one plus two, plus three. Plus, plus and minus three plus and minus two plus and minus one, and we should know that that's equal to this. Any questions or comments about that. How about restricted swapping What if we're only allowed to swap consecutive items. or adjacent items so maybe. I don't know what scenario would restrict you from doing that, but maybe your hardware, maybe it's a lot easier to do consecutive swapping rather than swapping any two elements. So, how would you start a permutation in this way. Just compare each pair as you go up and swap it if they're backwards and repeat across the list until they do no swaps okay. So. that's exactly what we're going to do so, the first thing you do is you look at the first two elements. four and three and since they're out of order let's put them in order so three four. Then the next two elements. Three they're out of order so put them in order. Then the next two elements they're already in order so leave them alone right. OK, the next two elements are out of order. So put them in order. And so on exactly bubble sort. Okay, if swapping only a Jason positions is the only operation, then we can use something called bubble sort so, given the list a one through a n. Compare the first two elements and swap them if they're out of order continue all the way up to the end of the list, now a consequence of doing this is that the largest element will be at the end after one iteration or after one pass. So you can kind of lock that element in and start over from the beginning to get the second biggest and the third biggest and so on. Okay, so this is how it works. You have this double loop, and you make the comparison of consecutive elements AJ and AJ plus one if AJ is bigger than AJ plus one and swamp them. You just kind of go up like that is called bubble sort because you can kind of think about like the largest bubble is like the largest element that will float up to the top or to the end of the list, and then it just kind of bubbles up each. Okay, so. I think I made a few illustrations let's see if this is the one that that works Okay, so we look at 41 and 75 there in order so don't do the swap okay. swap those 75 and 50 to swap those 75 to 85 are in the right order okay so leave them alone 85 and 3485 and 4985 and 63 now 85 is the biggest number it got bubble to the top every time you do that, it bubbles, the next one, up to the top. So the next biggest element is 75 that should in theory bubble to the top in the next pass let's see. 14 and. They swamp 41 and 5252 and 7575 and 34 out of order 75 and 4975 and 63 okay now 75 is in its correct position. Okay do it again and the next one should be the next biggest which is 63. All those are in order, those need to swap those need to swap and those are in order so 63 is there. Now we do it again and let's see what happens 18 and 41 or in order 41 and 34 swap 41 and 4949 52 so lock in 52 okay. Now next thing is watch this 18 and 34 in order 34 and 41 or in order 41 and 49 or an order. We didn't do any more swamps so once you figure out that you don't need to do any more swaps, you can you can be sure that you're done. The other questions about. In this. In this original. Implementation of bubble sort this is sort of like an a naive implementation, it goes through all of the passes it ignores whether or not it's sorted or not, it just kind of blindly goes through. But there's a there's a version of bubble sort where you can kind of do this early abort of the algorithm when you find out that it's already sorted, could you keep track of the last index you swapped and just never iterate that far again on each pass you know that's another. Another way, I think that you can save some time. Okay, so early exit pseudo code is that. Oh, I didn't even write it in there. I guess what you can do is a. have some sort of you have a like a line in here that says like. sorted equals true right and then every time you swap something, then you change it to sorted. is equal to false. And then out here, you say right or. No, sorry you want this to be out here. And then out here, you say if sorted is true. and Exit loop. Something like that. Right so yeah the naive bubble chart is good because it's short and it's kind of my it's almost. A little bit mindless right it just kind of goes through, and does this thing and stops when it's done it's just a simple double loop yeah. Okay, how many swaps does this algorithm do in the worst case. Anybody know. More than N minus one I mean this one, for example, how many swaps to this one do. You count them. I did want to know 1-234-567-8910 1112 12 swaps. Okay, how many swatches is doing the worst case right if the if the list is in reverse order, then that means. Every iteration you're just kind of bubbling the biggest element, up to the lab up to the end right, and each time you do that buyers and minus one swaps for the largest and minus two swaps, for the second largest and minus three and so on. n times N minus one divided by two. Is there any other operation, we should count comparisons. How many comparisons does it do. Also n times N minus one divided by two. it's kind of for the same reason right, and you can you can even see that in the animation right you're you're doing you're doing N minus one comparisons, no matter what, in the first pass and minus two comparisons in the second and minus three and so on, and. If you're doing the naive bubble sort, then you then you will always do exactly this many comparisons. Okay, so let's do a little bit of comparison here men sort or selection sort the number of comparisons was always. And times N minus one over to. The number of swaps was. N minus one in the worst case. And zero in the best case. Okay bubble sort. Was number of comparisons n times N minus one over to for. naive bubble sort. and less than or equal to n times N minus one or two for early exit bubbles or. Okay, the number of swaps is going to be n times N minus one over to in the worst case. And the best case is also zero. This is for a sorted list. This is for a reverse list. over here the best case here is sorted. And the best the worst case here is a single cycle. Okay, so does that mean that one of the algorithms is better than the other. Or does it depend. On what you're trying to do, or does it depend on what operations, you have available to you or what resources, you have available right it all depends so that's why we're going through both of them is that one is not better than the other in all scenarios. Questions about that. Alright let's jump into searching. searching is attempting to find an item in a collection indicate whether or not the item is found by giving its location. The index or the position or by returning negative one or zero or not found or something like that, depending on how you implement. Why do we need to search well. Finding files finding errors in a code searching, the Internet, even like the ranking algorithm we needed to searching if we were talking about ranking using. A dictionary right. You defined out where that bit string was and then output its position. Okay, so linear search is sort of like the naive way to search, while there are more items in the list look at the next item. Is this the item you're looking for, if it is then return the position, if not, then go to the next item, if you got to the end of the list and didn't find then print item not found. Pretty pretty straightforward, but even though it's straightforward I made an animation for it. Okay we're looking for the element okay so um is 19 the same as 20 know may as well, keep on going. Is 19 the same as 42 know. there's 19 the same as 16 know. Is 19 the same as eight know. Is 19 the same as. Yes. Okay, so, then you would output five. Questions about that. Okay here's the pseudo code for linear search. is just a single for loop. You ask every every element, you ask if it's equal to that element, or to equal to your target element X and, if so, return the position, otherwise return zero or. Negative one or. Not found. Depending on how you implement. So how many comparisons does this do in the worst case. And right and how many comparisons does it do in the best case. Right, so this is. If. X is last element. or not found. And this is if X is first Ellen. Okay, so the the worst case runtime this is usually what we're going to be looking at. or zero comparisons of n is equal to zero sure. i'm. The worst case runtime. Is a linear graph right the size of the input is the same length as the worst case runtime or sorry the, the number of comparisons. Right, so if I had a list of size 20 than in the worst case, I would have to do 20 comparisons right, so this is the graph for them. and number of comparisons is usually a good. estimation. of how long algorithm. Okay well let's talk about binary search. This can only be used if the list is sorted, so another way another reason that sorting a list is really helpful because binary search is much faster than linear search. How much faster well that's what we're going to look at in the next 10 minutes so divide the list into two smaller list based on a midpoint. The elements before the midpoint and the elements after the midpoint. Compare the target element to the midpoint if it is smaller search the elements before if it is greater search the elements after if it is equal return the position. Continue splitting the list and searching until the list has only one element, at this point, either we have found the item or the item is not in the list. Okay, so here is a pseudo code. The way that this works. is to have these um. indices that we keep track of and we're going to call them I nj in your other classes, maybe you call them low and high. They kind of the kind of define an interval of the list that we're looking in so we start I at the first element one we start at the lat or J at the last element and. And we kind of flip flop these things around to zero in on the on the element right, so if your target is our sorry the next thing you do is you find your mid point. And you do that by finding the middle of I put I nj right. So if you found the element, then you return the position you're all done otherwise if X is bigger. than you know you have to look in the right half of the list, so what that means is that you move I. To be n plus one right right after the midpoint and if it's if it's less than you move J over to be N minus one right before the midpoint. Okay let's look at how this works. Okay, so i'm looking for the item 21 okay So the first thing i'm going to do is set my I nj to be equal to one and 15. Then i'm going to. find the midpoint well, what is the midpoint you're going to do one plus 15 divided by two so that's going to be eight the big points eight. Okay, so, then you compare it. So 21 is less than 44. Okay watch this because this comes pretty fast ready. Less than okay so less than means, what do we move I, or do we move J. move J and where do we move it. over here. Now, in just that one operation. We have eliminated all of these numbers, this is why it's so fast is because every iteration you are throwing away half of your list. Okay, so, then we find a new midpoint. And do it again is 21 bigger or less than eight bigger than okay watch this because it comes fast ready. Alright, bigger than so now do we move I or Jay we move I. Now we move the midpoint and we move the number and now we are equal sore done. Okay, so how many comparisons does it do in the worst case, and how many times do we have to split the list so if n is equal to one you do one comparison and you split the list zero times. Right. When is equal to three think about it, you are going to. you're going to do you're going to split it once and you're going to do to comparisons right the first comparison in the worst case, the first comparison is with the middle element in the second comparison is either with the smaller one or the bigger one. You have like I am and Jay you really want to do two comparisons Okay, and is equal to seven right, we have to do two splits and how many comparisons, do we need we need. Three right, because if I will do seven. The first thing you do is you compare it to the middle one right and then you're back to the case of three in the case of three We only need to comparison, so one plus two is three comparisons. Okay, how about 1515 234568 you find the middle element you do one comparison, then you you basically do the the. The problem on a list of length seven which we already know takes three comparisons, so you get four. and so on, so, in general, if n is equal to to the K minus one, then you need K comparisons. Okay, so let's solve for K, because I want to know how many comparisons, I need in terms of n. Okay, so and it would be to the K minus one so n plus one is equal to two to the K, so that means that K is equal to log base to have n plus one. But since we're talking about. Comparisons, this is a whole number so we're gonna have to take the ceiling. Okay, so this is what the ceiling of log base to have n plus one looks like is these green dots here. Just like we saw before right these kind of jumps occur at three 715 and so on. So if we graph both of these we get linear searches this line we have binary search is a log function and it turns out that a log function is a lot lot. slower growing, then a line, but if the time of the function of time is growing slower, that means that the algorithm is actually faster so binary search is actually faster than linear search. I think I say it in the next slide. it's clear from the grass that not only is binary search faster than linear search, but the runtime of binary search. Is a smaller and smaller and smaller fraction of the runtime of linear search as the input size grows, or they kind of get like farther and farther away from each other, as you go out to infinity. How do we state this mathematically we say. binary search is ask them topically faster than linear search. On the other hand, we could say that the time. For binary search. Is a slower growing. Then the time. For your search Okay, so I don't really want you to get super confused on this, but it is a little confusing right because we're talking about time and you're talking about. speed and time and speed, as you know, are inversely related so just be. be aware of what we're talking about are we were talking about time or speed. Okay, so I think that's about it for today yeah we will talk about all these big O notation stuff maybe next time but yeah I think next time. So will will. will define all of these things. Okay, but really what it's what it's saying is that the time for binary search is little oh. Of the time for linear search, meaning that that function grows ask them topically slower than the other function. Okay, so let's end there and i'll stick around for 10 minutes or so, to answer any questions. Professor can you go back up to slide 44. Which one is that sorry I don't have the slide. yeah the one right after that. This one. um no it's the one it's the one right yeah that one I just need to write this down real quick. I guess I should write. Since. Okay. that's why we need the ceiling. Thank you. Anything else. How, you came up with the cycles yeah. Just do this example again. Okay, so. you write the presentation in to line notation like we have here. is to line. Okay start with one I always start with one. And follow one until. You get back. To one okay So what does that mean we follow one we start at one. One goes to eight okay. Okay, so who does eight go to eight goes to nine. where's nine go nine goes to seven. And seven goes back to one. So that is one cycle. And then to find the next cycle just look at the next number that you haven't seen yet so the next number that you haven't seen yet is to. So two goes to six. Six goes to 12. And 12 goes back to two so we've close that loop right and then go to the next one that we haven't seen yet three. Well, three just goes to three so you're done with that now pick the next one, we haven't seen yet which is for. For goes to five. Five goes to 1111 goes to 10. And 10 goes back to four. yeah. Since it's a permutation we're able to do this if you're just giving a random list then finding the cycles is not as easy right because the nice thing about a permutation is that each element. is one of the positions right, so you know exactly where it should go. That makes it easier. Okay anybody else. Okay, then well if that's all then see you all on Thursday.