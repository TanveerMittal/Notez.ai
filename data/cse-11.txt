starting to record. What else do we need to do anybody have any questions or comments, before we begin. we're working on your grade reports, hopefully they'll be ready today and that will have all the results from the Colonel blotto game so. it's kind of cool to see which strategies were the best. and we'll try to play it again, maybe after the second midterm. yeah. Alright, so let's let's continue along today we're going to do. The topic is going to be looping variants these are. used to prove that algorithms are correct Okay, so what is our what is on our schedule today. we're going to learn tricks for computing runtime for loop based algorithms so we're going to do that, first, and then, how do you prove the correctness of an algorithm so usually, when you talk about algorithm analysis. that the big things that you're talking about are usually runtime analysis and correctness right does your algorithm actually work. reliably and does it work efficiently now. On top of that, you can also talk about. Space efficiency but we're not really going to do so much of that in this class. Okay, so we're going to prove selection sort. is correct, using a loop variant well how do you do that, you state the loop and variant you prove the loop and variant using induction and then you use the loop and variant to prove the algorithm is correct, so there's three steps. will see it in a few examples. Okay, so first we're going to get into how to calculate run times. kind of a. standard way to get a loose upper bound and this might help you with with some of the homework problems. The idea is that if you have a loop, and you have something inside of the loop, then what you do is you figure out how long the body of the loop takes. right if the body of the loop runs in big of T one of N, this is in the worst case. And the loop itself actually runs Bingo of T to time times. Then the entire loop or the entire process is going to be a product of those functions big of tier one times T two. And the idea here is that in that while loop you're gonna do have to do at least as much as or no at most sorry, at most, as much as T one event you're going to do that T to event time so that's why we're multiplying here it's kind of like the product rule. Okay, so let's look at selection sort the pseudo code and kind of talk about. How to calculate the runtime now what is it that we're really calculating. What we're really counting. The The thing that you're doing the most is these comparisons so let's count this by the number of comparisons and you'll see that that is sufficient to counting the whole thing because everything else is going to be. kind of done at the same time as the comparisons anyway, so if you count the number of comparisons you really are you know, having a good idea of how many operations total we're doing. Okay, so. let's talk about let's kind of work from the inside out so this. line here. is going to be a constant time operation comparing is constant time to small numbers is Constantine. assigning a variable and is equal to Jay is also Constantine so that body of that inner loop is constant time. Right. about this. Well, this runs big of n times. In the worst case. right because, in the worst case is equal to one and then Jay has to go from two up to n. So this whole. This whole loop will run big old and. Big of n times one. Big of an times one. Okay now let's talk about the body of the outer for loop. well. We didn't really talk about this, but if you do certain operations in a row like if you do them and then do another one and do another one, then you add their run times so really what we're doing is we're adding the runtime of that inner loop. Plus, however long it takes to do this, plus however long it takes to do this, which are both constant time operation, so they kind of get lost because, in the worst case, this is big event, so this so this body is going to be bigger of n. Plus. Which is just big event in the worst case. All right now. You have this thing runs. And minus one times. So big. And so the actual runtime of the whole algorithm. is going to be big of n times and which is big of n squared. Okay, any questions or comments. So you multiply. When. You are. Talking about loops. You add. When. procedures. procedures. are run. one after the other. make sense any other questions or comments. want you to to notice here is that this is a upper bound right we're using big oh here. If you want it to get a tight upper bound like a big theta upper bound you'd have to be more careful okay anybody tell me where we were not very careful in this. In this analysis. The inner loop exactly right, this is. Bigger event times in the worst case right but that worst case only happens once right so do they even out right are there more better cases than there are worst cases So these are. These are kind of questions to think about. But this is fine, because this is true, this algorithm does run in big of n squared because remember big O means upper bound. it's also true that this algorithm does run in big data of n squared time and now with sort of the the methods that you've been practicing in the homework, you can probably oh you can't hear. No. i'm going to maybe I can move the microphone a bit closer. um what was I gonna say. Okay, you could do a more detailed analysis on this right, and you can you can actually count the exact number of. exact number of times that you compare things and base your runtime off of that, and you can get a big data bound. But for right now we're just talking about loose upper bounds. Okay, so here's another example, something triples. So, given a list of real numbers a one through a n look for three indices I J and K between one and such that Ai plus AJ is equal to Ak so, for example, does the list 36578 have a seven triple. Yes, right so three plus five plus eight right, so if we if we index them as 12345, then the indices 135. Is a something triple. Questions about that. Okay, so how would we make an algorithm to do this. i'm just going to kind of go through. A sort of sequence of algorithms that get kind of better and better and better, as we go let's start out with sort of a brute force thing. Why don't we try out all possible combinations Okay, so this is might be sort of the first thing that you think about. Maybe you all were already kind of thinking, this is one way to do it, so we have a nested for loop. Right, we take it from one to n J from one to n K from one to end and what this is doing is it's going through every single combination of I J and K. And then you just check if Ai plus AJ is Ak then return true So what is the order of the runtime of this algorithm it's pretty easy if you if you kind of understand how how the multiplication works, but let's go through it just like we did that other one. Okay, this guy is bigger have one right to do a comparison. This thing runs. And times. So this loop here is big of an. Right. This thing runs. And times so you have big of n times n. This thing runs. In times so you get bigger and times and square. This is big and cute. This is an upper bound elusive about this is actually a tight upper bound to write because. You can just see that, in the worst case it's going to have to go through every single possible combinations of I J and K, where I J and K can be any of the numbers from one to end really what you're doing is you're building a three letter word using the letters of. The numbers went through and or you can think about it as a three elements sequence of using the letters one through and so we've already counted these things, and there are there are, let me just write it there. are actually. And cubed. combinations know I should say sequences. Say three element. sequences of letters. No, sorry numbers. So you're actually doing in cube time, so it really is a theta but we're just kind of doing this, these loose bowels right now. Okay does anybody have any improvements that we could do. It can use the same number twice, so it won't work. Are they all start at one. Because what if the first number is zero then zero Plus zero is equal to zero, and so you can just have you know I J K all ones. Okay, good so let's yeah let's there's a few good comments in there, so we're going to kind of do a few of them, so one comment is that. summation. Is commutative. Does anybody know what that word means commutative. Just it's the same back and forth right a plus B is equal to be plus a so you're doing a lot of redundant work right because, for example. If I is equal to two and J is equal to five, and you do a two plus a five whatever you get seven or or maybe that's not whatever you get from that. that's the same as if you had a five plus a two so really you don't need to calculate both of those because you're going to get the same answer because summation is commutative. What that means is that you can always force I to be less than or equal to Jay or the other way around, how do you do that. To eliminate redundancy you start J at I. write it again. Okay, so what's the order of the runtime of this algorithm well we'll do the same, will do the same analysis will go to kind of go through it quickly, this time, this is Bingo of one this is n times. Right, so this guy is Bingo, and this is going to be and times in the worst case. Right, so this is gonna be big of n times n right but remember this is the worst case, but we're trying to just get a loose upper bound. This is bigger this is n times. So big of n cubed. Okay, so we get big old n cubed again. see me. So. Did we improve on the on the runtime here is this bound. Did we kind of bring that bound down or. Okay, so not really, but we still did improve the efficiency, you know so. that's going to be important, you know, in the workplace or what do you know what whatever you're doing. improving efficiency is great. But we didn't really improve it, by asking topic we didn't improve it as a topical, which means that. it's not a significant improvement okay so. dude. Okay, so can we do more improvements. So really kind of what this algorithm did like refit reframing how we did it is for each of those candidates, a one plus eight sorry Ai plus AJ. We basically do a linear search to find it that's kind of the the idea behind this right you kind of get those two things, and you, you search to see if it's in there. So what's better than linear search is binary search, I think, somebody already said that. But in order to use binary search, you need to sort everybody so first sort. A one through and. Then, for each candidate some Ai plus AJ making sure that we we take care of the redundancies binary search Ai plus AJ. In the list. Okay, so how long is this going to take. So the inside of this loop here. I guess we'll do it like this. How long does binary search take. Bigger of. log event. Right. So that's that inner loop, then this next loop here is going to take. In the worst case n times right. So you have. Big of n times login. And then, this outer loop. is going to take. And times so there's going to be big old n times analog in. Right and then how long does sorting take. well. For right now let's let's say that we're using selection sort. Selection sort. takes big of n squared time. Okay, so do we add this the the sorting algorithm or do we multiply. We add right because we're sorting it first. Think about it this way you sort it and then you're done with sorting and you get to move on, so that time that time has already elapsed you don't have to do the sorting a bunch of times you don't have to multiply so you add. let's see, so this is going to be. Bigger of n squared plus and squared login. And by using sort of the simplification rules, we can simplify this to just big of n squared login. Questions about that. How did you get big of login that's a that's something that we did with. We did that last week when we talked about binary search binary search takes login big old login runtime. We kind of. We kind of calculated instead the exact number of times remember i'm binary search. On input. Of length. And does what was it, it was the ceiling of log base to have n plus one. Something like that, so this this thing is big of login. Right, so that we that was like a little comment I made, I think, last Tuesday, is that. When we talk about these awesome topic run times we usually just write log and it doesn't matter which log, it is because all logs are constant multiples of each other. Right, whether you do natural log log log base to log base three log base 10 whatever you want. Okay, so some is the maximum here, just like we said before okay good so um can we make progress here, yes, we did right we actually found a you know we we didn't have to do a lot of. Counting we just kind of did this loose upper bound, but we were able to show that. This algorithm with the binary search is ask them topically faster than our first algorithm. Right. So I call this some triples three it does better than big of n cubed right big of n squared login is better than big open QA. But we're going to see this other sort called merge sort and it is faster than selection store it's an login but that's not actually going to help overall, I guess, I should say as syntactically. Right let's go back for a SEC. kind of got cut off, but. notice that, where if they if we're using selection sort. Then we get n squared if we use a faster sort like n log in you're going to see that it it uh you're still going to have to do all of this work for the N squared login so it's not going to kind of be asked them topically more efficient it'll still cut down the time probably but. it's kind of like what are you looking to do, are you looking to get a. asim topically faster algorithm or are you just trying to shave off a few calculations. Okay, the fastest known algorithm to do this. Is big goal of n squared times so you all can think about that as an exercise. Okay. So let's go back to this product rule let's revisit. If the body of the of the loop enter the body, the inner part runs into one time, in the worst case and the loop runs T too many times in the worst case, then the whole thing takes big old T one times T to. But what if many iterations are much better than the worst case, what if the worst case only happens a few times, is it possible that this is going to be a very, very loose upper bound. Okay, so let's look at this other example. given to sorted lists. be one through bn determine if they're indices I J such that Ai is equal to be J, so how would you all propose to do this. Okay, good, so we can binary search every every day into the B list. binary search. Oh hey I. In the B list right. Until we find one. How long is this algorithm going to take. In the worst case. And login okay good big of an login. Okay, so let's keep that in mind we're going to actually do something different, but this is a kind of a good good starting point, or at least, is a good. benchmark, to see if we can do any better. Okay, so i'm going to use linear search instead of binary search and see if be one is anywhere in the first list but whenever since A and B a since the A and B lists are sorted, I can kind of. Compare that element that be element be one until I find in a that's bigger right. So you kind of compare be one with a one if be one is bigger than a one then keep on moving right until you find a one that's bigger than B and then stop there, but then you can you can start where you left off on be too, because you know be two is bigger than P one. right because search for be to where you were that one left off and, in general, start the search for bj where the search for bj minus one left off Okay, so this is kind of how the algorithm would look um you can kind of think about it as like the Ai is the index for the a right. And the J is index for be. For the bees. bj now if you're like me, you get lost in all these indices and it's kind of a mess, but we could kind of go through it just so you can. You can sort of see. what's really going on. Okay, so you start with is equal to one that's the a. Right and. you're going to loop through all the bs but, as you loop through the bs you increment the eye right so. While bj is greater than Ai right if be one is bigger than a one, then you increment I and you go to a two alright, so I kind of takes you. Through the a list. right but notice that. right when you come out of this when you come out of this while loop. I guess, these are our ending conditions right if you ever find something, then you're good and if I goes to the to the end of the list, then you're then, then you haven't found anybody, but notice that when you go back into. When you go back into this for loop I doesn't reset right, so it gets left off from where you were before that's kind of the big thing. Okay, so how long is this going to take well these things are going to be both constant time this while loop takes big of an time in the worst case right. The worst case would be that be one is greater than every element in a. Right, what would that be. Well, if statements, always be. bigger one. He most of the time, most of most of the time that if statement is a comparison you're comparing two things right. So, usually usually if statements are going to be big of one. Okay, so if be if be one. is greater than all the elements of a in the worst case. Then this while loop is going to run and times. Right. So that's that so that means that this entire body is gonna be big of an in the worst case. Oh that's what I want okay good, so we have that. Now notice that this thing in the worst case runs. And times. Right, so the total year is going to be and times and write the entire algorithm is going to take. Bingo of n times and which is Bingo of and squared now Is this correct. Does this algorithm running and Bingo of n squared time. Okay, good, there is a, this is a correct upper bound exactly, but there is a tighter bound that we could we could calculate if we're a little careful. So. If you're a little bit more careful on on counting the number of operations, then you'll see that this. This while loop right, it will execute. Bingo have to end times and the way one way that you can see, that is, that. Each a I and bj. Is. considered. At most. Once right it's kind of like think about it this way that the a list and the B list you're only kind of going through them in one direction you never get reset so in the very worst case you got to consider all the a's and all the bs but that's just going to be too and considerations. And so, in the very worst case you're gonna you're gonna have a. Big have to and bound. yeah you can think about it this way to write the the eyes and the jays are only increasing. right they never go back so how many operations, do you have to do in the worst case well just think about it, that you have to do. I from one to end nj from one to end so that's going to be two and operations, which is going to be big event, so this is just a warning that this product rule is not always tight. it's always correct, but you know you're just going to get this upper bound, it might not always be tight. Is it fair to say that if algorithm has no comparisons big O and big data are equal. And I would I would not say that. know where that's coming from. Big data are never equal. Let me say it in a different way, big and big feta are two different they have two different definitions, so I don't know what you mean by. I don't know what you mean by bigger than big feta be equal. To n is equal to big event right, yes, yes. Because of that constant factor. Okay sorry any other lingering questions. know the whole algorithm is big event. But in order to count that i'm counting how many times this while loop actually. executes. worst case is not it Okay, so this is a little tricky the worst case is Bingo of n squared but there's a tighter bound on the worst case, the worst case is also big of n. But it's it's like that we're using this big oh so it's kind of like you can you can say that the worst case is big of n factorial or end to the end right, so if you're using big ago then. Then you can have any upper bound. But I would say that the worst case is big theta of n. So worst case here. Is. Big data of N and why is that well we why. Well, first we argued that the runtime. Is big of and right we've already argued that, so we have upper bound and the lower bound has got to be an also right because. In the worst case. You have to look at all of the elements anyway, and so, in the worst case, the lower bound is also big big Omega van. Since. You must. At least. Consider. Every. element. The runtime. is also big Omega event, so you got big and big old mega event that means you have big data event. Okay, any other questions. yeah you're trying to find if there's any a's in the B list or any or if there's any bs and a list is the same. The same problem. All right, let's move on to loop in various so we kind of talked about how to do some general runtime analysis now let's talk about how to do some correctness proofs so a loop and variant is a property. That remains true after each time the body of a loop is executed what is looping variant mean in variant means not changing. Not. Changing. So the three step plan you need to first state your looping variant. Prove that it's invariant by using induction and then use that invariant to prove that the algorithm is correct this usually. involves. showing that the loop very is correct, at the end of the algorithm and that will imply that the algorithm is correct. Okay, so let's do a let's let's prove the correctness of selection sort or men sort. remember how this works. You find the minimum element. In the list and you swap it with the first element, then you find the second element in the list you swap it with the second element, and the third, and the fourth and you basically kind of build the sorted list like that. Okay, so here's kind of like a more mid level pseudo code right you you set a m to be the minimum. Of the list, starting at a I right, and then you swap Ai with am so when is equal to one you swap them the very minimum, with a one and a two and so on. Okay, so I have this. kind of show. This thing. is supposed to be like a YouTube link. Oh, here we go. Okay, so you see that minimum down there. is very annoying sounding but I kind of like it. Right so it's finding the minimum, you can see that it's like blinking. Right and then it swaps it when whatever was was in the third place and. There there it is strength. going to stop it right there for just a SEC. Can I get rid of that thing. Okay Why am I showing you this video. it's because I really liked that sound know the reason is because the. The looping variant is really easy to see with this video. The looping variant is going to be something like this. After. The first. TEE iteration iterations. Of the loop. What can we say is true what have you done you've been building something right you noticed that, like the whole right side of this thing is a bunch of jumbled mess, but the first TEE. values. Are kind of put together in a nice way okay good So the first TEE elements are sorted. Okay there's actually another looping variant here. What else can you say about those first TEE elements. Can I draw on this thing. I can do it if I do this watch this. This. should be under there I draw a line you see that. These elements, just like you said, they are the smallest T elements so they're sorted order and they're the smallest everything to the right all that jumbled mess that only has those elements that are greater than all of the sorted things and that's going to be important. OK, so the first. The first key elements are sorted and I know I wanted to do it in. PowerPoint. And they are the smallest key elements. Okay, so it's like in the middle of the middle of the algorithm and you want to kind of, say, a general property in the middle of the algorithm. And then we're going to use that to say well this property holds for after every iteration so it's going to hold after the last iteration, and that means everybody's sorted okay so let's finish up this video. Okay cool. or annoying. Okay So what are the two variants for select. Sorry, after T iterations the first. or let's do it like this, the first. TEE elements. Are one in sorted order. And smallest. Okay, so that's the stating the loop and very now let's prove it. On actually I think we're going to skip to Part three so remember the loop invariant proof has three parts, we have state to live in variant prove the loop and variant is actually true. And then, once you show that it's true, why can you conclude the program is correct, so let's jump to three assuming that we've already done two and then we'll go back and do two. Okay, so if we know that the looping very is correct, then for any number of iterations from zero to N minus one the loop and variant is true after T iterations. In, particularly the loop and very is true after N minus one operations, if you go back to the actual pseudo code. notice that this loop only runs from one to N minus one so after N minus one iterations the algorithm stops and hopefully all the elements are in sorted order. Okay, so based on the loop in the loop invariant the first N minus elements and minus one elements are in sorted order that's good and the first N minus one elements are the smallest now those two pieces of information are enough to show that the entire list is in sorted order. right because. The first N minus one elements are the smallest implies that a and the last element is the biggest and so, if you have a sorted list of small things and you put a big thing at the very end, the result is all sorted. And this is why we conclude that the whole list is sorted and this is the exact algorithm specification. Questions about that. Okay, so we're now we're kind of have to do the meat of the problem, the the main part which is proved the loop and variant is correct. And that's where we use induction. OK, so the base case is going to be it's true before the algorithm even starts it's true before the loop before the first iteration or instead of saying before the first iteration we usually say you know. When T is equal to zero so after zero iterations right after zero iterations. This means before. The first. loop. And usually this is going to be like a trivial case and we'll see kind of how that works for this particular example. And then the induction step is usually going to be a regular induction because what we're doing is we're just going to assume that it's working after T iterations and then show that it works after the next iterations T plus one T T plus one, or, if you like, T minus one two T right but. notice that we just need it to work on the previous iteration to show that it works on the next iteration then we're done. Okay, so. In general, for a loop iteration proof the induction variable is the number of times, through the loop. Okay deduction steph you just say suppose that the statement holds after tea time for the loop for some tea and then show that the statement holds after T plus one times just regular regular induction. Okay, so let's do it for this example. base case after T equals zero after zero iterations the loop in various states that the first zero elements are in sorted order, this is vacuous Lee true or it's trivially true sometimes we say. Because. The empty set is our is a sorted set. Right. Okay second thing is the first zero elements are the smallest also trivially true. Right there's no element in the empty set that's bigger than any other elements so that's also trivially true so it's Nice that these. That these lupin variance they start out true and that's that's important so that, when we go through they remain to be true, as you go any questions about that. Often the base case of a loop and variant proof requires you to state, something that is trivially true about the empty sad or the set with just one element, or something kind of like. Something like that, what if you have negatives. What do you mean. Like the in the input. negatives aren't really gonna i'm going to matter much right because you're just going to put them in sorted order. Right so doesn't. With selection sort when you find the men you just find the minimum element, and so, if you have negatives in there, then it'll find. Those just using the minimum function okay inductive hypothesis suppose that for some tea greater than or equal to zero, the loop and variant is true after T iterations okay great. show that it's true after T plus one iterations, how do we do this. We kind of have to figure out what the algorithm is doing in that T plus first iteration. Do. T plus first. iteration. Well, the first thing it does is it's it finds the minimum of that set right. Oh, I have it right here. During the T plus first iteration the algorithm finds am right which is the minimum value of all of these elements from a T plus one up to an. So, after the T plus first so yeah you find the minimum value and then you swap them. Right and so after that. Operation 80 plus one is the minimum value of this set here. Now, how is that going to be helpful in showing that this loop invariant is true. We have to remember, we have to show both of them. Okay well in order to show the libertarians true is true we're going to need this induction right, and you know we didn't do induction for nothing let's use the induction to help us so by the inductive hypothesis. The loop and variant is true after T iterations, which means that. The first TEE elements are. In sorted order. and The smallest. So we get that for free, how is that going to help us right well. We what we want to show. That a one through a ti a T plus one. are sorted. And the smallest. Okay, so that's that's not a huge jump right, we just need We already know that a 180 are all sorted and small and we're adding this new element at plus one, and we just need to show that if you add that to the list it's still say sorted and it still stays small. Okay, so let's do to first. That these ones are the smallest, we want to show that a 180 plus one or the smallest and that's actually pretty easy to do, because we know that. 80 plus one is the minimum. Of the list a T plus one, through a an right because of that operation so 80 plus one is smaller than 80 plus two through a N and it's already bigger than all the other elements a one through at and so. A one through 18 plus one, are the smallest T plus one elements with the original list okay good. So that's that takes care of two now. Why are they all in sorted order well you already know that a one through a tier and sorted order, and you know that a one through at are all less than 80 plus one, so what happens if you take a big element and put it at the end of assorted list the resulting list is sorted. Okay, any questions or comments about this proof. So, then, the libertarian is true so we're done we're done here. Okay, so let's do another example we'll kind of do this one start from scratch okay. So, given a string of zeros and ones, we want to count how many times a sub string 00 occurs design algorithm to solve this so maybe this is what you're thinking of doing. is to have some variable let's call it count that increments every time you encounter that particular pattern we're trying to see. Trying to see how many times this sub string occurs 00. I guess maybe let's do an example, so if you had the string 110101001000100 or something like that, then how many times, does this pattern occur. It occurs 123456 times. So one way that we can do this is just kind of have like just go through the list from left to right and every time you see two zeros in a row you increment that counter. Okay, so. If n is less than two then return zero there's no way there's no possible way that you could. have an occurrence, with fewer than two elements, otherwise have a loop that goes from one to N minus one. Right and if bi is zero and bi plus one is zero then increment the counter. At the end of the algorithm return counter now if you were to see this algorithm you might. You might just be convinced already you're like yeah Of course that does what you want it to do that sorts it but we're using it as kind of a toy example to show off how to use a loop variant proof. To guarantee the correctness okay. So what is the looping variant for this algorithm after the first TEE iterations of the loop. What can we say is true. Count okay yeah so count a variable count. is equal to. The number. Of 00 occurrences. In the list. be one through BT right in that list so that means when the algorithm is over, that means that you've done. N minus one occurrences. or N minus one iterations. So the count is going to be right, the number of 00 occurrences in the, I guess, this should really be in the list be T plus one. right because it's going to he's going to look at I, and I plus one. Okay, any questions about the the loop invariant claiming that it's or stating what it is we haven't proved it, yet this is more of like a conjecture, or like a guess. there's i'm guessing that this is the thing that's going to help us, I mean it certainly will help us in the end, right, because if this is true, then when when T is equal to N minus one account will have counted the number of 00 occurrences in the entire list. Okay base case Okay, so I did kind of mess this up, this should be P T plus one. Okay base case let's see. After zero iterations. count. is equal to zero right. and There are zero occurrences. 00 in the empty list done. Questions about the base case. Of be one oh yeah right. Right, because this is what we're claiming frank yeah you're right. be zero plus one right. But still it's true. Okay inductive hypothesis okay so remember this is plus two, plus one suppose. That for some tea greater than or equal to zero. After T iterations. count. Is. The number. Of 00 occurrences. d one through be T plus one. Right Okay, so what we want to show. Is after. T plus one iterations. Is the number. Of 00 occurrences. and be one through be two plus two. Okay, so inductive step remember what we did before you kind of you kind of want to figure out what's happening in the T plus first iteration Okay, so what. happens. In T plus first. iteration. Okay, so for this particular algorithm we're gonna have to kind of break it up into cases and the cases are based on this if statement here. Because either you found an occurrence, or you haven't but you need to show that in both cases the loop and variance stays true so case one. Bi is zero and. Sorry, be T plus one is zero and BT plus two is zero. Right. Then. The number. Of 00. or sorry then count. is set to. Count plus one. Now this count here. Right. Were. previously. count. Was the number. Of 00 occurrences. be one through be T plus one right. So. You add one more occurrence. For the B T plus one be T plus two occurrence right. Therefore. It is correct. That. Count should. Be incremental. By one. it's just like you found a new occurrence you just added one. oops. Okay we're not done with this. case. Is that otherwise. been T plus one be T plus two. is not a 00 occurrence. In this case. Count doesn't. Change. And that's that's correct. that's correct. Because. The number. Of 00 occurrences. and be one through be T plus one is equal. To the number. Of 00 occurrences. In be one through BT plus two. It doesn't change because you know that that those last two don't make an occurrence, so you can essentially just kind of forget about BT plus two, you know BT plus two does not. is not part of any occurrence so just throw it away and you just get the number of occurrences in that other list. So in. In either case. count. is equal. To the number. Of 00 occurrences. In be one through be T plus two. OK, so the loop in varying is true, this is the end of the proof for the looping variant is true, but this is not the end of the proof of the algorithm is correct, we haven't done that part, yet we need to kind of leverage this loop invariant to show that, after algorithm is over. The The thing that we want the algorithm to do it does right so let's let's look at that. Okay, so let's restate the loop and variant. This is kind of like the part three, prove. algorithm. is correct. Okay So how do we do that. We say so we know we have proved we have. proven. loop invariant. is true after. T. iterations. For all T in between zero and minus one. And then, this is usually how this part goes you say in particular. looping variant. is true after and T is equal to N minus one. or when T is equal to N minus one or after N minus one iteration. Usually kind of like plug in the last iteration for T and show that the result of the loop invariant is equivalent to the algorithm specification, the problem of specification. Particularly loop is very is true after T is equal to N minus one. In which case. count. is equal to the number of. occurrences. 00. In the entire list. This is exactly. The. The goal. Of the algorithm. algorithm is correct. Any questions or comments. back to the inductive hypothesis lie. Okay, so let's end it there and then on. On Thursday we're going to see some recursive algorithms and talk about how to analyze those run times and correctness proofs. But i'll stick around for a little while to answer any other follow up questions you'll see that recursive algorithms are. Or, in my opinion, there are a lot easier to prove they're correct because you don't have to do any of this loop and various stuff you just kind of have to do an induction. The part that link to like to your second sorta it was was that, too, and again. So, like for the one in this one. So there are. The the entire list. Right is of length to end. Right and. The. This algorithm in the worst. possible case you're gonna have to consider every single one of those elements. Yes, so, in the worst. Case they're going to there's going to be to an operations. But wouldn't like so we're combining into one single list. Like from A to B in like we're considered as a single list or. We can consider it, however, you want i'm just saying that the fact of the matter is that there are two n elements. Total. So, but wouldn't a like because seriously repeatedly for each iteration of be. So yeah. Like before I before he duration wouldn't be like a one to be considered like once after each loop of V1 to V2 like for be one is going to become certain times and for me to. is going to be considered times again. So that that doesn't happen here, and the reason is because this is equal to one. It only ever is set at the very beginning of the algorithm and then, once you get in it doesn't it doesn't reset back every time you go to a new be element. Okay. You start where you left off in the a so it's kind of somebody was also talking about kind of like having these two flags, you can kind of think about it as like these two pointers to the a list and the B list and. They kind of like move, you know the kind of like both sort of inch their way. Through the lists, but the. The key observation here is that they're both only moving in one direction so in the very worst case, this point or has to has to point to. All elements of a. And this point, I have to point to all elements of B, which means you've pointed at. Two elements. All right, got it Thank you. Okay, see you off i'm going to. meet with a ta real fast so stop recording but i'm.