WEBVTT

1
00:00:01.050 --> 00:00:02.340
Miles E Jones: starting to record.

2
00:00:05.370 --> 00:00:09.870
Miles E Jones: What else do we need to do anybody have any questions or comments, before we begin.

3
00:00:14.250 --> 00:00:24.630
Miles E Jones: we're working on your grade reports, hopefully they'll be ready today and that will have all the results from the Colonel blotto game so.

4
00:00:25.740 --> 00:00:29.520
Miles E Jones: it's kind of cool to see which strategies were the best.

5
00:00:30.930 --> 00:00:31.740
Miles E Jones: and

6
00:00:34.500 --> 00:00:36.960
Miles E Jones: we'll try to play it again, maybe after the second midterm.

7
00:00:46.860 --> 00:00:47.280
Miles E Jones: yeah.

8
00:00:49.050 --> 00:00:52.920
Miles E Jones: Alright, so let's let's continue along today we're going to do.

9
00:00:54.180 --> 00:00:57.720
Miles E Jones: The topic is going to be looping variants these are.

10
00:01:01.110 --> 00:01:07.380
Miles E Jones: used to prove that algorithms are correct Okay, so what is our what is on our schedule today.

11
00:01:10.050 --> 00:01:19.650
Miles E Jones: we're going to learn tricks for computing runtime for loop based algorithms so we're going to do that, first, and then, how do you prove the correctness of an algorithm so usually, when you talk about algorithm analysis.

12
00:01:22.290 --> 00:01:31.050
Miles E Jones: that the big things that you're talking about are usually runtime analysis and correctness right does your algorithm actually work.

13
00:01:32.130 --> 00:01:36.360
Miles E Jones: reliably and does it work efficiently now.

14
00:01:37.560 --> 00:01:39.960
Miles E Jones: On top of that, you can also talk about.

15
00:01:41.940 --> 00:01:46.890
Miles E Jones: Space efficiency but we're not really going to do so much of that in this class.

16
00:01:48.750 --> 00:01:50.940
Miles E Jones: Okay, so we're going to prove selection sort.

17
00:01:52.860 --> 00:02:05.130
Miles E Jones: is correct, using a loop variant well how do you do that, you state the loop and variant you prove the loop and variant using induction and then you use the loop and variant to prove the algorithm is correct, so there's three steps.

18
00:02:06.570 --> 00:02:07.980
Miles E Jones: will see it in a few examples.

19
00:02:09.510 --> 00:02:15.150
Miles E Jones: Okay, so first we're going to get into how to calculate run times.

20
00:02:18.450 --> 00:02:19.320
Miles E Jones: kind of a.

21
00:02:20.460 --> 00:02:26.850
Miles E Jones: standard way to get a loose upper bound and this might help you with with some of the homework problems.

22
00:02:28.680 --> 00:02:39.720
Miles E Jones: The idea is that if you have a loop, and you have something inside of the loop, then what you do is you figure out how long the body of the loop takes.

23
00:02:41.280 --> 00:02:50.160
Miles E Jones: right if the body of the loop runs in big of T one of N, this is in the worst case.

24
00:02:55.500 --> 00:03:02.610
Miles E Jones: And the loop itself actually runs Bingo of T to time times.

25
00:03:04.260 --> 00:03:13.800
Miles E Jones: Then the entire loop or the entire process is going to be a product of those functions big of tier one times T two.

26
00:03:14.760 --> 00:03:33.120
Miles E Jones: And the idea here is that in that while loop you're gonna do have to do at least as much as or no at most sorry, at most, as much as T one event you're going to do that T to event time so that's why we're multiplying here it's kind of like the product rule.

27
00:03:35.550 --> 00:03:41.100
Miles E Jones: Okay, so let's look at selection sort the pseudo code and kind of talk about.

28
00:03:42.240 --> 00:03:47.310
Miles E Jones: How to calculate the runtime now what is it that we're really calculating.

29
00:03:50.220 --> 00:03:51.990
Miles E Jones: What we're really counting.

30
00:03:53.100 --> 00:04:06.600
Miles E Jones: The The thing that you're doing the most is these comparisons so let's count this by the number of comparisons and you'll see that that is sufficient to counting the whole thing because everything else is going to be.

31
00:04:07.530 --> 00:04:19.080
Miles E Jones: kind of done at the same time as the comparisons anyway, so if you count the number of comparisons you really are you know, having a good idea of how many operations total we're doing.

32
00:04:20.910 --> 00:04:21.810
Miles E Jones: Okay, so.

33
00:04:24.420 --> 00:04:28.320
Miles E Jones: let's talk about let's kind of work from the inside out so this.

34
00:04:29.520 --> 00:04:30.510
Miles E Jones: line here.

35
00:04:32.970 --> 00:04:40.110
Miles E Jones: is going to be a constant time operation comparing is constant time to small numbers is Constantine.

36
00:04:41.340 --> 00:04:48.780
Miles E Jones: assigning a variable and is equal to Jay is also Constantine so that body of that inner loop is constant time.

37
00:04:52.110 --> 00:04:52.410
Miles E Jones: Right.

38
00:04:55.350 --> 00:04:56.430
Miles E Jones: about this.

39
00:04:58.140 --> 00:05:03.030
Miles E Jones: Well, this runs big of n times.

40
00:05:04.710 --> 00:05:06.150
Miles E Jones: In the worst case.

41
00:05:09.930 --> 00:05:16.590
Miles E Jones: right because, in the worst case is equal to one and then Jay has to go from two up to n.

42
00:05:19.470 --> 00:05:21.480
Miles E Jones: So this whole.

43
00:05:23.610 --> 00:05:26.700
Miles E Jones: This whole loop will run big old and.

44
00:05:28.560 --> 00:05:30.150
Miles E Jones: Big of n times one.

45
00:05:32.910 --> 00:05:34.320
Little different color.

46
00:05:35.400 --> 00:05:37.500
Miles E Jones: Big of an times one.

47
00:05:39.450 --> 00:05:40.650
worst case.

48
00:05:45.450 --> 00:05:51.600
Miles E Jones: Okay now let's talk about the body of the outer for loop.

49
00:06:01.980 --> 00:06:02.340
Miles E Jones: well.

50
00:06:03.750 --> 00:06:18.240
Miles E Jones: We didn't really talk about this, but if you do certain operations in a row like if you do them and then do another one and do another one, then you add their run times so really what we're doing is we're adding the runtime of that inner loop.

51
00:06:19.980 --> 00:06:37.950
Miles E Jones: Plus, however long it takes to do this, plus however long it takes to do this, which are both constant time operation, so they kind of get lost because, in the worst case, this is big event, so this so this body is going to be bigger of n.

52
00:06:39.180 --> 00:06:39.810
Miles E Jones: Plus.

53
00:06:41.370 --> 00:06:41.730
two.

54
00:06:42.990 --> 00:06:45.180
Miles E Jones: Which is just big event in the worst case.

55
00:06:47.640 --> 00:06:48.870
Miles E Jones: All right now.

56
00:06:50.550 --> 00:06:52.530
Miles E Jones: You have this thing runs.

57
00:06:53.850 --> 00:06:55.230
Miles E Jones: And minus one times.

58
00:06:56.340 --> 00:06:56.910
Miles E Jones: So big.

59
00:07:05.910 --> 00:07:09.600
Miles E Jones: And so the actual runtime of the whole algorithm.

60
00:07:11.100 --> 00:07:16.500
Miles E Jones: is going to be big of n times and which is big of n squared.

61
00:07:18.240 --> 00:07:19.830
Miles E Jones: Okay, any questions or comments.

62
00:07:31.140 --> 00:07:32.640
Miles E Jones: So you multiply.

63
00:07:36.780 --> 00:07:37.530
Miles E Jones: When.

64
00:07:38.730 --> 00:07:40.050
Miles E Jones: You are.

65
00:07:41.400 --> 00:07:43.050
Miles E Jones: Talking about loops.

66
00:07:49.320 --> 00:07:50.520
Miles E Jones: You add.

67
00:07:51.930 --> 00:07:52.770
Miles E Jones: When.

68
00:07:54.420 --> 00:07:55.620
procedures.

69
00:07:59.310 --> 00:08:00.240
What do you call them.

70
00:08:05.790 --> 00:08:06.540
Miles E Jones: procedures.

71
00:08:08.820 --> 00:08:09.750
Miles E Jones: procedures.

72
00:08:11.940 --> 00:08:12.990
Miles E Jones: are run.

73
00:08:17.280 --> 00:08:18.600
Miles E Jones: one after the other.

74
00:08:27.120 --> 00:08:29.280
Miles E Jones: make sense any other questions or comments.

75
00:08:43.980 --> 00:08:50.250
Miles E Jones: want you to to notice here is that this is a upper bound right we're using big oh here.

76
00:08:52.620 --> 00:09:03.510
Miles E Jones: If you want it to get a tight upper bound like a big theta upper bound you'd have to be more careful okay anybody tell me where we were not very careful in this.

77
00:09:06.240 --> 00:09:07.770
Miles E Jones: In this analysis.

78
00:09:11.220 --> 00:09:14.070
Miles E Jones: The inner loop exactly right, this is.

79
00:09:15.390 --> 00:09:29.580
Miles E Jones: Bigger event times in the worst case right but that worst case only happens once right so do they even out right are there more better cases than there are worst cases So these are.

80
00:09:32.850 --> 00:09:35.310
Miles E Jones: These are kind of questions to think about.

81
00:09:37.260 --> 00:09:44.490
Miles E Jones: But this is fine, because this is true, this algorithm does run in big of n squared because remember big O means upper bound.

82
00:09:44.880 --> 00:09:57.630
Miles E Jones: it's also true that this algorithm does run in big data of n squared time and now with sort of the the methods that you've been practicing in the homework, you can probably oh you can't hear.

83
00:09:59.610 --> 00:10:00.210
Miles E Jones: No.

84
00:10:06.120 --> 00:10:09.030
Miles E Jones: i'm going to maybe I can move the microphone a bit closer.

85
00:10:16.800 --> 00:10:18.660
Miles E Jones: um what was I gonna say.

86
00:10:20.520 --> 00:10:27.090
Miles E Jones: Okay, you could do a more detailed analysis on this right, and you can you can actually count the exact number of.

87
00:10:28.830 --> 00:10:35.340
Miles E Jones: exact number of times that you compare things and base your runtime off of that, and you can get a big data bound.

88
00:10:36.690 --> 00:10:39.270
Miles E Jones: But for right now we're just talking about loose upper bounds.

89
00:10:40.740 --> 00:10:44.400
Miles E Jones: Okay, so here's another example, something triples.

90
00:10:45.510 --> 00:11:01.320
Miles E Jones: So, given a list of real numbers a one through a n look for three indices I J and K between one and such that Ai plus AJ is equal to Ak so, for example, does the list 36578 have a seven triple.

91
00:11:08.760 --> 00:11:24.720
Miles E Jones: Yes, right so three plus five plus eight right, so if we if we index them as 12345, then the indices 135.

92
00:11:25.770 --> 00:11:27.210
Miles E Jones: Is a something triple.

93
00:11:32.430 --> 00:11:33.360
Miles E Jones: Questions about that.

94
00:11:40.440 --> 00:11:43.440
Miles E Jones: Okay, so how would we make an algorithm to do this.

95
00:11:45.630 --> 00:11:47.190
Miles E Jones: i'm just going to kind of go through.

96
00:11:48.660 --> 00:11:55.980
Miles E Jones: A sort of sequence of algorithms that get kind of better and better and better, as we go let's start out with sort of a brute force thing.

97
00:11:56.520 --> 00:12:03.210
Miles E Jones: Why don't we try out all possible combinations Okay, so this is might be sort of the first thing that you think about.

98
00:12:03.720 --> 00:12:09.630
Miles E Jones: Maybe you all were already kind of thinking, this is one way to do it, so we have a nested for loop.

99
00:12:10.080 --> 00:12:21.030
Miles E Jones: Right, we take it from one to n J from one to n K from one to end and what this is doing is it's going through every single combination of I J and K.

100
00:12:21.630 --> 00:12:39.900
Miles E Jones: And then you just check if Ai plus AJ is Ak then return true So what is the order of the runtime of this algorithm it's pretty easy if you if you kind of understand how how the multiplication works, but let's go through it just like we did that other one.

101
00:12:42.870 --> 00:12:48.630
Miles E Jones: Okay, this guy is bigger have one right to do a comparison.

102
00:12:51.720 --> 00:12:53.130
Miles E Jones: This thing runs.

103
00:12:54.330 --> 00:12:55.710
Miles E Jones: And times.

104
00:12:56.910 --> 00:13:01.110
Miles E Jones: So this loop here is big of an.

105
00:13:02.940 --> 00:13:03.270
Miles E Jones: Right.

106
00:13:05.040 --> 00:13:06.450
Miles E Jones: This thing runs.

107
00:13:11.040 --> 00:13:15.240
Miles E Jones: And times so you have big of n times n.

108
00:13:21.090 --> 00:13:22.410
Miles E Jones: This thing runs.

109
00:13:25.410 --> 00:13:30.840
Miles E Jones: In times so you get bigger and times and square.

110
00:13:39.690 --> 00:13:41.790
Miles E Jones: This is big and cute.

111
00:13:44.070 --> 00:13:50.100
Miles E Jones: This is an upper bound elusive about this is actually a tight upper bound to write because.

112
00:13:51.900 --> 00:14:11.310
Miles E Jones: You can just see that, in the worst case it's going to have to go through every single possible combinations of I J and K, where I J and K can be any of the numbers from one to end really what you're doing is you're building a three letter word using the letters of.

113
00:14:12.330 --> 00:14:27.120
Miles E Jones: The numbers went through and or you can think about it as a three elements sequence of using the letters one through and so we've already counted these things, and there are there are, let me just write it there.

114
00:14:28.470 --> 00:14:30.030
Miles E Jones: are actually.

115
00:14:33.090 --> 00:14:34.560
Miles E Jones: And cubed.

116
00:14:37.890 --> 00:14:41.700
Miles E Jones: combinations know I should say sequences.

117
00:14:43.260 --> 00:14:44.280
sequences.

118
00:14:46.470 --> 00:14:47.910
Miles E Jones: Say three element.

119
00:14:49.500 --> 00:14:52.110
Miles E Jones: sequences of letters.

120
00:14:53.130 --> 00:14:54.150
Miles E Jones: No, sorry numbers.

121
00:15:04.770 --> 00:15:11.220
Miles E Jones: So you're actually doing in cube time, so it really is a theta but we're just kind of doing this, these loose bowels right now.

122
00:15:12.270 --> 00:15:14.430
Miles E Jones: Okay does anybody have any improvements that we could do.

123
00:15:27.750 --> 00:15:31.410
Miles E Jones: It can use the same number twice, so it won't work.

124
00:15:32.760 --> 00:15:34.020
Sorry, what won't work.

125
00:15:52.350 --> 00:15:53.760
Miles E Jones: Are they all start at one.

126
00:15:55.980 --> 00:16:05.820
Miles E Jones: Because what if the first number is zero then zero Plus zero is equal to zero, and so you can just have you know I J K all ones.

127
00:16:16.680 --> 00:16:25.830
Miles E Jones: Okay, good so let's yeah let's there's a few good comments in there, so we're going to kind of do a few of them, so one comment is that.

128
00:16:27.660 --> 00:16:28.860
Miles E Jones: summation.

129
00:16:32.520 --> 00:16:34.020
Miles E Jones: Is commutative.

130
00:16:36.960 --> 00:16:39.330
Miles E Jones: Does anybody know what that word means commutative.

131
00:16:44.970 --> 00:16:55.020
Miles E Jones: Just it's the same back and forth right a plus B is equal to be plus a so you're doing a lot of redundant work right because, for example.

132
00:16:56.430 --> 00:17:08.340
Miles E Jones: If I is equal to two and J is equal to five, and you do a two plus a five whatever you get seven or or maybe that's not whatever you get from that.

133
00:17:09.000 --> 00:17:20.760
Miles E Jones: that's the same as if you had a five plus a two so really you don't need to calculate both of those because you're going to get the same answer because summation is commutative.

134
00:17:21.180 --> 00:17:29.850
Miles E Jones: What that means is that you can always force I to be less than or equal to Jay or the other way around, how do you do that.

135
00:17:31.290 --> 00:17:35.610
Miles E Jones: To eliminate redundancy you start J at I.

136
00:17:38.400 --> 00:17:39.450
Miles E Jones: write it again.

137
00:17:41.400 --> 00:17:54.510
Miles E Jones: Okay, so what's the order of the runtime of this algorithm well we'll do the same, will do the same analysis will go to kind of go through it quickly, this time, this is Bingo of one this is n times.

138
00:17:55.890 --> 00:18:04.740
Miles E Jones: Right, so this guy is Bingo, and this is going to be and times in the worst case.

139
00:18:09.360 --> 00:18:17.160
Miles E Jones: Right, so this is gonna be big of n times n right but remember this is the worst case, but we're trying to just get a loose upper bound.

140
00:18:19.980 --> 00:18:21.900
Miles E Jones: This is bigger this is n times.

141
00:18:23.220 --> 00:18:25.260
Miles E Jones: So big of n cubed.

142
00:18:28.230 --> 00:18:30.720
Miles E Jones: Okay, so we get big old n cubed again.

143
00:18:36.180 --> 00:18:36.660
Miles E Jones: see me.

144
00:18:37.980 --> 00:18:38.460
Miles E Jones: So.

145
00:18:40.890 --> 00:18:45.450
Miles E Jones: Did we improve on the on the runtime here is this bound.

146
00:18:47.730 --> 00:18:50.850
Miles E Jones: Did we kind of bring that bound down or.

147
00:18:53.820 --> 00:19:00.240
Miles E Jones: Okay, so not really, but we still did improve the efficiency, you know so.

148
00:19:01.740 --> 00:19:07.140
Miles E Jones: that's going to be important, you know, in the workplace or what do you know what whatever you're doing.

149
00:19:08.910 --> 00:19:11.190
Miles E Jones: improving efficiency is great.

150
00:19:13.320 --> 00:19:18.990
Miles E Jones: But we didn't really improve it, by asking topic we didn't improve it as a topical, which means that.

151
00:19:22.170 --> 00:19:26.730
Miles E Jones: it's not a significant improvement okay so.

152
00:19:30.000 --> 00:19:30.390
Miles E Jones: dude.

153
00:19:43.590 --> 00:19:46.410
Miles E Jones: Okay, so can we do more improvements.

154
00:19:50.220 --> 00:20:01.920
Miles E Jones: So really kind of what this algorithm did like refit reframing how we did it is for each of those candidates, a one plus eight sorry Ai plus AJ.

155
00:20:02.790 --> 00:20:14.280
Miles E Jones: We basically do a linear search to find it that's kind of the the idea behind this right you kind of get those two things, and you, you search to see if it's in there.

156
00:20:15.390 --> 00:20:20.160
Miles E Jones: So what's better than linear search is binary search, I think, somebody already said that.

157
00:20:21.300 --> 00:20:25.230
Miles E Jones: But in order to use binary search, you need to sort everybody so first sort.

158
00:20:26.340 --> 00:20:27.450
Miles E Jones: A one through and.

159
00:20:29.130 --> 00:20:40.560
Miles E Jones: Then, for each candidate some Ai plus AJ making sure that we we take care of the redundancies binary search Ai plus AJ.

160
00:20:43.650 --> 00:20:44.400
Miles E Jones: In the list.

161
00:20:46.680 --> 00:20:48.840
Miles E Jones: Okay, so how long is this going to take.

162
00:21:02.700 --> 00:21:05.460
Miles E Jones: So the inside of this loop here.

163
00:21:07.170 --> 00:21:08.310
Miles E Jones: I guess we'll do it like this.

164
00:21:17.010 --> 00:21:18.750
Miles E Jones: How long does binary search take.

165
00:21:19.800 --> 00:21:21.150
Miles E Jones: Bigger of.

166
00:21:22.440 --> 00:21:23.280
Miles E Jones: log event.

167
00:21:25.080 --> 00:21:25.440
Miles E Jones: Right.

168
00:21:27.120 --> 00:21:32.910
Miles E Jones: So that's that inner loop, then this next loop here is going to take.

169
00:21:36.450 --> 00:21:38.370
Miles E Jones: In the worst case n times right.

170
00:21:43.830 --> 00:21:45.030
Miles E Jones: So you have.

171
00:21:46.950 --> 00:21:49.440
Miles E Jones: Big of n times login.

172
00:21:53.730 --> 00:21:55.260
Miles E Jones: And then, this outer loop.

173
00:21:56.460 --> 00:21:57.690
Miles E Jones: is going to take.

174
00:21:59.340 --> 00:22:04.290
Miles E Jones: And times so there's going to be big old n times analog in.

175
00:22:07.110 --> 00:22:09.060
Miles E Jones: Right and then how long does sorting take.

176
00:22:15.060 --> 00:22:15.510
Miles E Jones: well.

177
00:22:16.860 --> 00:22:20.310
Miles E Jones: For right now let's let's say that we're using selection sort.

178
00:22:21.930 --> 00:22:23.070
Miles E Jones: Selection sort.

179
00:22:24.570 --> 00:22:26.310
Miles E Jones: takes big of n squared time.

180
00:22:27.510 --> 00:22:33.360
Miles E Jones: Okay, so do we add this the the sorting algorithm or do we multiply.

181
00:22:36.030 --> 00:22:38.610
Miles E Jones: We add right because we're sorting it first.

182
00:22:40.170 --> 00:22:51.720
Miles E Jones: Think about it this way you sort it and then you're done with sorting and you get to move on, so that time that time has already elapsed you don't have to do the sorting a bunch of times you don't have to multiply so you add.

183
00:22:53.910 --> 00:22:56.550
Miles E Jones: let's see, so this is going to be.

184
00:22:57.900 --> 00:23:02.280
Miles E Jones: Bigger of n squared plus and squared login.

185
00:23:03.720 --> 00:23:11.640
Miles E Jones: And by using sort of the simplification rules, we can simplify this to just big of n squared login.

186
00:23:13.380 --> 00:23:14.550
Miles E Jones: Questions about that.

187
00:23:29.040 --> 00:23:32.760
Miles E Jones: How did you get big of login that's a that's something that we did with.

188
00:23:35.100 --> 00:23:42.000
Miles E Jones: We did that last week when we talked about binary search binary search takes login big old login runtime.

189
00:23:44.580 --> 00:23:45.330
Miles E Jones: We kind of.

190
00:23:47.400 --> 00:23:55.260
Miles E Jones: We kind of calculated instead the exact number of times remember i'm binary search.

191
00:23:59.400 --> 00:24:00.960
Miles E Jones: On input.

192
00:24:02.850 --> 00:24:03.690
Miles E Jones: Of length.

193
00:24:05.310 --> 00:24:17.040
Miles E Jones: And does what was it, it was the ceiling of log base to have n plus one.

194
00:24:21.930 --> 00:24:26.820
Miles E Jones: Something like that, so this this thing is big of login.

195
00:24:41.460 --> 00:24:46.680
Miles E Jones: Right, so that we that was like a little comment I made, I think, last Tuesday, is that.

196
00:24:48.690 --> 00:24:58.650
Miles E Jones: When we talk about these awesome topic run times we usually just write log and it doesn't matter which log, it is because all logs are constant multiples of each other.

197
00:25:00.030 --> 00:25:06.060
Miles E Jones: Right, whether you do natural log log log base to log base three log base 10 whatever you want.

198
00:25:10.110 --> 00:25:23.730
Miles E Jones: Okay, so some is the maximum here, just like we said before okay good so um can we make progress here, yes, we did right we actually found a you know we we didn't have to do a lot of.

199
00:25:25.440 --> 00:25:30.660
Miles E Jones: Counting we just kind of did this loose upper bound, but we were able to show that.

200
00:25:31.830 --> 00:25:36.870
Miles E Jones: This algorithm with the binary search is ask them topically faster than our first algorithm.

201
00:25:38.610 --> 00:25:38.970
Miles E Jones: Right.

202
00:25:40.140 --> 00:25:49.560
Miles E Jones: So I call this some triples three it does better than big of n cubed right big of n squared login is better than big open QA.

203
00:25:51.660 --> 00:26:05.130
Miles E Jones: But we're going to see this other sort called merge sort and it is faster than selection store it's an login but that's not actually going to help overall, I guess, I should say as syntactically.

204
00:26:09.660 --> 00:26:11.220
Miles E Jones: Right let's go back for a SEC.

205
00:26:12.510 --> 00:26:13.830
Miles E Jones: kind of got cut off, but.

206
00:26:15.810 --> 00:26:18.510
Miles E Jones: notice that, where if they if we're using selection sort.

207
00:26:22.650 --> 00:26:42.960
Miles E Jones: Then we get n squared if we use a faster sort like n log in you're going to see that it it uh you're still going to have to do all of this work for the N squared login so it's not going to kind of be asked them topically more efficient it'll still cut down the time probably but.

208
00:26:45.600 --> 00:26:48.960
Miles E Jones: it's kind of like what are you looking to do, are you looking to get a.

209
00:26:50.340 --> 00:26:56.370
Miles E Jones: asim topically faster algorithm or are you just trying to shave off a few calculations.

210
00:26:58.080 --> 00:27:00.360
Miles E Jones: Okay, the fastest known algorithm to do this.

211
00:27:01.380 --> 00:27:04.920
Miles E Jones: Is big goal of n squared times so you all can think about that as an exercise.

212
00:27:09.660 --> 00:27:10.110
Miles E Jones: Okay.

213
00:27:12.150 --> 00:27:16.050
Miles E Jones: So let's go back to this product rule let's revisit.

214
00:27:17.370 --> 00:27:32.760
Miles E Jones: If the body of the of the loop enter the body, the inner part runs into one time, in the worst case and the loop runs T too many times in the worst case, then the whole thing takes big old T one times T to.

215
00:27:33.840 --> 00:27:47.430
Miles E Jones: But what if many iterations are much better than the worst case, what if the worst case only happens a few times, is it possible that this is going to be a very, very loose upper bound.

216
00:27:49.110 --> 00:27:50.910
Miles E Jones: Okay, so let's look at this other example.

217
00:27:52.680 --> 00:27:54.120
Miles E Jones: given to sorted lists.

218
00:27:55.500 --> 00:28:04.680
Miles E Jones: be one through bn determine if they're indices I J such that Ai is equal to be J, so how would you all propose to do this.

219
00:28:24.480 --> 00:28:29.940
Miles E Jones: Okay, good, so we can binary search every every day into the B list.

220
00:28:31.320 --> 00:28:32.520
Miles E Jones: binary search.

221
00:28:36.180 --> 00:28:38.490
Miles E Jones: Oh hey I.

222
00:28:39.540 --> 00:28:41.040
Miles E Jones: In the B list right.

223
00:28:44.550 --> 00:28:45.540
Miles E Jones: Until we find one.

224
00:28:48.840 --> 00:28:49.740
A match.

225
00:28:52.260 --> 00:28:54.240
Miles E Jones: How long is this algorithm going to take.

226
00:28:55.530 --> 00:28:56.430
Miles E Jones: In the worst case.

227
00:29:01.770 --> 00:29:04.620
Miles E Jones: And login okay good big of an login.

228
00:29:06.990 --> 00:29:15.510
Miles E Jones: Okay, so let's keep that in mind we're going to actually do something different, but this is a kind of a good good starting point, or at least, is a good.

229
00:29:16.590 --> 00:29:18.720
Miles E Jones: benchmark, to see if we can do any better.

230
00:29:20.070 --> 00:29:35.250
Miles E Jones: Okay, so i'm going to use linear search instead of binary search and see if be one is anywhere in the first list but whenever since A and B a since the A and B lists are sorted, I can kind of.

231
00:29:37.290 --> 00:29:45.270
Miles E Jones: Compare that element that be element be one until I find in a that's bigger right.

232
00:29:46.530 --> 00:30:03.210
Miles E Jones: So you kind of compare be one with a one if be one is bigger than a one then keep on moving right until you find a one that's bigger than B and then stop there, but then you can you can start where you left off on be too, because you know be two is bigger than P one.

233
00:30:05.640 --> 00:30:25.740
Miles E Jones: right because search for be to where you were that one left off and, in general, start the search for bj where the search for bj minus one left off Okay, so this is kind of how the algorithm would look um you can kind of think about it as like the Ai is the index for the a right.

234
00:30:32.370 --> 00:30:34.890
Miles E Jones: And the J is index for be.

235
00:30:36.090 --> 00:30:36.960
Miles E Jones: For the bees.

236
00:30:37.980 --> 00:30:47.700
Miles E Jones: bj now if you're like me, you get lost in all these indices and it's kind of a mess, but we could kind of go through it just so you can.

237
00:30:49.860 --> 00:30:51.120
Miles E Jones: You can sort of see.

238
00:30:52.350 --> 00:30:53.550
Miles E Jones: what's really going on.

239
00:30:54.900 --> 00:30:58.440
Miles E Jones: Okay, so you start with is equal to one that's the a.

240
00:30:59.640 --> 00:31:01.500
Miles E Jones: Right and.

241
00:31:02.970 --> 00:31:10.920
Miles E Jones: you're going to loop through all the bs but, as you loop through the bs you increment the eye right so.

242
00:31:12.120 --> 00:31:25.320
Miles E Jones: While bj is greater than Ai right if be one is bigger than a one, then you increment I and you go to a two alright, so I kind of takes you.

243
00:31:26.340 --> 00:31:28.170
Miles E Jones: Through the a list.

244
00:31:29.400 --> 00:31:30.930
Miles E Jones: right but notice that.

245
00:31:32.580 --> 00:31:37.350
Miles E Jones: right when you come out of this when you come out of this while loop.

246
00:31:39.150 --> 00:31:52.410
Miles E Jones: I guess, these are our ending conditions right if you ever find something, then you're good and if I goes to the to the end of the list, then you're then, then you haven't found anybody, but notice that when you go back into.

247
00:31:59.130 --> 00:32:09.090
Miles E Jones: When you go back into this for loop I doesn't reset right, so it gets left off from where you were before that's kind of the big thing.

248
00:32:11.490 --> 00:32:22.950
Miles E Jones: Okay, so how long is this going to take well these things are going to be both constant time this while loop takes big of an time in the worst case right.

249
00:32:29.010 --> 00:32:34.890
Miles E Jones: The worst case would be that be one is greater than every element in a.

250
00:32:49.860 --> 00:32:51.630
Miles E Jones: Right, what would that be.

251
00:32:53.910 --> 00:32:55.950
Miles E Jones: Well, if statements, always be.

252
00:32:57.150 --> 00:32:58.320
Miles E Jones: bigger one.

253
00:33:00.000 --> 00:33:07.590
Miles E Jones: He most of the time, most of most of the time that if statement is a comparison you're comparing two things right.

254
00:33:08.790 --> 00:33:11.820
Miles E Jones: So, usually usually if statements are going to be big of one.

255
00:33:14.010 --> 00:33:16.950
Miles E Jones: Okay, so if be if be one.

256
00:33:20.160 --> 00:33:24.900
Miles E Jones: is greater than all the elements of a in the worst case.

257
00:33:28.470 --> 00:33:31.980
Miles E Jones: Then this while loop is going to run and times.

258
00:33:35.760 --> 00:33:36.060
Miles E Jones: Right.

259
00:33:37.680 --> 00:33:45.960
Miles E Jones: So that's that so that means that this entire body is gonna be big of an in the worst case.

260
00:33:49.290 --> 00:33:53.010
Miles E Jones: Oh that's what I want okay good, so we have that.

261
00:33:54.300 --> 00:33:59.730
Miles E Jones: Now notice that this thing in the worst case runs.

262
00:34:01.020 --> 00:34:01.980
Miles E Jones: And times.

263
00:34:03.630 --> 00:34:03.990
and

264
00:34:05.310 --> 00:34:07.440
worst case.

265
00:34:09.180 --> 00:34:16.440
Miles E Jones: Right, so the total year is going to be and times and write the entire algorithm is going to take.

266
00:34:17.760 --> 00:34:23.760
Miles E Jones: Bingo of n times and which is Bingo of and squared now Is this correct.

267
00:34:25.200 --> 00:34:28.530
Miles E Jones: Does this algorithm running and Bingo of n squared time.

268
00:34:35.310 --> 00:34:45.360
Miles E Jones: Okay, good, there is a, this is a correct upper bound exactly, but there is a tighter bound that we could we could calculate if we're a little careful.

269
00:34:50.040 --> 00:34:51.270
yeah exactly.

270
00:34:52.950 --> 00:34:53.550
Miles E Jones: So.

271
00:34:55.350 --> 00:35:03.360
Miles E Jones: If you're a little bit more careful on on counting the number of operations, then you'll see that this.

272
00:35:07.650 --> 00:35:12.150
Miles E Jones: This while loop right, it will execute.

273
00:35:13.170 --> 00:35:18.180
Miles E Jones: Bingo have to end times and the way one way that you can see, that is, that.

274
00:35:22.050 --> 00:35:26.610
Miles E Jones: Each a I and bj.

275
00:35:28.620 --> 00:35:29.190
Miles E Jones: Is.

276
00:35:30.300 --> 00:35:31.440
Miles E Jones: considered.

277
00:35:33.630 --> 00:35:34.740
Miles E Jones: At most.

278
00:35:36.960 --> 00:35:58.110
Miles E Jones: Once right it's kind of like think about it this way that the a list and the B list you're only kind of going through them in one direction you never get reset so in the very worst case you got to consider all the a's and all the bs but that's just going to be too and considerations.

279
00:35:59.700 --> 00:36:04.920
Miles E Jones: And so, in the very worst case you're gonna you're gonna have a.

280
00:36:06.180 --> 00:36:08.370
Miles E Jones: Big have to and bound.

281
00:36:16.860 --> 00:36:21.930
Miles E Jones: yeah you can think about it this way to write the the eyes and the jays are only increasing.

282
00:36:23.520 --> 00:36:33.330
Miles E Jones: right they never go back so how many operations, do you have to do in the worst case well just think about it, that you have to do.

283
00:36:34.890 --> 00:36:49.620
Miles E Jones: I from one to end nj from one to end so that's going to be two and operations, which is going to be big event, so this is just a warning that this product rule is not always tight.

284
00:36:50.910 --> 00:36:56.430
Miles E Jones: it's always correct, but you know you're just going to get this upper bound, it might not always be tight.

285
00:37:00.060 --> 00:37:05.820
Miles E Jones: Is it fair to say that if algorithm has no comparisons big O and big data are equal.

286
00:37:07.650 --> 00:37:10.350
Miles E Jones: And I would I would not say that.

287
00:37:17.250 --> 00:37:18.750
Miles E Jones: know where that's coming from.

288
00:37:24.180 --> 00:37:25.590
Miles E Jones: Big data are never equal.

289
00:37:30.420 --> 00:37:39.990
Miles E Jones: Let me say it in a different way, big and big feta are two different they have two different definitions, so I don't know what you mean by.

290
00:37:42.390 --> 00:37:45.210
Miles E Jones: I don't know what you mean by bigger than big feta be equal.

291
00:37:54.960 --> 00:37:58.140
Miles E Jones: To n is equal to big event right, yes, yes.

292
00:37:59.940 --> 00:38:01.770
Miles E Jones: Because of that constant factor.

293
00:38:05.280 --> 00:38:08.790
Miles E Jones: Okay sorry any other lingering questions.

294
00:38:26.160 --> 00:38:28.290
Miles E Jones: know the whole algorithm is big event.

295
00:38:32.310 --> 00:38:38.070
Miles E Jones: But in order to count that i'm counting how many times this while loop actually.

296
00:38:40.080 --> 00:38:40.980
Miles E Jones: executes.

297
00:38:51.540 --> 00:39:04.170
Miles E Jones: worst case is not it Okay, so this is a little tricky the worst case is Bingo of n squared but there's a tighter bound on the worst case, the worst case is also big of n.

298
00:39:04.500 --> 00:39:18.510
Miles E Jones: But it's it's like that we're using this big oh so it's kind of like you can you can say that the worst case is big of n factorial or end to the end right, so if you're using big ago then.

299
00:39:21.180 --> 00:39:22.680
Miles E Jones: Then you can have any upper bound.

300
00:39:24.150 --> 00:39:27.900
Miles E Jones: But I would say that the worst case is big theta of n.

301
00:39:34.320 --> 00:39:35.670
Miles E Jones: So worst case here.

302
00:39:39.000 --> 00:39:39.570
Miles E Jones: Is.

303
00:39:41.790 --> 00:39:47.190
Miles E Jones: Big data of N and why is that well we why.

304
00:39:49.350 --> 00:39:52.440
Miles E Jones: Well, first we argued that the runtime.

305
00:39:54.060 --> 00:40:05.190
Miles E Jones: Is big of and right we've already argued that, so we have upper bound and the lower bound has got to be an also right because.

306
00:40:06.990 --> 00:40:08.310
Miles E Jones: In the worst case.

307
00:40:09.660 --> 00:40:18.840
Miles E Jones: You have to look at all of the elements anyway, and so, in the worst case, the lower bound is also big big Omega van.

308
00:40:22.950 --> 00:40:23.760
Miles E Jones: Since.

309
00:40:25.620 --> 00:40:26.490
Miles E Jones: You must.

310
00:40:29.070 --> 00:40:30.120
Miles E Jones: At least.

311
00:40:31.980 --> 00:40:32.760
Miles E Jones: Consider.

312
00:40:35.040 --> 00:40:35.700
Miles E Jones: Every.

313
00:40:36.810 --> 00:40:37.560
Miles E Jones: element.

314
00:40:39.420 --> 00:40:40.380
Miles E Jones: The runtime.

315
00:40:41.760 --> 00:40:47.340
Miles E Jones: is also big Omega event, so you got big and big old mega event that means you have big data event.

316
00:40:55.860 --> 00:40:56.880
Miles E Jones: Okay, any other questions.

317
00:41:08.580 --> 00:41:15.270
Miles E Jones: yeah you're trying to find if there's any a's in the B list or any or if there's any bs and a list is the same.

318
00:41:17.520 --> 00:41:18.420
Miles E Jones: The same problem.

319
00:41:25.980 --> 00:41:38.910
Miles E Jones: All right, let's move on to loop in various so we kind of talked about how to do some general runtime analysis now let's talk about how to do some correctness proofs so a loop and variant is a property.

320
00:41:40.440 --> 00:41:49.290
Miles E Jones: That remains true after each time the body of a loop is executed what is looping variant mean in variant means not changing.

321
00:41:51.990 --> 00:41:52.800
Miles E Jones: Not.

322
00:41:56.340 --> 00:41:56.820
Miles E Jones: Changing.

323
00:41:59.430 --> 00:42:03.720
Miles E Jones: So the three step plan you need to first state your looping variant.

324
00:42:05.130 --> 00:42:13.080
Miles E Jones: Prove that it's invariant by using induction and then use that invariant to prove that the algorithm is correct this usually.

325
00:42:14.280 --> 00:42:15.210
Miles E Jones: involves.

326
00:42:16.920 --> 00:42:24.360
Miles E Jones: showing that the loop very is correct, at the end of the algorithm and that will imply that the algorithm is correct.

327
00:42:27.120 --> 00:42:34.380
Miles E Jones: Okay, so let's do a let's let's prove the correctness of selection sort or men sort.

328
00:42:35.400 --> 00:42:36.660
Miles E Jones: remember how this works.

329
00:42:38.010 --> 00:42:39.510
Miles E Jones: You find the minimum element.

330
00:42:40.680 --> 00:42:52.650
Miles E Jones: In the list and you swap it with the first element, then you find the second element in the list you swap it with the second element, and the third, and the fourth and you basically kind of build the sorted list like that.

331
00:42:54.540 --> 00:43:03.630
Miles E Jones: Okay, so here's kind of like a more mid level pseudo code right you you set a m to be the minimum.

332
00:43:05.070 --> 00:43:16.650
Miles E Jones: Of the list, starting at a I right, and then you swap Ai with am so when is equal to one you swap them the very minimum, with a one and a two and so on.

333
00:43:18.630 --> 00:43:20.220
Miles E Jones: Okay, so I have this.

334
00:43:24.330 --> 00:43:25.920
Miles E Jones: kind of show.

335
00:43:27.120 --> 00:43:27.900
Miles E Jones: This thing.

336
00:43:30.990 --> 00:43:32.940
Miles E Jones: is supposed to be like a YouTube link.

337
00:43:34.890 --> 00:43:35.490
Miles E Jones: Oh, here we go.

338
00:43:52.710 --> 00:43:54.810
Miles E Jones: Okay, so you see that minimum down there.

339
00:43:58.320 --> 00:44:02.400
Miles E Jones: is very annoying sounding but I kind of like it.

340
00:44:04.500 --> 00:44:07.650
Miles E Jones: Right so it's finding the minimum, you can see that it's like blinking.

341
00:44:09.720 --> 00:44:14.040
Miles E Jones: Right and then it swaps it when whatever was was in the third place and.

342
00:44:19.110 --> 00:44:20.580
Miles E Jones: There there it is strength.

343
00:44:43.980 --> 00:44:47.070
Miles E Jones: going to stop it right there for just a SEC.

344
00:44:48.180 --> 00:44:49.290
Miles E Jones: Can I get rid of that thing.

345
00:44:51.450 --> 00:44:53.730
Miles E Jones: Okay Why am I showing you this video.

346
00:44:54.780 --> 00:45:01.680
Miles E Jones: it's because I really liked that sound know the reason is because the.

347
00:45:03.630 --> 00:45:08.010
Miles E Jones: The looping variant is really easy to see with this video.

348
00:45:09.930 --> 00:45:12.450
Miles E Jones: The looping variant is going to be something like this.

349
00:45:13.470 --> 00:45:14.220
Miles E Jones: After.

350
00:45:15.690 --> 00:45:16.980
Miles E Jones: The first.

351
00:45:18.510 --> 00:45:20.550
Miles E Jones: TEE iteration iterations.

352
00:45:23.280 --> 00:45:24.000
Miles E Jones: Of the loop.

353
00:45:26.760 --> 00:45:40.920
Miles E Jones: What can we say is true what have you done you've been building something right you noticed that, like the whole right side of this thing is a bunch of jumbled mess, but the first TEE.

354
00:45:42.600 --> 00:45:43.590
Miles E Jones: values.

355
00:45:44.670 --> 00:45:50.850
Miles E Jones: Are kind of put together in a nice way okay good So the first TEE elements are sorted.

356
00:46:01.590 --> 00:46:04.770
Miles E Jones: Okay there's actually another looping variant here.

357
00:46:05.820 --> 00:46:08.460
Miles E Jones: What else can you say about those first TEE elements.

358
00:46:16.470 --> 00:46:17.760
Miles E Jones: Can I draw on this thing.

359
00:46:23.250 --> 00:46:25.680
Miles E Jones: I can do it if I do this watch this.

360
00:46:31.980 --> 00:46:32.370
Miles E Jones: This.

361
00:46:37.650 --> 00:46:41.070
Miles E Jones: should be under there I draw a line you see that.

362
00:46:42.300 --> 00:47:01.020
Miles E Jones: These elements, just like you said, they are the smallest T elements so they're sorted order and they're the smallest everything to the right all that jumbled mess that only has those elements that are greater than all of the sorted things and that's going to be important.

363
00:47:02.550 --> 00:47:03.510
Miles E Jones: OK, so the first.

364
00:47:05.610 --> 00:47:11.400
Miles E Jones: The first key elements are sorted and I know I wanted to do it in.

365
00:47:12.990 --> 00:47:13.680
Miles E Jones: PowerPoint.

366
00:47:15.990 --> 00:47:16.380
house.

367
00:47:18.180 --> 00:47:20.700
Miles E Jones: And they are the smallest key elements.

368
00:47:27.420 --> 00:47:34.650
Miles E Jones: Okay, so it's like in the middle of the middle of the algorithm and you want to kind of, say, a general property in the middle of the algorithm.

369
00:47:35.010 --> 00:47:45.540
Miles E Jones: And then we're going to use that to say well this property holds for after every iteration so it's going to hold after the last iteration, and that means everybody's sorted okay so let's finish up this video.

370
00:48:08.970 --> 00:48:09.540
Miles E Jones: Okay cool.

371
00:48:11.790 --> 00:48:12.450
Miles E Jones: or annoying.

372
00:48:13.860 --> 00:48:15.930
Miles E Jones: Okay So what are the two variants for select.

373
00:48:18.420 --> 00:48:21.810
Miles E Jones: Sorry, after T iterations the first.

374
00:48:23.460 --> 00:48:25.260
Miles E Jones: or let's do it like this, the first.

375
00:48:26.430 --> 00:48:27.510
Miles E Jones: TEE elements.

376
00:48:30.000 --> 00:48:33.390
Miles E Jones: Are one in sorted order.

377
00:48:36.120 --> 00:48:38.340
Miles E Jones: And smallest.

378
00:48:40.650 --> 00:48:41.250
elements.

379
00:48:48.900 --> 00:48:52.140
Miles E Jones: Okay, so that's the stating the loop and very now let's prove it.

380
00:48:54.450 --> 00:49:05.370
Miles E Jones: On actually I think we're going to skip to Part three so remember the loop invariant proof has three parts, we have state to live in variant prove the loop and variant is actually true.

381
00:49:06.120 --> 00:49:17.460
Miles E Jones: And then, once you show that it's true, why can you conclude the program is correct, so let's jump to three assuming that we've already done two and then we'll go back and do two.

382
00:49:21.450 --> 00:49:34.470
Miles E Jones: Okay, so if we know that the looping very is correct, then for any number of iterations from zero to N minus one the loop and variant is true after T iterations.

383
00:49:36.150 --> 00:49:44.880
Miles E Jones: In, particularly the loop and very is true after N minus one operations, if you go back to the actual pseudo code.

384
00:49:46.050 --> 00:49:58.620
Miles E Jones: notice that this loop only runs from one to N minus one so after N minus one iterations the algorithm stops and hopefully all the elements are in sorted order.

385
00:50:01.410 --> 00:50:20.940
Miles E Jones: Okay, so based on the loop in the loop invariant the first N minus elements and minus one elements are in sorted order that's good and the first N minus one elements are the smallest now those two pieces of information are enough to show that the entire list is in sorted order.

386
00:50:22.020 --> 00:50:23.460
Miles E Jones: right because.

387
00:50:25.740 --> 00:50:38.940
Miles E Jones: The first N minus one elements are the smallest implies that a and the last element is the biggest and so, if you have a sorted list of small things and you put a big thing at the very end, the result is all sorted.

388
00:50:41.250 --> 00:50:46.770
Miles E Jones: And this is why we conclude that the whole list is sorted and this is the exact algorithm specification.

389
00:50:48.540 --> 00:50:49.830
Miles E Jones: Questions about that.

390
00:50:55.110 --> 00:51:03.540
Miles E Jones: Okay, so we're now we're kind of have to do the meat of the problem, the the main part which is proved the loop and variant is correct.

391
00:51:04.680 --> 00:51:05.970
Miles E Jones: And that's where we use induction.

392
00:51:07.080 --> 00:51:23.640
Miles E Jones: OK, so the base case is going to be it's true before the algorithm even starts it's true before the loop before the first iteration or instead of saying before the first iteration we usually say you know.

393
00:51:27.810 --> 00:51:34.860
Miles E Jones: When T is equal to zero so after zero iterations right after zero iterations.

394
00:51:36.870 --> 00:51:39.810
Miles E Jones: This means before.

395
00:51:40.890 --> 00:51:42.570
Miles E Jones: The first.

396
00:51:43.830 --> 00:51:44.280
Miles E Jones: loop.

397
00:51:46.140 --> 00:51:52.770
Miles E Jones: And usually this is going to be like a trivial case and we'll see kind of how that works for this particular example.

398
00:51:53.940 --> 00:52:12.600
Miles E Jones: And then the induction step is usually going to be a regular induction because what we're doing is we're just going to assume that it's working after T iterations and then show that it works after the next iterations T plus one T T plus one, or, if you like, T minus one two T right but.

399
00:52:15.150 --> 00:52:21.120
Miles E Jones: notice that we just need it to work on the previous iteration to show that it works on the next iteration then we're done.

400
00:52:25.200 --> 00:52:26.580
Miles E Jones: Okay, so.

401
00:52:36.090 --> 00:52:43.410
Miles E Jones: In general, for a loop iteration proof the induction variable is the number of times, through the loop.

402
00:52:46.410 --> 00:52:56.850
Miles E Jones: Okay deduction steph you just say suppose that the statement holds after tea time for the loop for some tea and then show that the statement holds after T plus one times just regular regular induction.

403
00:52:58.860 --> 00:53:00.570
Miles E Jones: Okay, so let's do it for this example.

404
00:53:01.830 --> 00:53:17.250
Miles E Jones: base case after T equals zero after zero iterations the loop in various states that the first zero elements are in sorted order, this is vacuous Lee true or it's trivially true sometimes we say.

405
00:53:23.250 --> 00:53:24.090
Miles E Jones: Because.

406
00:53:25.500 --> 00:53:29.250
Miles E Jones: The empty set is our is a sorted set.

407
00:53:31.020 --> 00:53:31.260
Miles E Jones: Right.

408
00:53:34.200 --> 00:53:39.510
Miles E Jones: Okay second thing is the first zero elements are the smallest also trivially true.

409
00:53:40.440 --> 00:53:49.140
Miles E Jones: Right there's no element in the empty set that's bigger than any other elements so that's also trivially true so it's Nice that these.

410
00:53:49.860 --> 00:54:01.380
Miles E Jones: That these lupin variance they start out true and that's that's important so that, when we go through they remain to be true, as you go any questions about that.

411
00:54:06.510 --> 00:54:16.320
Miles E Jones: Often the base case of a loop and variant proof requires you to state, something that is trivially true about the empty sad or the set with just one element, or something kind of like.

412
00:54:18.150 --> 00:54:20.790
Miles E Jones: Something like that, what if you have negatives.

413
00:54:23.640 --> 00:54:24.390
Miles E Jones: What do you mean.

414
00:54:27.240 --> 00:54:28.620
Miles E Jones: Like the in the input.

415
00:54:43.230 --> 00:54:49.590
Miles E Jones: negatives aren't really gonna i'm going to matter much right because you're just going to put them in sorted order.

416
00:54:50.850 --> 00:54:52.260
Miles E Jones: Right so doesn't.

417
00:54:54.150 --> 00:55:00.180
Miles E Jones: With selection sort when you find the men you just find the minimum element, and so, if you have negatives in there, then it'll find.

418
00:55:00.900 --> 00:55:12.000
Miles E Jones: Those just using the minimum function okay inductive hypothesis suppose that for some tea greater than or equal to zero, the loop and variant is true after T iterations okay great.

419
00:55:13.440 --> 00:55:17.670
Miles E Jones: show that it's true after T plus one iterations, how do we do this.

420
00:55:21.090 --> 00:55:26.430
Miles E Jones: We kind of have to figure out what the algorithm is doing in that T plus first iteration.

421
00:55:30.690 --> 00:55:31.710
What does.

422
00:55:33.210 --> 00:55:33.990
algorithm.

423
00:55:36.630 --> 00:55:37.260
Miles E Jones: Do.

424
00:55:44.040 --> 00:55:45.480
Miles E Jones: T plus first.

425
00:55:47.700 --> 00:55:48.420
Miles E Jones: iteration.

426
00:55:52.320 --> 00:55:58.290
Miles E Jones: Well, the first thing it does is it's it finds the minimum of that set right.

427
00:56:00.270 --> 00:56:01.050
Miles E Jones: Oh, I have it right here.

428
00:56:04.770 --> 00:56:16.170
Miles E Jones: During the T plus first iteration the algorithm finds am right which is the minimum value of all of these elements from a T plus one up to an.

429
00:56:27.240 --> 00:56:27.660
Excuse me.

430
00:56:29.460 --> 00:56:34.620
Miles E Jones: So, after the T plus first so yeah you find the minimum value and then you swap them.

431
00:56:35.760 --> 00:56:37.980
Miles E Jones: Right and so after that.

432
00:56:39.180 --> 00:56:44.550
Miles E Jones: Operation 80 plus one is the minimum value of this set here.

433
00:56:45.630 --> 00:56:51.150
Miles E Jones: Now, how is that going to be helpful in showing that this loop invariant is true.

434
00:57:03.450 --> 00:57:05.400
Miles E Jones: We have to remember, we have to show both of them.

435
00:57:11.760 --> 00:57:25.230
Miles E Jones: Okay well in order to show the libertarians true is true we're going to need this induction right, and you know we didn't do induction for nothing let's use the induction to help us so by the inductive hypothesis.

436
00:57:26.610 --> 00:57:30.600
Miles E Jones: The loop and variant is true after T iterations, which means that.

437
00:57:31.890 --> 00:57:34.080
Miles E Jones: The first TEE elements are.

438
00:57:36.240 --> 00:57:37.920
Miles E Jones: In sorted order.

439
00:57:41.460 --> 00:57:42.300
Miles E Jones: and

440
00:57:45.000 --> 00:57:45.930
Miles E Jones: The smallest.

441
00:57:56.910 --> 00:58:01.890
Miles E Jones: So we get that for free, how is that going to help us right well.

442
00:58:03.060 --> 00:58:04.530
Miles E Jones: We what we want to show.

443
00:58:11.280 --> 00:58:16.260
Miles E Jones: That a one through a ti a T plus one.

444
00:58:17.400 --> 00:58:18.990
Miles E Jones: are sorted.

445
00:58:20.670 --> 00:58:22.290
Miles E Jones: And the smallest.

446
00:58:25.230 --> 00:58:43.830
Miles E Jones: Okay, so that's that's not a huge jump right, we just need We already know that a 180 are all sorted and small and we're adding this new element at plus one, and we just need to show that if you add that to the list it's still say sorted and it still stays small.

447
00:58:47.250 --> 00:58:49.830
Miles E Jones: Okay, so let's do to first.

448
00:58:50.910 --> 00:59:02.640
Miles E Jones: That these ones are the smallest, we want to show that a 180 plus one or the smallest and that's actually pretty easy to do, because we know that.

449
00:59:03.930 --> 00:59:07.500
Miles E Jones: 80 plus one is the minimum.

450
00:59:10.230 --> 00:59:29.820
Miles E Jones: Of the list a T plus one, through a an right because of that operation so 80 plus one is smaller than 80 plus two through a N and it's already bigger than all the other elements a one through at and so.

451
00:59:30.870 --> 00:59:35.880
Miles E Jones: A one through 18 plus one, are the smallest T plus one elements with the original list okay good.

452
00:59:38.100 --> 00:59:41.370
Miles E Jones: So that's that takes care of two now.

453
00:59:43.050 --> 01:00:00.750
Miles E Jones: Why are they all in sorted order well you already know that a one through a tier and sorted order, and you know that a one through at are all less than 80 plus one, so what happens if you take a big element and put it at the end of assorted list the resulting list is sorted.

454
01:00:05.730 --> 01:00:08.790
Miles E Jones: Okay, any questions or comments about this proof.

455
01:00:20.370 --> 01:00:20.760
Okay.

456
01:00:23.760 --> 01:00:28.710
Miles E Jones: So, then, the libertarian is true so we're done we're done here.

457
01:00:32.520 --> 01:00:38.220
Miles E Jones: Okay, so let's do another example we'll kind of do this one start from scratch okay.

458
01:00:39.630 --> 01:00:50.850
Miles E Jones: So, given a string of zeros and ones, we want to count how many times a sub string 00 occurs design algorithm to solve this so maybe this is what you're thinking of doing.

459
01:00:51.390 --> 01:01:03.960
Miles E Jones: is to have some variable let's call it count that increments every time you encounter that particular pattern we're trying to see.

460
01:01:06.300 --> 01:01:09.360
Miles E Jones: Trying to see how many times this sub string occurs 00.

461
01:01:11.820 --> 01:01:28.440
Miles E Jones: I guess maybe let's do an example, so if you had the string 110101001000100 or something like that, then how many times, does this pattern occur.

462
01:01:30.480 --> 01:01:38.790
Miles E Jones: It occurs 123456 times.

463
01:01:49.200 --> 01:02:00.330
Miles E Jones: So one way that we can do this is just kind of have like just go through the list from left to right and every time you see two zeros in a row you increment that counter.

464
01:02:02.340 --> 01:02:02.910
Miles E Jones: Okay, so.

465
01:02:04.140 --> 01:02:08.760
Miles E Jones: If n is less than two then return zero there's no way there's no possible way that you could.

466
01:02:10.680 --> 01:02:18.060
Miles E Jones: have an occurrence, with fewer than two elements, otherwise have a loop that goes from one to N minus one.

467
01:02:19.290 --> 01:02:24.480
Miles E Jones: Right and if bi is zero and bi plus one is zero then increment the counter.

468
01:02:25.950 --> 01:02:31.350
Miles E Jones: At the end of the algorithm return counter now if you were to see this algorithm you might.

469
01:02:32.280 --> 01:02:48.570
Miles E Jones: You might just be convinced already you're like yeah Of course that does what you want it to do that sorts it but we're using it as kind of a toy example to show off how to use a loop variant proof.

470
01:02:50.130 --> 01:02:52.530
Miles E Jones: To guarantee the correctness okay.

471
01:02:53.970 --> 01:03:00.600
Miles E Jones: So what is the looping variant for this algorithm after the first TEE iterations of the loop.

472
01:03:01.860 --> 01:03:03.750
Miles E Jones: What can we say is true.

473
01:03:13.080 --> 01:03:16.830
Miles E Jones: Count okay yeah so count a variable count.

474
01:03:18.750 --> 01:03:20.250
Miles E Jones: is equal to.

475
01:03:22.140 --> 01:03:23.220
Miles E Jones: The number.

476
01:03:24.960 --> 01:03:28.200
Miles E Jones: Of 00 occurrences.

477
01:03:38.940 --> 01:03:40.260
Miles E Jones: In the list.

478
01:03:42.060 --> 01:03:52.830
Miles E Jones: be one through BT right in that list so that means when the algorithm is over, that means that you've done.

479
01:03:56.970 --> 01:03:58.950
Miles E Jones: N minus one occurrences.

480
01:04:00.360 --> 01:04:02.070
Miles E Jones: or N minus one iterations.

481
01:04:03.900 --> 01:04:13.320
Miles E Jones: So the count is going to be right, the number of 00 occurrences in the, I guess, this should really be in the list be T plus one.

482
01:04:14.520 --> 01:04:18.510
Miles E Jones: right because it's going to he's going to look at I, and I plus one.

483
01:04:21.150 --> 01:04:31.860
Miles E Jones: Okay, any questions about the the loop invariant claiming that it's or stating what it is we haven't proved it, yet this is more of like a conjecture, or like a guess.

484
01:04:32.460 --> 01:04:48.270
Miles E Jones: there's i'm guessing that this is the thing that's going to help us, I mean it certainly will help us in the end, right, because if this is true, then when when T is equal to N minus one account will have counted the number of 00 occurrences in the entire list.

485
01:04:50.640 --> 01:04:55.170
Miles E Jones: Okay base case Okay, so I did kind of mess this up, this should be P T plus one.

486
01:04:56.400 --> 01:04:58.410
Miles E Jones: Okay base case let's see.

487
01:05:00.270 --> 01:05:04.290
Miles E Jones: After zero iterations.

488
01:05:11.550 --> 01:05:12.210
Miles E Jones: count.

489
01:05:13.410 --> 01:05:15.600
Miles E Jones: is equal to zero right.

490
01:05:17.580 --> 01:05:18.270
Miles E Jones: and

491
01:05:19.350 --> 01:05:24.030
Miles E Jones: There are zero occurrences.

492
01:05:25.980 --> 01:05:31.140
Miles E Jones: 00 in the empty list done.

493
01:05:33.000 --> 01:05:34.590
Miles E Jones: Questions about the base case.

494
01:05:41.130 --> 01:05:42.780
Miles E Jones: Of be one oh yeah right.

495
01:05:47.790 --> 01:05:50.370
Miles E Jones: Right, because this is what we're claiming frank yeah you're right.

496
01:05:52.590 --> 01:05:54.120
Miles E Jones: be zero plus one right.

497
01:05:55.350 --> 01:05:56.850
Miles E Jones: But still it's true.

498
01:06:03.660 --> 01:06:08.700
Miles E Jones: Okay inductive hypothesis okay so remember this is plus two, plus one suppose.

499
01:06:10.830 --> 01:06:16.320
Miles E Jones: That for some tea greater than or equal to zero.

500
01:06:19.290 --> 01:06:22.050
Miles E Jones: After T iterations.

501
01:06:24.690 --> 01:06:25.320
Miles E Jones: count.

502
01:06:27.330 --> 01:06:28.230
Miles E Jones: Is.

503
01:06:29.610 --> 01:06:30.540
Miles E Jones: The number.

504
01:06:32.490 --> 01:06:35.850
Miles E Jones: Of 00 occurrences.

505
01:06:39.990 --> 01:06:42.390
Miles E Jones: d one through be T plus one.

506
01:06:46.500 --> 01:06:49.230
Miles E Jones: Right Okay, so what we want to show.

507
01:06:52.620 --> 01:06:54.300
Miles E Jones: Is after.

508
01:06:55.350 --> 01:06:57.630
Miles E Jones: T plus one iterations.

509
01:07:03.060 --> 01:07:05.250
Miles E Jones: Is the number.

510
01:07:06.660 --> 01:07:10.080
Miles E Jones: Of 00 occurrences.

511
01:07:14.130 --> 01:07:17.460
Miles E Jones: and be one through be two plus two.

512
01:07:20.730 --> 01:07:31.530
Miles E Jones: Okay, so inductive step remember what we did before you kind of you kind of want to figure out what's happening in the T plus first iteration Okay, so what.

513
01:07:32.910 --> 01:07:33.750
Miles E Jones: happens.

514
01:07:35.580 --> 01:07:38.160
Miles E Jones: In T plus first.

515
01:07:40.200 --> 01:07:40.830
Miles E Jones: iteration.

516
01:07:45.060 --> 01:07:53.880
Miles E Jones: Okay, so for this particular algorithm we're gonna have to kind of break it up into cases and the cases are based on this if statement here.

517
01:07:55.050 --> 01:08:04.110
Miles E Jones: Because either you found an occurrence, or you haven't but you need to show that in both cases the loop and variance stays true so case one.

518
01:08:12.780 --> 01:08:15.900
Miles E Jones: Bi is zero and.

519
01:08:16.950 --> 01:08:22.530
Miles E Jones: Sorry, be T plus one is zero and BT plus two is zero.

520
01:08:25.080 --> 01:08:25.350
Miles E Jones: Right.

521
01:08:28.530 --> 01:08:29.400
Miles E Jones: Then.

522
01:08:31.080 --> 01:08:32.130
Miles E Jones: The number.

523
01:08:33.930 --> 01:08:35.880
Miles E Jones: Of 00.

524
01:08:37.500 --> 01:08:38.880
Miles E Jones: or sorry then count.

525
01:08:45.330 --> 01:08:48.480
Miles E Jones: is set to.

526
01:08:51.180 --> 01:08:52.590
Miles E Jones: Count plus one.

527
01:08:55.410 --> 01:08:57.450
Miles E Jones: Now this count here.

528
01:08:58.950 --> 01:08:59.310
Miles E Jones: Right.

529
01:09:01.980 --> 01:09:02.520
Miles E Jones: Were.

530
01:09:03.660 --> 01:09:04.530
Miles E Jones: previously.

531
01:09:08.340 --> 01:09:08.970
Miles E Jones: count.

532
01:09:10.320 --> 01:09:13.440
Miles E Jones: Was the number.

533
01:09:15.150 --> 01:09:17.970
Miles E Jones: Of 00 occurrences.

534
01:09:21.600 --> 01:09:25.320
Miles E Jones: be one through be T plus one right.

535
01:09:28.470 --> 01:09:29.340
Miles E Jones: So.

536
01:09:31.440 --> 01:09:36.750
Miles E Jones: You add one more occurrence.

537
01:09:39.150 --> 01:09:47.250
Miles E Jones: For the B T plus one be T plus two occurrence right.

538
01:09:49.800 --> 01:09:50.640
Miles E Jones: Therefore.

539
01:09:53.850 --> 01:09:55.920
Miles E Jones: It is correct.

540
01:09:57.690 --> 01:09:58.140
Miles E Jones: That.

541
01:09:59.730 --> 01:10:02.100
Miles E Jones: Count should.

542
01:10:03.810 --> 01:10:05.310
Miles E Jones: Be incremental.

543
01:10:08.670 --> 01:10:09.180
Miles E Jones: By one.

544
01:10:11.040 --> 01:10:13.920
Miles E Jones: it's just like you found a new occurrence you just added one.

545
01:10:15.540 --> 01:10:15.840
Miles E Jones: oops.

546
01:10:17.340 --> 01:10:18.510
Miles E Jones: Okay we're not done with this.

547
01:10:25.650 --> 01:10:26.160
Miles E Jones: case.

548
01:10:45.330 --> 01:10:46.620
Miles E Jones: Is that otherwise.

549
01:10:49.080 --> 01:10:53.520
Miles E Jones: been T plus one be T plus two.

550
01:10:54.810 --> 01:10:59.100
Miles E Jones: is not a 00 occurrence.

551
01:11:04.650 --> 01:11:05.850
Miles E Jones: In this case.

552
01:11:07.980 --> 01:11:10.350
Miles E Jones: Count doesn't.

553
01:11:11.550 --> 01:11:12.390
Miles E Jones: Change.

554
01:11:15.270 --> 01:11:17.190
Miles E Jones: And that's that's correct.

555
01:11:19.320 --> 01:11:20.250
Miles E Jones: that's correct.

556
01:11:21.960 --> 01:11:22.800
Miles E Jones: Because.

557
01:11:24.720 --> 01:11:25.800
Miles E Jones: The number.

558
01:11:27.390 --> 01:11:29.550
Miles E Jones: Of 00 occurrences.

559
01:11:33.480 --> 01:11:40.890
Miles E Jones: and be one through be T plus one is equal.

560
01:11:42.270 --> 01:11:44.220
Miles E Jones: To the number.

561
01:11:46.080 --> 01:11:49.020
Miles E Jones: Of 00 occurrences.

562
01:11:53.610 --> 01:11:57.900
Miles E Jones: In be one through BT plus two.

563
01:11:59.850 --> 01:12:11.280
Miles E Jones: It doesn't change because you know that that those last two don't make an occurrence, so you can essentially just kind of forget about BT plus two, you know BT plus two does not.

564
01:12:13.170 --> 01:12:19.440
Miles E Jones: is not part of any occurrence so just throw it away and you just get the number of occurrences in that other list.

565
01:12:22.230 --> 01:12:22.950
Miles E Jones: So in.

566
01:12:27.540 --> 01:12:28.950
Miles E Jones: In either case.

567
01:12:31.500 --> 01:12:32.130
Miles E Jones: count.

568
01:12:33.180 --> 01:12:34.440
Miles E Jones: is equal.

569
01:12:35.700 --> 01:12:37.890
Miles E Jones: To the number.

570
01:12:39.990 --> 01:12:43.170
Miles E Jones: Of 00 occurrences.

571
01:12:45.690 --> 01:12:49.740
Miles E Jones: In be one through be T plus two.

572
01:12:51.810 --> 01:13:08.310
Miles E Jones: OK, so the loop in varying is true, this is the end of the proof for the looping variant is true, but this is not the end of the proof of the algorithm is correct, we haven't done that part, yet we need to kind of leverage this loop invariant to show that, after algorithm is over.

573
01:13:10.260 --> 01:13:16.590
Miles E Jones: The The thing that we want the algorithm to do it does right so let's let's look at that.

574
01:13:17.760 --> 01:13:19.920
Miles E Jones: Okay, so let's restate the loop and variant.

575
01:13:21.420 --> 01:13:25.080
Miles E Jones: This is kind of like the part three, prove.

576
01:13:26.280 --> 01:13:27.330
Miles E Jones: algorithm.

577
01:13:29.640 --> 01:13:30.690
Miles E Jones: is correct.

578
01:13:33.840 --> 01:13:35.160
Miles E Jones: Okay So how do we do that.

579
01:13:36.480 --> 01:13:41.820
Miles E Jones: We say so we know we have proved we have.

580
01:13:43.080 --> 01:13:43.830
Miles E Jones: proven.

581
01:13:45.630 --> 01:13:46.860
Miles E Jones: loop invariant.

582
01:13:49.500 --> 01:13:52.110
Miles E Jones: is true after.

583
01:13:54.660 --> 01:13:55.230
Miles E Jones: T.

584
01:13:56.280 --> 01:13:57.270
Miles E Jones: iterations.

585
01:13:59.400 --> 01:14:04.380
Miles E Jones: For all T in between zero and minus one.

586
01:14:05.880 --> 01:14:11.670
Miles E Jones: And then, this is usually how this part goes you say in particular.

587
01:14:15.180 --> 01:14:16.350
Miles E Jones: looping variant.

588
01:14:20.190 --> 01:14:25.500
Miles E Jones: is true after and T is equal to N minus one.

589
01:14:27.570 --> 01:14:31.890
Miles E Jones: or when T is equal to N minus one or after N minus one iteration.

590
01:14:33.420 --> 01:14:45.300
Miles E Jones: Usually kind of like plug in the last iteration for T and show that the result of the loop invariant is equivalent to the algorithm specification, the problem of specification.

591
01:14:46.380 --> 01:14:49.980
Miles E Jones: Particularly loop is very is true after T is equal to N minus one.

592
01:14:51.240 --> 01:14:52.320
Miles E Jones: In which case.

593
01:14:56.610 --> 01:14:57.300
Miles E Jones: count.

594
01:14:58.320 --> 01:15:00.810
Miles E Jones: is equal to the number of.

595
01:15:02.520 --> 01:15:03.660
Miles E Jones: occurrences.

596
01:15:08.040 --> 01:15:08.910
Miles E Jones: 00.

597
01:15:10.140 --> 01:15:11.850
Miles E Jones: In the entire list.

598
01:15:19.980 --> 01:15:22.590
Miles E Jones: This is exactly.

599
01:15:24.960 --> 01:15:25.650
Miles E Jones: The.

600
01:15:28.440 --> 01:15:29.400
Miles E Jones: The goal.

601
01:15:30.870 --> 01:15:32.700
Miles E Jones: Of the algorithm.

602
01:15:37.980 --> 01:15:38.880
Miles E Jones: algorithm is correct.

603
01:15:45.870 --> 01:15:47.310
Miles E Jones: Any questions or comments.

604
01:15:56.190 --> 01:15:58.560
Miles E Jones: back to the inductive hypothesis lie.

605
01:16:36.480 --> 01:16:38.520
Miles E Jones: Okay, so let's end it there and then on.

606
01:16:40.080 --> 01:16:49.020
Miles E Jones: On Thursday we're going to see some recursive algorithms and talk about how to analyze those run times and correctness proofs.

607
01:16:51.870 --> 01:16:59.070
Miles E Jones: But i'll stick around for a little while to answer any other follow up questions you'll see that recursive algorithms are.

608
01:17:00.060 --> 01:17:09.450
Miles E Jones: Or, in my opinion, there are a lot easier to prove they're correct because you don't have to do any of this loop and various stuff you just kind of have to do an induction.

609
01:17:12.660 --> 01:17:13.470
explain that.

610
01:17:14.580 --> 01:17:20.880
Chengjing Yuan: The part that link to like to your second sorta it was was that, too, and again.

611
01:17:36.270 --> 01:17:39.030
Chengjing Yuan: So, like for the one in this one.

612
01:17:42.900 --> 01:17:44.220
Miles E Jones: So there are.

613
01:17:45.240 --> 01:17:47.190
Miles E Jones: The the entire list.

614
01:17:48.090 --> 01:17:49.770
Miles E Jones: Right is of length to end.

615
01:17:51.750 --> 01:17:53.460
Miles E Jones: Right and.

616
01:17:54.810 --> 01:17:55.650
Miles E Jones: The.

617
01:17:57.870 --> 01:17:59.550
Miles E Jones: This algorithm in the worst.

618
01:17:59.640 --> 01:18:04.530
Miles E Jones: possible case you're gonna have to consider every single one of those elements.

619
01:18:08.910 --> 01:18:11.070
Miles E Jones: Yes, so, in the worst.

620
01:18:11.070 --> 01:18:15.750
Miles E Jones: Case they're going to there's going to be to an operations.

621
01:18:18.990 --> 01:18:22.740
Chengjing Yuan: But wouldn't like so we're combining into one single list.

622
01:18:25.620 --> 01:18:29.940
Chengjing Yuan: Like from A to B in like we're considered as a single list or.

623
01:18:30.780 --> 01:18:37.920
Miles E Jones: We can consider it, however, you want i'm just saying that the fact of the matter is that there are two n elements.

624
01:18:38.940 --> 01:18:39.540
Miles E Jones: Total.

625
01:18:44.550 --> 01:18:49.290
Chengjing Yuan: So, but wouldn't a like because seriously repeatedly for each iteration of be.

626
01:18:51.120 --> 01:18:51.750
Miles E Jones: So yeah.

627
01:18:52.800 --> 01:19:03.390
Chengjing Yuan: Like before I before he duration wouldn't be like a one to be considered like once after each loop of V1 to V2 like for be one is going to become certain times and for me to.

628
01:19:04.770 --> 01:19:06.270
Chengjing Yuan: is going to be considered times again.

629
01:19:07.200 --> 01:19:14.610
Miles E Jones: So that that doesn't happen here, and the reason is because this is equal to one.

630
01:19:15.720 --> 01:19:29.790
Miles E Jones: It only ever is set at the very beginning of the algorithm and then, once you get in it doesn't it doesn't reset back every time you go to a new be element.

631
01:19:32.070 --> 01:19:32.400
Chengjing Yuan: Okay.

632
01:19:32.460 --> 01:19:45.570
Miles E Jones: You start where you left off in the a so it's kind of somebody was also talking about kind of like having these two flags, you can kind of think about it as like these two pointers to the a list and the B list and.

633
01:19:46.260 --> 01:19:50.670
Miles E Jones: They kind of like move, you know the kind of like both sort of inch their way.

634
01:19:50.700 --> 01:19:53.010
Miles E Jones: Through the lists, but the.

635
01:19:53.460 --> 01:20:04.830
Miles E Jones: The key observation here is that they're both only moving in one direction so in the very worst case, this point or has to has to point to.

636
01:20:05.190 --> 01:20:06.600
Miles E Jones: All elements of a.

637
01:20:06.840 --> 01:20:11.010
Miles E Jones: And this point, I have to point to all elements of B, which means you've pointed at.

638
01:20:12.060 --> 01:20:13.230
Miles E Jones: Two elements.

639
01:20:14.910 --> 01:20:16.080
Chengjing Yuan: All right, got it Thank you.

640
01:21:38.790 --> 01:21:40.920
Miles E Jones: Okay, see you off i'm going to.

641
01:21:42.120 --> 01:21:48.120
Miles E Jones: meet with a ta real fast so stop recording but i'm.

