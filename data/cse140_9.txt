 Mm-hm. Welcome back everybody. Before I get started, I wanted to let you know I've had some issues with network in my house. So if I drop off, don't be hugely surprise did happen about five or six times earlier in the morning. I was able to recall or a full lecture for the earlier time this morning from 930 to 11. So if all else fails, we at least have one good recorded lecture, but you guys can watch. Let me revisit where we are. So what we've covered so far or memories, latches and flip-flops. Today we're going to talk about registers, counters and finite state machines, which is actually quite a bit to cover in the day. Exam number one, we're very close to done, but not completely so by Tuesday, but we'll definitely have full results. And so far, the maximum score is 110, which I'm sure he's not going to change that score. So congratulations to whoever got it. The current, the average is right around 70%, which if it remains this y, I would expect to curve the grades to average of about 75% for the class. Minimum that we got so far is nine, which scares me a bit. So if you are not doing well on this exam, you should definitely talk to me and to the teaching staff and see if you can get some help in being able to actually move forward with this class. But when we look at the questions, the question number one, the average was around 60% over all of the different versions of the question that we had. So that's a little low. I would've liked to have seen that the little higher question too, average is closer to 80% across all versions. So question two we had question three. Average is even higher. It goes up to about 88%. So it seems that people really got the question three material and question four was the lowest. It was around 50%. My guess is that the timing might have been an issue. So the planets, as I set the finished grading this, we're actually gonna look over, you know, how many people had issues with uploading. And I think in one individual had some issue with downloading as well. So we're going to try to figure out what is the right way to handle various problems that seem to have occurred. So far, my count is that we had 14 people who had some issues with uploading out of about 335 people that are in the class. So that actually statistically isn't too bad. But I really would like to make sure that you guys feel less stressed around that. So my guess is and again, I don't know this yet for sure because I don't have all the results, but my guess is that next exam we'll have some extra time. So it's a little less stressful for everybody, especially when it comes to dealing with uploads. Okay. But we'll discuss that more next Tuesday. I do expect to apply to the results or sorry, not the results, but the solved questions. On to the web. You will, you should be able to see solutions hopefully at the end of the day to day or at the latest, thoroughly tomorrow. It will be posted only on Canvas. You will not see it on the class website. So feel free to take a look. You'll see we had four versions of each question. So take a look at what we've done. And that hopefully will help you. Once we release the grades again, you will have 45-minute window in which to sorry, not 45-minute, 24-hour window in which to ask for a regrade for your question. Okay. The other things, deadlines, homework number three is due today. Hallmark number four will be assigned today and it'll be due next Thursday. And let me get started. But just a little bit of a review before I get started. Does anybody have any questions at all? Okay, so let me review quickly what we have done with bit storage so far. So SR latch, we covered right that beginning in SR latch we have the following truth table. So if S is one and R is 0, that means that the output will be not reset but set. If S is 0 or R is one, output will be reset. If both are 0, output will be whatever it was at the last instance or whatever we had. Store it. So this is a whole state. And if both are one, this is don't care state because we never want that to happen. The level sensitive SR latch was slightly different in that it has a clock. So here's my clock. And then it had our S and R inputs. And here is the Q output. So if clock was a 0, SNR did not matter. The output was going to be just whatever it was before. So this is a whole state. If clock is one, we have standard SR behavior. Okay? Then we improved on it by designing a D latch, and we did this by adding an inverter. So again, we still have a clock. So here we have two inputs, clock and d. And here is our next state. If clock is 0, D doesn't matter out, but there's going to be whatever was there before. So this is the whole state. If clock is equal to one, the output will be what the 7A is at the input D. Notice that this is going to copy what ever is at the input, as long as clock is equal to one. Okay? The last one is the flip-flop. Them notice that the flip-flop has two latches and so it's much bigger. And in this last flip-flop, the only time that anything happens is add the rising edge of the clock. So if rising edge of the clock occurs, the output Q plus will be equal to whatever is the input, but it's equal to whatever is at the input only at this one little point in time when rising edge occurs. Otherwise, if it's not rising edge of the clock. So any other time, regardless of what D is, the output will be what it was already. Okay? So just to clarify, Q plus this next state, q minus its previous state. Okay? So the key here is rising edge. Now remember, and here it's basically level sensitive. And in this case, as long as clock is one, it copies. Ok. Notice that we also, if we move this inverter to the servant instead, then they have a falling edge. And falling edge, everything is the same. The only difference is, is that all the events happened when the edge falls. Any questions on this? This is just a quick review hopefully for everybody. Okay, so let me compare latches and flip-flops or would like to compare them by looking at the waveform here. Now notice that here, have a positive edge triggered Flip-flop. I know it's a flip-flop because it has this little triangle for the clock. This is a D flip-flop. It has a Q output. It also has what other output that I did not draw on here, but we know it hasn't exactly. It also has the q prime output. We're not drawing it because we imply if it's a flip-flop, it always has both of those outputs. Ok? The other is a level sensitive latch, and I know it's allowed to because there is no triangle on the clock. Level. Sensitive collateral copy, whatever is at the input. The output as long as clock is high. Okay, so for the positive edge triggered flip-flop, we're going to look at whenever clock goes from 0 to one, what is at the input? So whatever is the input at that point in time is what gets copied to the next state and what gets held until the next rising edge. So when we first start out, this is our Q flip-flop. Output hears or pure latch. So when you first start out, both of the outputs are at 0 and the first rising edge. Over here, we're gonna go from 0 to a one on the Flip-flop because there is a one right here, that rising edge. We know don't care at all what LSD is until the very next rising edge, which happens here. So this just gets copied all the way until the next rising edge, it gets held. Right? So the only time it's going to change is right at the edge. Now in this case there is no change because D is still a logic one. So we're gonna keep the logic one and we're going to hold again until the next rising edge of this rising edge D is a 0. So we immediately change. So that says change to 0 at rising edge. Whoops, sorry. Okay, and then we hold again all the way to the next stage. And then here again, we see that the input is a 0. So behold again, until the next edge, the next edge we see a change into the logic one, because the rising edge D is a logic one. Now my move and we call them till the next rising edge. Because these 0's here, we go back to 0 and we stay at 0. Ok? So the key of its flip-flop is only that rising edge. Do you load anything in? No other time the rest of the time you hold whatever it is you had. Ok. Now I'm going to move on to the latch. And latch is interesting because here we're looking at when clock is equal to a logic one. As long as clock is a logic one, we're going to copy whatever is any input to the output after we're done copying. So at this point, we hold whatever was there last. So this is why we have a logic one at the output of a latch, because latch, input handle logic one the whole time. And we're going to hold until the next logic one. So we hold between these two instances. Then we look at what is the in between here and here when we copy. And then again, we're going to hold because at that point clock it's a 0, so we're just holding whatever was there and right before the plumped change to 0. Now once we get to the next spot, notice that d now changes to a 0. So we're going to again copy during this period here. This is a copy. Now D is a 0, so there is nothing much to do but just hold it. Once a clock goes back to 0, then we hold again at a 0. And here clock is equal to one, so we copy. But since input is a 0, nothing changes. And then we move again to the position where we hold until clock goes to one. Now at this point, notice that D is a one, but it also changes back down to 0 during the time that we're doing a copy. So that's why you see a copy here of exactly what happened at the input D and why it's going to hold on to the next time that clock is one, it's going to hold the 0. So even if I had a little blip here, that blip will not be visible because here I'm holding. Okay. And now we move to the last piece. Again. I'm copying that and I kind of circled the little too much here. I'm gonna copy, right? What is between this? And notice that this copy occurs exactly while the clock is equal to one. And after that we hold. Ok, any questions on this? This is very important to understand. And I believe you have on your homework assignment to draw a diagram that's similar to this. By just has some logic gates outlet to it. Okay. If there are no other questions, no questions on this. Let me move on. I wanted to quickly review the set and reset features. We went over this last time, but it was a little quick. So I want to make sure to remind you. So here is my flip-flop. If I want to put the reset, I would put an AND gate with D and with not r. And in this case, what will happen is if reset is equal to one, the output of this gate will be a 0. Output of an inverter is 0, which means I put the 0 at the input, which means q is going to load the 0 and the rising edge of the plump. If reset is equal to a 0, then I have a situation in which next Q will be equal to D ANDed with a one because of this inverter here. Which means that the next input that will be loaded will be just whatever is at the input D. So that is a reset. Preset works the same way, except it's an OR gate and it has a set signal. So here is my queue. And here, if set this equal to one, q will be equal to one at the rising edge of the flop. If set is equal to 0, Q will be equal to d or 0 at the rising edge of the flop clock, which means that you will be, the next cube will be equal to just whatever d is. If we have both of the preset and reset, it depends on which is dominant. So let's say that I take reset dominant. In this case, what would happen is I would have something like this. I could express this as r prime ended wet, the 4D wet.'s. So what I would have is an AND gate with an inverter on this. And the other input to this would be the or gate that has set and it has deep. Okay? So here is my b, here is my Q, and here is o'clock. Now notice here, if reset is equal to one, the D flip-flop input is going to be equal to 0. And it does not matter what is on the other line. So if r is equal to one, what we have is a 0 here. So this means that it is reset dominant, which means regardless of what site is it will load a 0 into the flip-flop. If r is equal to a 0, which is another option here. So if r is equal to, oops, sorry. If r is equal to a 0, then what's gonna happen is whatever sect is will dump, will determine the what is loaded. Okay? The last one is the multiplexer one. So in this example we had the mux that loaded into the flip-flop. And the flip-flop, I believe loads when the load signal is a 0, which is this peaceable load, the previous value. And the load signal is a one. It will load something new or the data input. So this is what that would look like. And the last piece to remind you of is that we always have both Q and Q prime available. So don't forget that. Ok, any questions on these? Okay. So let me move on to the very first poll of the day. We actually do have bunch of polls today. So hopefully you guys can stay awake and engaged. For all of the exciting poles. In this example, they revisit what we did last time, but latches, but now it's with flip flops. So notice that here we say that we start with all zeros and then a rising edge of the clock. And this is just one clock. So just a single rising edge. Y is going to go from 0 to one. So there will be an input, the one here. The question is, what will be stored in the flip-flop after that single clock? Okay? This is only one rising edge. We'll talk later about what happens with multiple edges, but single rising edge, just one. Okay, I'll give you ten seconds. And 543210 are super long five seconds. But most of you think it's a, that there is only one pattern. However, there are a number of you who have other opinions. So let's go over this in a second. This is quite important that everybody understand. So if I have only one rising edge, just a single rising edge, what will happen is the first flip-flop with low below the one in here. The second flip-flop will load the 0 from the previous flip-flop. The third flip-flop will load the 0 from the flip-flop two and the fourth flip up with low the 0 from a flip-flop three. So what we will effectively half after just one rising edge is 1000. If we have to rising edges, then, and why just held that? The one, what we have is one 1-0-0. At three rising edges. You will have 1110 and it's for rising edges, you can kind of guess what happens. You will have 1111, okay? So answer C is correct. If it is four edges, not correct if it's just one edge, answer a is correct because of it they're expressing for both clocks a and B, just one rising edge. Now notice this is very different from what we did with latches. Because with latches, what mattered is how long is the clock on? And the fact that the clock B is on for such a short time might effect how much propagates through the latches. On flip-flop. It totally doesn't matter. What matters, is only the rising edge occurred. It doesn't matter how long that rising edge is, how long one is held. Now, that, that actually turns out does not completely true, we're going to talk about timing next Tuesday. But for right now, we're assuming that all of these gates are stupor incredibly fast and they can compute in near 0 time. In fact, you can assume that data propagates in a small delta time, which is super close to 0, but it is not equal to 0. Ok? So this means that you will be able to load the data predictably enough flip-flop, but it won't propagate instantaneously to all other flip-flops. So that is why a is correct and B is not correct because it does not matter and how long the clock is held high. And then D and E are not correct because a is obviously correct. Any questions on this? So this particular design is actually a shift register and not the laser to shift register. It is a right shift, right? Because we were shifting something in to the right. This also happens to be a very common design that is used in all of the processors for any kind of serial communication. And I see I have some questions here. How long does a write a rising edge last for its instantaneous in this class, obviously impossible in reality. But you can assume that the rising edge is much, much, much, much, much faster than the amount of time that the clock is one or 0. Why does only the first few get while you have one? It's because we're talking about flip-flops. In flip-flop you load only the value that is there at the input, right? That the rising edge. So because one is present only at the rising edge of the flip-flop one and it is not present. Flip-flop to edit template has a 0 over here because that is the value that flip-flop one was holding. So that will be the value that flip-flop tuba load. And same thing with 34. This is why this works as a shift register and it works as a very predictable shift register because on every rising edge it'll shift one value in from whatever is edit template, whether at the input is the previous output of the previous flop or the empathy is something from the outside. So you put the, if you put this something from the outside, an example would be for, for example, if I have USB connection, USB is a serial bus, so it's going to be shifting in values one bit at a time. And this is in fact exactly how this is implemented on your computer. What it does is it shifts in. Now obviously it won't shift in only four bits. It's going to shift in 64 bits probably because you're registered, your CPU's mostly are 64-bit register size. What's a chips and 64-bits, it'll load that value into the processor. Then it will then do operations on that value. But it will take it literally 64 rising edges to get that shifted that, which is why we're super happy that clocks run in gigahertz range because otherwise you would be sitting there forever twiddling your thumbs, waiting for values to shifting. Ok. Any questions on this? This is actually pretty important to understand. And on the next slides we're going to talk about how to build registers and how to build a universal Shift Register. So if you have those questions that's about to come. All right, moving on. Here is our basic register. This basic register, it takes inputs and loads them on the rising edge of the clock and then produces a new output. Notice that all of the flip-flops have a same clock signal. So we can draw a box around this, and that is what you get then that would be the symbol for the register. So an example when such a register might be use this if I'm trying to load from some memory location into a register a, this may, for example, be my Registry. Now what I'm loading might come from memory, it might come from outside, like I gave an example of USB input. There are many different places it might come from. Notice that this input is effectively 4-bit bus. So I can represent it using a single line width four bits. And presumably, what that means is that I can actually split up four wires from that single bus, each into a separate flip-flop. The same thing happens at the output. I can create a 4-bit output bus that will be represented like this. Okay? No, this is not a shift register. So here I cannot shift theta left or right between the bits. Here I can only load the data and I can read the data out. So I can also store the data, for example, by reading the data and writing it to some memory location. I read it by just looking at what's the output. So flip-flops will just hold those, that data in storage and the value will remain stable on the output wire. Okay? Any questions on this? Okay, there is no question. Let me move on to a shift register and a pattern recognizer. This does occur on your homework. So pay careful attention here. This example has a fairly simple version that's easy to implement in a single slide and class. So here you have a shift registered that ships data in at the input. So for example, if I start out with values zeros, 0, ones, oops, sorry. What the heck. Let me return back to my normal display. Okay, you guys see the normal display, I hope above. So here it goes here to values. Let's say that they have 1-0-0 one. Ok? And let's say that I'm inputting that in. So, and let's imagine that I started out with all zeros stored and my flip-flops. So if I did this, what would be happening as I would on every clock cycle, I will shift in one value. Let's say that the first value is a one. So what the next step would be? I would have one into my first flip-flop and then 000. Then the next value shifts and so there'll be a 0, but the current one will shift to the next flip-flop. 0 will shift to the next one and so on. Okay? Now the next rising edge of the clock, I'm going to shift the second 0. So here's one more 0 shifted then, and then everything else shifts to the right. And then let's say that I have the last one that shifts it. So the first flip book will have a one. Next time we will have a 0, the next one will have a 0, and the last one will have a one. Ok? So is it clear now how exactly I am doing the shifting enough values. Basically on every rising edge of the clock. I'm loading a single bit into the first most left flip-flop and everything else is shifting to the right. Now notice the interesting thing that at this point I have a pattern 1001. What happens to the output when this pattern is loaded in my flip-flop? So when I have these values stored in here, what is my output equal to? Exactly? My output is going to be equal to 0. If the pattern is 1-0-0 one. What happens if a pattern is anything else? So for 1-0-0, one out is a 0. Else, what is it? It's a one. So this is effectively a pattern recognizer. And the pattern nick recognizes its 1-0, 0-1. You can imagine that there's a walk. If you shift the right combination to the lock, it will unlock, otherwise it won't, they'll block. Okay, so this would be a great example of how you can design a pattern recognizer that's based on a shift register. And that it's super simple. So you can recognize any 4-bit pattern using this poor relies bits basically you can recognize, okay, any questions on this? We get, let me move on. I want to talk about how to design a universal shift register. And this register I want to shift right and shift left. And I would also like to be able to just load the input then. And the last piece I chose to do is I want to be able to just hold the output. The question on the previous one was, do we use a NAND gate since it's less transistors? Yeah, that's why I like the NAND gate Exactly. So the last piece in this story is I want to be able to clear all of my bets to unknown value. So use a clear signal, which means that I'm going to set all of the bits to 0, each one of the cells. So let's say this is my 0123. So each one of these cells inside will have to have a Flip-flop, a D flip-flop, which has at its input D And as its output cubed. Now, obviously, we know that it also has a q naught. But for the universal shift register, we don't really need to use a q naught. So the first step on this, what bait to realize that we need a multiplexer to implement all of these combinations here. So that is what that multiplexer represents. And notice that here controls and 0 and S1 represent the most significant bit and the lsb. So whenever they're labeled like this with a 01, you know that one is going to be more significant than the Zara. And now I'm going to look at and see how I can connect all of the rest of the gates. So the first thing I wanna do is I want to make sure that I have a universal and synchronous clear. It is universal because a single clear signal that is right here controls and clears all of the flip-flops in all of the cells in a synchronous because it will happen only on the rising edge of the clock. Okay? So the next step is to start implementing all of the other values. First, we're going to implement a hold. Notice that here I think the current state and I loaded back through my multiplexer into the D input. Okay? The next one, it's going to be when I'm shifting to the left than when I'm shifting to the right. And lastly, I'm going to deal with when I'm just loading the input, which is the input combination three. And this effectively creates my universal shift register. Okay? Any questions on this? So the last piece obviously to connect all of the cells together, and you see that right up on top here. There are no questions. I'm going to move to counter this counter a super exciting. It counts through a sequence. And let's see which sequence I'm going to start from 0000. And I'm going to look at what happens at every single rising edge knife. I just had a 0 stored. So if I started out that those zeros clips, then what I've stored and here is a 0, that 0 is going to come to an inverter, it will become a one and it's going to get loaded on the next rising edge straight into my first flip-flop. So my first flip-flop will then have a one. All the other flip-flops will have zeros because they will have been carried at zeros from the previous one. On the next rising edge, I'm going to load another one, but the previous one will shift to the right. And same thing keeps happening. I keep shifting on every single rising edge. Okay, are we OK so far? So I'll end up with all ones. Now if I have a one at the output of the flip-flop number for that one will become 0 here, which then gets input to the first flip-flop. So again, on the next rising edge, I'm going to get a 0. But no one's gonna shift straight over. And on the subsequent the edges I shift in more zeros while shifting ones out. So here we go. And the last pieces all zeros. And this means that now I can go back to my cycle. So the cycle is 12345678 counts long. So effectively I can count to eight in circles using this. Now, how much could I actually optimally count if I use four flip flops to store by count value, how many numbers can I counter? I can count more than 50. I can count from 0 to 15. So I can count total of 16 values. So I can certainly designer counter, that's a little better than this. And it turns out that this particular design, people oftentimes will use XOR gates to provide the feedback. And that you can actually create a relatively simple design that has only one or two gates that will cycle through all 16 possible options. But it will cycle through in a way that looks random to a casual observer, but actually isn't completely random. This is the basis of linear feedback shift register, LFSR, which is the basis of all random number generators in all of the processors and niches you probably now is a key piece to creating any kind of crypto codes. In fact, all of the crypto codes are based on something very similar to what we're learning right here. Obviously the differences is that they don't use only four bits and a whole lot more than 4-bits. I think 128th is state-of-the-art. Now if I remember right. So, but we're going to do in this class is going to be relatively simple. We're gonna stay quiet about maximum four bits because that's about the size of the K map that we want to handle. But in general, as I said, you can use this design for a lot more sophisticated types of functions. Ok, so any questions on the counters before I moved to finite state machines? Okay? There are no questions, I'm going to move to finite state machines. So in finite, in circuits, when we talk about the logic circuits in combinational logic, we had, we would write truth tables, which would allow us then write boolean equations that are hopefully minimized, form up whatever we had in the truth table. And it also allowed us to draw logic diagrams using gates that express the particular function that we wanted to have in circuits. What's new now with sequential networks is that we're going to have some feedback. So instead of having only one way flow, like we had in combinational logic, now we have both storage. So this is an example of a register that has multiple flip-flops which may store. State. And that state is then used in combinational logic to compute the next state and also to compute the output potentially. Now notice that the output here is a function of also whatever the current status. So current_state is whatever is stored in our current flip-flops. Next state is whatever the logic has computed should be loaded into the flip-flops on the next rising edge. Now the other thing that I wanted to make you aware of is something called register transfer level. What this means is actually pretty simple. What it all it says is that going to have some registers at the input, then I'll have combinational logic that I'm gonna use to perform some computation on to produce output that is again going to be stored in a register. So literally I'm transferring data from one register to another. And in the meantime, I'm doing some operations on it than what I'm doing is described by using RTL descriptions. So in the lab, hopefully you guys are getting some experience writing verilog code. Verilog code is what you would use to describe RTL level description for you to combinational or sequential logic. Now if I was doing and machines, I will also have some feedback loops like I have here. I can have RPL that does not have feedback loop, that just does the transfer. An example of where you might do that is when we're doing LU based computations where we would take data from the register or from memory we were loaded into LU preform competition in and know you and then whatever was in ALU would be input into a register or output into the memory and eventually output out of the circuit. So this is a very basic, a new type of diagram that we're going to be thinking about, that they will include both state and inputs and outputs. So let's revisit our counter. This is a two bit counter example. In this example, we do assume that we have o'clock. So we're going to be using always rising edge of the clock unless I specifically WAS a falling edge. And into bit counter, we're going to have count through four different sequences. We're going to start in state that's 0, which is going to be labeled using two bits, 00 state this one, 201 state S2 will count to 1-0 and state S3 will count to 11. And on and on, it goes in circles. Now if I want to represent the state table, what I will do is I will just put state names in it. Were state names are as 0, S1, S2. And I will tell you how I transit from current state to the next state. I can actually move that state table to something that looks like excitation table. By specifying what binary combination. Well, my states big. So because here I have four states that I'm trying to represent. I need two bits to represent those four states at least. So my state a 0 will be 00. This is the current state. My next state if status and here is q at t plus one, that would be my next state. So if I'm in current state 00 and my next state is 01, which corresponds to S1. If my current state this S1, which is represented by 01, what should be my next state? It should be 1-0, correct? If now I'm in state 10, what should be my next state? 11, and finally 11, what is my next state? 00. Excellent. So now I know exactly, given a current state that I have here, one of the most significant and least significant bit of my next state. And notice that now I can use k maps to actually create logic for most significant then the least significant bit of the next state. And it will not in fact, a whole lot of gates to implement this. So now, what do you guys have any questions on this before I go to next slide? Okay, so now we move on to a super exciting part where we have a pole. And you get to think about this again. So what I'm interested in is what kind of circuit is likely a realization of this two bit counter. So excitation table that I'm showing here. So this is excitation table. All that means is that I'm representing the current state, the next state using binary values, the bits that I would actually want to compute on using my logic gates in state table, you're using state names. Okay? So the question is what I implement these two bits using combinational circuit only and without the need for the flip-flop, what I need to flip flops to start my state and then use those two flip-flops to compute the next state in addition to combinational logic, or can I get away with, because I have only Q1 and Q0, how can I get away with using only a single flip-flop together with some combinational logic. Okay? I'm going to give you a 54321 and check out these results. C was actually inching ahead, do it a little more than half, and let see what is the actual result here. So first of all, combinational circuit would not work because I have to be able to store the state I need memory. Because I want to keep whatever the current status before I actually update it with the next state. Okay? Now notice that my current state is built out of two bits. The only way for me to store those two bits is to use two different flip-flops. So this is why the option B, and in fact the slightly less than half the class turns out was right. Option B is a correct option because I need a place to store my Q1 and my Q0. And then those become also inputs into the combinational circuit that's going to generate the queue. I forget Q1 plus and Q0 plus, which are going to be loaded on the next rising edge of the clock. One bit is not sufficient simply because I have too much information to store. I have a combination 00011011. I cannot store that into single bit. So that's why C is an incorrect answer. Do you guys have any questions on why this is? My B is correct. Okay. So into bits, counter circuit, we will store the current state using D flip-flops because that's why the inputs combinational circuit will not change while we compute the next output. And it allows us to control when that transition occurs, which will happen only at the rising edge of the clock. Now how do I figure out how to get the output? Well, some of this is really easy. For q. One of t plus one are Q1 plus all it is, is looking at when is it the logic one? And here I can see that this is a logic one when Q1 and Q0 are exhort. For the other one, which is q 0 plus the correct output seems to depend only on q 0. In fact, it turns out it's Q0 not. So this would be a very simple approach to solving this problem, where you just use standard K maps the same way that we have always done before. In this case, I didn't even need the came up. I could just read it out because it's a very small problem. So I would then take these equations that I have here and I will create a circuit based on them. So here is the circuit that you see, okay? And here are the equations. This here is an XOR. Whoops, I don't know why does that periodically. Ok. So I can delete this piece here. So it's not so messy, right? Yep. And notice that the output, so here is the Q0 plus, here is Q0 out, but here's Q1 output, and here is Q1 plus input. Ok? Any questions on this? Okay, moving on to finite state machines. Finite-state machines, and I assume you have covered in previous classes. So in this class we're going to really just focus on how do we build finite-state machines in the hardware. Our focus is not on just on teaching you how to design them necessarily, I'm assuming that you have some experience with that. So if I take machine both consist of set of states, set of inputs, a set of outputs, initial state. So here's an example of initial state and transitions of which only one can be true at a time. So in this example, I'm assuming that a is equal to one, but b is equal to 0, or b is a. Don't care. When we transition to a state, they now notice that B cannot be a. Don't care because I'm the second edge. B has to be equal to one when we transition to state B. So here B is one, a is equal to 0. On all other cases we assume. So. This is the case whether it's 1100, we assume that we're staying in the initial state. The Finite State Machine representations can be represented with a state diagram and a state table. And I'll give you that example in the very next slide. So here is an excellent example of a 3-bit counter. This 3-bit counter actually counts all the way from 0 to seven, so it goes through all possible combinations. This here is a state diagram that represents the counter state table. What name each of these states using normal names with ladders. And they want to show you for the current state. For example, a is 0. What is the next state? In this case would be S1. For S1 and would be S2 and on it goes. So that would be a state table. The state assignment is when we say that state that's 0 should be represented using three zeros state this one should be represented using 001. Once we have that, we can create an excitation table from state table and state assignments. So this, and this gives you the excitation table, which is shown right down here. So this here is the current state. This here is the next state. Now in this particular design, we don't have inputs and outputs. If we're dead, inputs would go unless side outputs would go on the right side. And once we have this, we can do a circuit. How do we do a circuit? We do K maps, three different K maps, one for each next state, bit, most significant, middle, and least significant. And then you can actually draw the circuit. And here is an example of what that circuit would look like. Okay? And I'll let you analyze this circuit and convince yourself that in fact, this does implement the counter that I showed in the diagram. So this is a great example of what they expect you to do in the homework when we talk about designing, designing finite state machines in hardware. Now I will actually go through a bunch of examples of how key maps would look like. But let's say that for n three, I wanted to do a K map. I would just draw my current state, let's say c3, c2, and c1 output all of the combinations in. And then I would populate this whatever is in the end three column. And then I will do my sum of products or product of sums depending on how many ones and zeros I have. Ok, so let me move on to also teach you the difference between Mealy and Moore machines. So a mealy machine, the key is that the output. So this is the output is a function of the input and the current state. Okay? Whereas in Moore machine, the output is only a function of the current state for both of them. Next state is a function of the input and the current state. Okay? So the key difference really just happens in output. There is no difference in generation of the next state. So the key difference, it isn't output. So if I were to look at the diagram for Mealy machine, the output is generated by using the input and the current state. Notice that the next state is a function of the input and also the current state. So the next state, this generated using Diagram C1 in both cases, and it's done the same way using input, the current state. The differences in this diagram C2, which and mealy machine uses input X of T and current state. And Moore machine, it uses all lay current state. That is really key. And you can see that also in state diagram, because a Mealy state diagram, the output changes. Whenever the input changes. Whereas a more state diagram, the output changes only in the states. It does not change, add the edges. So output this function of only the current state. This is the current state. Ok? Any questions on the difference between Mealy and Moore? Okay. Now we're gonna go through and recognize life on Mars. It's a super exciting day in your life. You get to operate the Mars rover, which has a single sensor, input x, when it receives the input sequence 001. So first two zeros followed by one. From its life detection sensor. It means there is life on Mars. It has just detected it. And it's going to output the one. Otherwise, it will output to 0, which means sadly that there is no life on Mars. So the question is, what should this pattern recognizer half? And I'm going to launch poll. Again, this ball is not graded and it's anonymous. It's here just to help you guys learn a little bit. So the question is, should this pattern recognizer have a one state because it has one output, b, one state because it has one input, C, two states because the input can be 0 or one. The more than two states because various reasons and E, None of the above. So give that some thought. I'll give you a 543210. And most of the people really like option C, that it has two states because input can be 0 or one. And let's see what happens. So let's talk through this. First of all, should it have one state? Because it has only one output? Output frankly has nothing to do with the state at all. We need states so that we can remember this sequence. The only way to remember this sequence is for us to store it in memory. Otherwise, as the data comes in, it just disappears. We can't remember it from one sample to the other. So that answer a is definitely not true. B, one state because it has one input to this truly has one input. However, again, going back to the sequence, you really have to be able to recognize the sequence. So that means you have to store it some place. And the fact that it has one HIPAA doesn't help you store it anywhere. So you need more than a single state, c two states, because input can be 01, it is possible that you can get away with two states. It turns out for this particular problem, you cannot, you need more than two states. So definitely this part of these true. However, it is not related to the fact that input can be 0 or one. Otherwise, any finite state machine could be implemented using a single bit. So c is actually totally not true. It is very, very rarely to almost never true, that you've only used two states. It's only works for very small finite state machines. And the reason why you would use to states has nothing to do with the fact that did, but can be 01. And then E is not true because d is true. In fact. Ok. Any questions on this? Okay. That means you guys are ready. Implement the recognizer. We want. The question is which of the following is correct mu, a solution for our pattern recognizer. And I'm going to launch the poll again. There you go. So think about it. How would you design a finite state machine that recognizes a 0 followed by a 0, followed by a one, and outputs a one once it sees that pattern. Okay, I'll give you guys 54321, second row. And let me share the results. So we'll slow, turns out classes evenly split between a and b answer. So we should definitely walk through this and discuss a few people thought C and D. But it turns out that it's definitely not C and D, Unfortunately, let's talk about this. Ok. So looking at this design, Let's start first with Part a. So if we start in state 0, we're interested in recognizing first a leading 0 of this pattern. So if you get a one, we're just going to go back and wait until a 0 appears. If a 0 appears will go to state this one. In this state, this one. We have recognized in fact that 0 has occurred. So this is good news. But if we now get to logic one, so if we have a situation where we have 01, that's bad news because that definitely means that there is no life on Mars. So this is why at that point, we return back to state 0 and we wait until we get again just a single, oops, sorry, single leading 0. So when we have a single leading 0, we're gonna wait for one more 0 so that 0 will bring us to state as to in which case, in which case we have two leading zeros. At this point. If we get more zeros, that's okay because we'll always have at least two that are the last two that were just recognized. And at this point all we want is to finally get a one. So we get the logic one. We're super happy and make an output. Yes, there is life on Mars at this particular spot where that logic one occurred. Now once we have this pattern recognized. We want to go back to the original state as 0, because having that one does not help us recognize the next pattern. We need to get a 0 to get us started. So answer a is definitely correct. Now let's look at the answer b. So answer B, we start with state those 0. They have the same feedback. So, so far so good. We have the same transition, so this is good. Now we get into state this one where we recognize a single 0. Instate this one. We will transition to state as to now get a one. So we will transition if we have a pattern 01, that pattern will be recognized as one which is bad news that is not life on Mars. Okay. So I have a question on what does the second number mean? The first number is the input, the second number is the output. So in this example, when we are transitioning from state one to state the US, do we actually have an incorrect output? And the other thing that's a problem is this 0 here. So the problem is that if this feedback loop on zeros isn't status one, we end up with the incorrectly recognized pattern 01, which only has a single 0. What we need is we need to recognize patterns that has exactly 2m zeros before a one. So that's why this loop really should have been in the status to instead. And that's where B is incorrect, therefore sees incorrect that D we know is incorrect because a is correct. Okay. Any questions on this? Yeah, so the output should only be one if we have the pattern 001 and it turns out that the second one gives you out, but also if you only have 01001, so that's wrong. I have a quick question. Yes. So for part B, for question b, for S1 to S2, the you said the 1-1 is wrong. Yes. So what I said is in s1, you recognize the 0. And then this 11 means that right after I recognize the single 0, I got to logic one as an input. So the pattern would have been 01. Output one because it was thought that this is a pattern to recognize. So this is why this is incorrect. Oh, okay. Okay. I see already. Good question. Any other questions? Okay, let's move. Yet in another merge recognizer poll. So I'm going to launch the poll. We now have the correct state machine drawn. And my question is, what does state they will need to show to design controls of C1. So notice I'm asking only C1. Okay? So what are the controls for c1? Ten seconds, 54321. And let me share the results. Most people think the answer is a, So let's take a look. Okay. So let's see, c1 generates the next state of this Mealy finite state machine. And C1 as eight, but has its current input. So this is the input. Here is the current state. So current the input current state, and it outputs the next state. So a is correct. Let's see what's up with B. So it does have current and both has current state. But C1 does not generate current output. This is actually C2. So that's why B's not correct. C has current, the current state, it has next state, but it also has current output. So that's why this is incorrect and these incorrect because a is correct. Okay, so on the next slide, we're going to take the state diagram, which is right here, will create a state table. And state table. We have names of states so and 0, S1, S2. And we represent for different inputs. So this is x input here. What is the output and what is the next state? So here is next state. And here's the output. Okay? Then we do state assignment. So I've decided to assign as 000101 and S 110. Once I don't speak assignment, I just replace 00 wherever I have written as 0, but you replace 0-1 wherever I've written S1 and so on. This is how I get this excitation table. Again, this here is an input x, this is the output Y. And here's my next state. Okay? And this here is current state. Okay? The next step that I'm going to do, we'll just make it easier for us to do K maps. What I'm gonna do is I'm going to take the current state and the input, and I'll put it on one side of the table. And I'm going to have the next state and the outputs on the other side of the table. Ok, that's on the very next slide. So here's the same table. This is the current state, this is the input. And here I have the next state and the output. Ok. So same table as before, same combinations, I just rewrote it. And I added these last two combinations which were not represented. Notice that the current state of 11 does not exist. We don't need this. So that is why we put don't cares in all of the next state than the output because we know that this will never occur. Okay? So bad is then what would be our starting point for our logic minimization? So we will take this table and we would create K maps. So for example, I could create a K map for D1. And here Is that came up over here. And i created by using the current state. So that is this here. And an input to put all of the values into the K map. And all I did is I just took these values and I filled them out. So you can see that I don't care in column 11 for state, oops, sorry. For state 1-0. Depending on what the xis, I get, either output, the next state, this either one or a 0 and so on. So I just wrote from a truth table excitation table, which I have on the left here to the K map. And now that I've written this, I can actually do my sum of products minimization. So I might do something like this to minimize my function and I would end up with an equation. Now notice that I can also do d1. D1 has just a single one. It cannot be combined with any of these, don't cares. So this equation would've been just Q1 prime, Q0 prime, x prime. And I can do y. Y in fact is a logic one here. But now I can combine this with this to minimize further. And this gives me then y equal to q one. And the last one is a x, right? And if I was going to do this is my y. And if I was going to write the equations for the d1, then this would be equal to q one q 0, so q 0, and it would be x prime, or the other one would be q one, oops, Q1 width, x prime. Ok. It's just standard K maps, nothing else. So this would be the final equations and you can see that we figured out the equations. And then what you do is you would take these equations and you will draw circuit. So the equation right down here, that is the equation for d one drawn in the circuit. So this here corresponds to that circuit up here. Here we have the 0 and then y is right, that the output here. Now notice that y is a function of the current state and also of the input. So this is where you see that merely aspect of it, that input plays a role in how output y is produced. The other important thing to realize is that each of these, so here's my bid 0, here's my bit one. Notice that I have Q1 prime and I have Q0 prime right over here. So in this example, for example, q 0 would be connected directly back to the input. Here one would also be correct, connected directly to the input. Same thing would happen with the primes. So Q0 prime over here would go back and they would be connected to this input over here. And Q1 prime, which I'm having a little trouble with here, Q1 prime would go and it would be connected right over here to that input. Okay? And then lastly, we have these two x primes. I would certainly connect them together and have just a single inverter that feeds both from Annex. So this would be an example of what the circuit might look like for our Mealy design of Mars life detector. Why is Q prime connected to both Q1 and Q2 weren't frame. So I have these two different bits. The first bit, maybe I get a different color. This first one is our q 0, the second one is a q one. So these are two different bits at them story. So the bottom q prime is in fact Q1 prime. The top Q prime is in fact Q0 prime. Okay? What I'm saying, yeah, Sara us and here is ones, and this is D0 and D1. Okay. Okay. I was just asking because the why for Q1 on the bottom one is connected as well to Q1 prime. I might have messed up. Oh, yeah, it looks like I messed up. So here I'll draw this again. There. Okay. Okay. Okay. Sorry. Noise. I think what happened was I had drawn it correctly, but then I draw Q1 prime wire out and it connected when I was drawing, adding ed. Okay. Okay, thank you. Eggs. So everybody okay, on this, this basically walk you through a complete design problem, which is very similar to what you got on your homework. You're going to have to go from a word problem to design a state diagram, state table, excitation table, and then a circuit for I think, most significant bit only, but you could design also all the other bits. Okay? But I have no other questions. Then you get to do the more finite state machine life recognizer. So they can look at this and see what you think. Which one of these is a Moore finite state machine. Now remember the more has output as a function of only the current state. That's the important key to remember here. Okay. I got 54 3210. And let me share results. Most of you like cancer B. I would tend to agree with all of you. Let's just look at where the initialize for second. So here, Part a is in fact correct. The problem is that it is a Mealy. So that is why for the question that as this would be incorrect, but otherwise it'd functionality wise, it is correct, it will recognize the correct function b. Let's analyze how it works. So it starts from originals initial state as 0 into a child with this a 0. If it gets a one and just stays there because that's not the pattern it's interested in. If it gets a 0, it goes to state 0 in which it has recognized that at least 10. Now if it gets another 0, it goes to state S2. Now it knows that there have been two zeros. So far it outputs a 0 from state this one, it will return to state 0 if it gets a one, because that doesn't help it get its pattern recognized. Now repeated S2 and it keeps getting zeros. It's fine because having 5-6 zeros doesn't matter as long as the last two are 0. And if now with the last two zeros being 0, it gets a one. It recognizes the pattern. So it outputs a one. Once it's in this state where it's recognized the one. If it gets a 0, it's going to go to a state in which it has one leading 0. If it gets a one, it's going to go to a state where it has to start over because one is really not helpful. A and B are both not correct and b is not true because a is true. Okay, and let's move on to the next question. So here my pole is going to actually ask you, how do we get a record? How did we implement C2 in a Moore state machine? So they can look at the C2 block. What is needed to implement this block for more of Mars life pattern recognizer. And I'm gonna give you a half a minute because we're a little bit short on time. So let's do 543210. So let me share results. Most people like D. Let's take a look and see what actually is the case. So here I have a situation in which I'm looking at C2. So proceed to my input. And only input is the current state. Hey, says current input, so that's definitely not true. B also says current, but that's definitely not true. And in fact, c says current state, which is happy and it produces the current thoughts, but which is true, that is current output does not produce the next state. So this is why C is not correct. The says current state than current output. So D is correct and is not correct because D is correct. Now notice that for C one, we have current state. We have input. Sorry, this is the current state and what we produce is the next state only. Okay? Now I'd like to step you through the design problem of how we would implement the Mars Rover or life recognizer using a more versions of it. And what we will do is we would first move from the state diagram to state table. And here we are with right, for each state, what state does it transition to and what is the output given a particular input. Ok? So we will end up at a state table which would have next state and output specified for different inputs. Then we do state assignment. For state assignment, for example, I would stay, but that's 0 is a 00, S1 is 01, and so on. And then all I do is I replace the names as 0, S1 and S2. And the white keeps doing this with the particular number. So wherever as always, I will replace it with this pattern 00, like so. Wherever S1 is, again, replace it with the pattern. And then that gives me the excitation table. Now I just rearranged the excitation table to get my current state and input separated from next state and output. And to also get all patterns represented. Once I have this, I can get to the point where I can create my K maps. And I'll have one K Map for D1, one for D 01 for y. Now in K Maps, I can just start combining values, you know, so this would be an example of what I might do. Notice here for why, what happens that I have here Q1, Q2 is 0 and x. When I combine these two, once I end up implementing y as Q1, Q2 is 0. Notice that it's a function of only the current state. X does not play any role. So he doesn't care about dx. So now that I've done these K maps and hopefully you've gotten the equations. You could actually draw your circuit. So what would happen is to create the next state. You'd put some logic in here. You would obviously have both Q0 and Q1, and probably also the primes going in so that you can generate logic for the next state. But notice that your y, y will be generated using only the current state. There is no x input here. Ok? So that is what I meant by this kind of model where the output is represented only by using a current state. That's what makes this a Moore FSM. Ok. Any questions on this? This is where I'm going to stop for today. Ok. Any questions on anything else of covered today or anything related to homework? Now, if there are no questions, I wanna thank you all for your attention and I look forward to seeing you next week. Thank you very much and enjoy your day. Bye.