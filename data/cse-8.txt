Okay let's get started um. Anybody have any questions or comments, before we start. Did you all see that. RON will Ronald made a. sort of like a not like a practice test, but it was a a way that you can. Take a grade scope online assignment just to kind of see what it's like So if you wanted to see what it's like before we actually did the real thing. Sorry. All right, let's go so today we're going to talk about ranking. One of my favorite. topics that we do in this class is. is really a powerful. idea and. i'm going to try to. revisit it when we do probability, and maybe you'll see kind of where it comes in, to play and why it's important and. Why it's Nice. But in order to motivate it we're going to what are we doing example of different ways to encode the same data okay so. i'm going to talk about a particular type of data and we're going to try to figure out what's the best way to encode it what's the best way to store it and then we're going to get to down to something called the theoretically optimal encoding. And that involves ranking and and ranking fixed density binary strings okay So what is this same data we're going to play a game called Colonel blotto, this is a game that. that one of the Grad students play when I was a Grad student and it's it's not a game that's going to be. it's not a very hard game. But the strategy is a little. interesting if you think about it, and it can change depending on who you're playing with it is sort of more in the realm of game theory and we're not going to go into that part of the game. it's kind of like rock paper scissors yeah. The re there's a few reasons that I wanted to play the game one, because I think it does illuminate kind of. Ideas about discrete objects and mathematical objects. I think it's kind of interesting to see the results and it's sort of fun to to play around with this data. But the main reason that I want to talk about it is, I want to artificially make something important Okay, so if we kind of get into this game and we find it important than we're we're. You know, then it's important to figure out the best way to store the data because it's something that is important what's important in this world it's all kind of arbitrary right it kind of all depends on what you're into or what. What most people are into. Right, like some people in the chat who would have known that game stop would would you know shoot up the stock, you know the stock will shoot up. Why is it important, you know it's it's important because a bunch of people found it to be important and they you know they made it important, so it's kind of like that, with this example is Colonel blotto important no are we going to pretend like it is yeah. Okay, so to illustrate the different ways to encode the same object will use the example of Colonel blotto. How complicated are the encoding decoding algorithms and I want you to think about these. How many bits are required and here's kind of a question that we're going to be going back and forth, is it. Can you still kind of do appropriate logic and arithmetic on the encoded object, or is it necessary for you to decode it in order to do that kind of stuff and is that important to you, maybe it is maybe it's not. Okay, so Colonel blotto is an exercise in game theory, it can be modeled as a game where every player sets up how they would guard 10 labeled castles. With 100 indistinguishable nights a battle between two players consists of comparing the number of nights each player had for each castle. For each cancel the player with the higher number of nights wins that Castle the player who wins more castles wins the battle if they both win the same amount of castles then it's a time. Okay, so that's that's how it works, but let's see an example Okay, so we have the green player and the red player. So remember you're you're placing 100 indistinguishable nights into 10 castles sound familiar. So 100. indistinguishable Nice. And you're allowed to leave caps castles empty, if you want you're allowed to put all 100 nights into one Castle that's not a very good strategy, as you will you'll kind of figure out. Okay, so what you do each of the castles are numbered right 12345 up to it up to 10. And so, how do you battle these two people well you just compare their castles so. Green wins Castle 115 is bigger than eight so green wins Castle to 20 is bigger than six so green wins castles 313 is bigger than five they'll do like this, so read wins Castle five red wins Castle, four and five sign Castle six goes to breen seven. Eight goes to read. Nine goes to read and then there's a tie so nobody wins that castle. Okay, so the score is five to four. Excuse me so greenwood when. Okay, if you look on the outside, there is a Google form that you can fill out if you play. You will earn. One review quiz point. If you're the top five you will win an additional review quiz point. And if you a successfully encode your arrangement you'll get another review quiz point. Okay it's not supposed to be something that's that's a it's supposed to be an optional game you don't have to play if you don't want to when I post the scores i'll post them completely anonymously. Only I will have the data and i'll give you your review quiz points and stuff anonymously so don't worry about that. was just kind of like it's more of like an experiment and to see kind of what kind of strategies you all come up with, because you know certain strategies work for certain classes and different. yeah okay any questions about that. it's optional. And we'll play one more time after right before the the. The the arrangements are do Monday night. Okay, so get them in before then, and then i'll post the scores, the following Friday will probably play one more time after the second midterm too so maybe you'll learn from. kind of the way it went but maybe everybody else will also learn from how it went so it's kind of like this thing, where you sort of try to guess what your opponent, is going to do, but their opponents trying to guess what you're going to do so it's this whole kind of thing. I guess the way it works is i'm going to I have a I have a script that will. That will pit everybody against everybody else, and then whoever wins the most battles wins the whole thing okay um so Colonel blah. You are all going or not you are all but whoever wants to play is going to give me their arrangement and the end the format of their arrangement is going to come in this. Google form i'm going to download it into a spreadsheet and that's the format that i'm going to use is that the most efficient way to store it is there a way to crunch down the number of bits per arrangement down even farther that's kind of what we're going to do today. Okay, each night arrangement consists of an arrangement of 10 100 indistinguishable nice into 10 label castles let's suppose there's 150 students in the class and. Everybody plays how much memory is needed to uniquely identify each of the night arrangements Okay, based on that let's say that my computer is this like full of stuff and I only have one kilobyte of memory left, is it possible to store all 159. In that one kilobyte. Anybody say no. Anybody say depends, how you store it anybody say it's impossible, so what we're going to talk about. Okay, so version one. Maybe I guess version zero would be just keep it in the csv and store it that way. I didn't do any calculations on that, but. I don't know exactly how long that would be okay so version, one would be list of numbers, using ascii now for each. For each night. Right. You can store a two digit number using eight bit ascii right, so this example would be. I would make this 0500 attend a 520 10 and 00. So how many bits would this take. Well, you have 10 nights. Right two digits each. and eight. bits per digit. Okay, so each night arrangement is 160 and so, if I only have one kilobyte which is 8192 bits I can really only store if the one night arrangements in one kilobyte. Okay does anybody see any problems with this is this going to work for all of those different night arrangements are there any night arrangements that this. encoding can't handle. Right exactly so. This is bad for when. All 100. nights are in one castle. It does anybody have a way around this. minus one sure right, you can kind of since we're using ascii. Instead of 100 instead of instead of writing 100 you could write it as like hulu hundred or I don't know right just any to to character code for 100 and that would work right. delete the 100 because they're definitely going to lose sure sure. Use hex so that's what we're going to do next so. version one is 160 bits I can only hold 51 I have 150 students, so this is not good okay version. To. version two I thought I made this version 1.5. And yeah. So do I actually need. All eight bit ascii all i'm doing is encoding digits right so remember that remember B, C D is a. Is an encoding. Okay sorry is an encoding scheme where you encode every digit using only four bits each right. Do you need the entire ascii code, no. You only need four bits. per digit. Right, so this is going to take oh yeah I did call it 1.5 and let me change that here. So this was going to be four bits per digit. two. digits. Her. castle. 10 castles. So now, I have at bits per night i've cut it in half. Right, so now, I can hold twice as much. How do you handle. 100. How do you handle the case where there's 100. Okay, good us to have the forbidden things so that this there's only 10 of the 16 possible codes with using four bits, so there are six extra things that you could use right, so the forbidden. are going to be. 1010101111001101 and 1110 and 1111 do you only want to use one of them up, you should probably use to write because it's important to us, too, because if you. If they bury in my and then you're going to need the commas right, so you could say 100 is equal to I don't know 11111111 or something like that, and that will that will take care of it. Okay questions so everybody, we can we're able to do it. 10100000 could decode nicely to 100 that's true yeah that's that's probably better. Because 1010 is 10 and then 0000 is zero. yeah So these are the kind of things that I want you to start thinking about is you know what what makes it better what makes it worse, certainly, this is better than the ascii one right. In my opinion, you can hold twice as much, and you can still do arithmetic on your. Okay version two. Well, we know that each number is in between zero and 100. So we only need seven bits per number, where do I get that seven from. Everybody now okay good ceiling of log base to have 100. is equal to seven so in order to encode every single different number between zero and 107 bits is them minimal number of bits required you can't do it in six bits does anybody know why. Exactly. Because two tubes. To to the six is less than 100 so there's not enough binary strings of links six in order to give each different number a different sort of name or a different string so seven is the minimum amount, so instead, what we can do is each number. convert it into binary right we know how to do this from CSC 20 right the binary is just a different number system it's not any better or worse than decimal but it allows us to encode it into bits now, we can do seven bits. per console and 10 castles. Now we got 70 bits. and hundred and 17 in one kilobyte yes you're right I should do that that's probably better log base to have 101 because zero is a is a castle right. You could have zero so there's 101 different values that you could pick from. Okay, good so does anybody see any room for improvement here. there's going to be version 2.5 do we need to store all 10 numbers. Why do we have to take the ceiling. Because bits are what we're trying to do is figure out the minimum number of bits bits are kind of discrete objects so. You can't use a fractional bit in this scenario, and so my calculator. log base to have 101 is equal to see. is equal to around. 6.658, meaning that to raise the 6.658 is going to be equal exactly 201 but I can't use a fraction of a bit. And so i'm going to have to. round up to seven bits now there's going to be some extra data or some extra binary strings and i'm not going to use it all but that's okay. Okay yeah we can that's a good idea is to use kind of like a. Like a hash map. Hoffman encoding maybe. So all the versions, that I have here they're not all always you can do all these other kind of things to do, and some of them have different advantages okay so back to kind of let's try to go along this route that i've planned for us, do we need all 10 numbers, is it enough to. is, are you able to kind of work out the 10th number from the other ones. Exactly. If. right if if everybody's being honest and all giving like a valid night arrangement, which means that the sum of all the. nights is going to exactly equal 100, then I don't need to store this last value, I can figure out what it is by subtracting the sum of all the other castles from 100 this is going to be equal to 100 minus the sum of the first knowing castles. So that means I can take off that so how many bit it's Do I need now. store 130. i'm almost getting there. Does anybody think it's possible to store 150 in one kilobyte. Is there a way to crunch this down even farther. yeah there are some wasted bits you're right because, like you said there's some bit strings that we're not using so. Okay, so let's keep on going and see what else we can do, do you all remember fibonacci encoding remember what it did it was a variable length encoding that. encoded shorter or smaller numbers was shorter strings and and bigger numbers with longer strings but this seems like a great opportunity to use it, because. we're going to have probably a lot more smaller numbers and we are bigger numbers. I don't know if you all, are trying to working out the strategy in your head, but putting 50 or more nights into one Castle is probably not the best idea those nights will probably be more well suited to be spread out a little bit better right, so they there will probably be more nights. More smaller number nights which will require shorter streams okay so. In order to use fibonacci encoding you hear there's there's a little there's a little problem and the problem is that fibonacci encoding cannot encode zero but we're allowed to keep the castles empty one way around this is to just add one to everything. That way, you get rid of that zero. Okay, so. remember how fibonacci encoding works every integer. Is. A unique some. nonconsecutive fibonacci numbers. For example, 16 is equal to three plus 13 so the code for 16 is going to be 001001 right that's why I haven't here 001001, then you put a one like that that sort of represents the comma or the break too, so you know to start reading the next number. Over the next number is also 00001001 and then break and then we have 0000001 that is for 21 because 21 is actually equal to a fibonacci number itself right. 00001. yeah if. You want to have like a an encoding. A reliable. encoding scheme and so um. yeah when I asked you to write the fibonacci encoding I want you to add one to everything, even if there are no zeros because I, because then, I still want you to. I want everything to be the same, I want it to be like a fixed encoding algorithm. encoding decoding. Okay, so um This is great now, this is a variable length encoding so I can't do the same type of calculation, I did before, where I say every Castle is going to have X number of bits Therefore, the whole thing is going to be a certain number. For example, if I put. If I put 10 in each Castle, this requires 60 bits and the reason is because. 11 right because you're going to add one to each Castle 11 requires 12345 bits. Five kind of number bits and then one each one includes one more bit for like the sort of comma or the break so each one of those 10s requires six bits you get 60. thing in the middle. Okay, I think this is probably the maximum number. And the reason is because 12 plus one is 1313 is kind of the next fibonacci number, and you have the bunch of them I don't know, maybe as a challenge. The challenge. Is. find a night arrangement. That requires. More than 65 bits. Okay, so I think that's the maximum number, certainly, you know it's some bound right because I could find something that. That takes 65 bits now, I think this is the minimum number, if you put all 100 into one Castle this only requires 29 bits so there's a big range of these things. Since this is a variable encoding you save a lot of space, if you have a lot of small numbers experimentally, I have found that using a random Colonel blotto examples kind of random night assignments each integer uses, on average, around 5.5 bits. So if we can store each night arrangement using roughly 55 bits or we could use the same trick that we did before and ignore the last castle. And then we only need around 50 bits. what's but is that what it is what's 5.5 times 940 9.5 yeah. yeah I did encode all 10 numbers, I did for this example, but but yes, you can use that same trick and take out the last castle. And just do nine and then you're you only need around 50 bits per castle. So this is great right, because now, I can store all 150 students in one kilobyte. Is anybody bothered by the fact that if everybody gives me this. This. This 65 bit. arrangement, then I can't store all 150 in there right, so this is like right on the cusp write it in general or on average, you probably will be able to, but there is a chance that you won't based on kind of the the variable nature. Oh ah. let's see. Sure, omit the last Castle i'll make that up a note on the. On the thing on the Google form. Okay, so is anybody bothered by that. This is um this is on average. right but worst case scenario. Is that 65 bits. arrangement. That means that you can only store. 65 you can only store 126. Any questions or comments you kind of understand the problem here, and the this is really good if you compare it to all the other things we've done, but there is this very, very, very small chance that you're going to need a lot of bits. Well, oh no wait, so I guess. Wait a minute did they do this right. Oh, I guess you can omit one of them right. Okay well. Either way, you have this variable length. Okay, so. Another version stars and bars, this is kind of what we talked about last week it's exactly the same scenario right, you have a bunch of nights you put them in castles so. We have 100 nights we put it in. 10 castles so. How big is this stars and bars string and instead of stars and bars I use the zeros and ones, and remember kind of how this works is that the number of zeros you have. Before the one. is equal to the number of nights in the first Castle, and the number of zeros between the castles. Between the ones the first two ones is the number of nights and the second Castle, and so on. Okay, good, so this is going to be 109 bits. Right you basically have 100 zeros and you have nine ones and the nine ones are the. The barriers in between the castles. Okay, does this actually help. Now I have 109 bits I could have done it in 50 bits with fibonacci encoding. Right and now only one kilobyte can hold 75 seems like we're kind of going backwards. Right. Right, so we call that to count the number of ways, you could put 100 nights into 10 castles you compute this, which means. you're you're counting fixed length. binary strings. With 109 bits and exactly. Nine ones. Okay, this seems worse why well it's. Worse, because there's my workbench. US have been encoding on the multiple bit blocks of stars and bars, including. Maybe. Okay, what do we done so far let's kind of see what. What we've done right our sort of best reliable strategy was this version 2.5 which did 63 bits per Castle for arrangement and we get 430 now if we if we rely on. fibonacci encoding and we we sort of assume everybody's going to give us sort of randomized castles, then we can do it in 50 bits per arrangement, and we can fit all 150 right, so the question i'm going to ask you. Or the question that we're going to try to answer now is what is the lower bound, what is the limit of what is the lower bound of number of bits that are required to store every single night arrangement. Every single night arrangement, if you. You know if they all have to be different. Okay, good so considering all coatings the best is 60 is there a way to use fewer bits. What is the fewest number of bits theoretically needed right okay so somebody just said it right here so let's let's write that in. There are. 109 choose nine. Okay. So the fewest number of bits theoretically needed is log base to have the ceiling 109 choose nine which is equal to 42 Is this possible to accomplish this is certainly less than 50 right, this is a good sign. Oh sorry, yes, the ceiling should go outside the lock like that. Is it possible to accomplish indeed is that what your answer is indeed. Yes, it is possible to accomplish that's what we're gonna do yeah let's do it. Okay, so just to recap there 109 choose nine possible night arrangements, if we assign a different bit string to each arrangement, what is the minimum number of bits needed and it's 42, this is the fewest number of bits required to uniquely describe each possible. management, how do we accomplish this. How do you get 109 um yeah it's the stars and bars. it's 100 plus 10 minus one choose 10 minus one. Okay, so let's just talk about a theoretically optimal encoding so if you're trying to encode a set of and begin objects um different objects, each with their own unique binary string then. Then the theoretically optimal encoding is log base to have big in bits where the ceiling of that and we've already kind of talked about that, because if you use fewer bits there's not enough different bit strings to go around to name every day differently. Theoretically optimal encoding for length and binary strings with exactly K ones would use. The ceiling of log base to have and choose K bits per string just for an example. So how do you do it well, one way to do it is to. sort of build a dictionary okay and we're going to list out all the possible strings in a particular order, then in order to encode the string you look it up where it falls in that dictionary let's say it's the 190 eighth. bit string. Or the 190 eighth object using this particular ordering, then we would encode it with the number 190 so you encode based on where it falls in a list. How do you decode well. What if I want to know which one is the 190 fifth string I just take my dictionary and look up where where it is now, why does this actually give you the theoretically optimal encoding it's because. With this strategy right. You will. encode. Each. object. To a unique. number. from zero to. ceiling of log base to event. I guess N minus this thing minus one. So. The. it's really kind of just listing them out and looking at the position Okay, how much data would be needed to store this dictionary. Well let's look at this. let's look at how How would look if you listed out all the strings okay let's say that, instead of 100 nights and one in 10 castles let's kind of go to a. more manageable example where we have only five nights and five castles then each night arrangement can be represented as a fixed density binary string of length, what with exactly how many ones. Right nine with exactly, for once, or you just put zeros under these guys. And then you have the ones in between the castles and this corresponds to the. string 001011001 okay now Where does this string fall in the list of all of those strings. OK, so the theoretical optimal encoding for for this sort of play example with five castles five nights use this seven bits because nine choose for is 126 log base to have 126 is very close to seven. So to encode this particular example we find it in the dictionary and encode it as its position as a seven bit binary integer example find this is the, this is the example we had yeah 001011001 find this in the list. here's the list here's the dictionary since there's 126 I can I can list them all out and notice that I have numbered them from zero up to 125. So I just go through the list and try to find the. The exact binary string which was 100101100101011001. Trying to code it with the number 22 and if I want I can convert that 22 into a binary it's binary expansion, but. When we're talking about this type of this is called ranking we're talking about ranking we're just going to be talking about the position so in general will just be talking about the base 10 version of the position. Okay does anybody have any questions about how how this sort of works in general it's not it's not the most high tech. way to do it the organist we're going to talk about a little bit more and figure out more efficient ways rather than storing this big dictionary. Is there a way to get the position without having to look it up and what I want you to notice about this list is the order of the strings can anybody tell me, maybe in a few words, what is the rule, how are these streams ordered. Why is this one, the first string and this one, the last string is there any. Can anybody see any rule or any pattern or. Okay, good yeah so that they're. they're sorted by value right. right if you converted them to their binary number they they would. There be sorted like that right, this number here converted to whereas this one converts like I don't know. A few thousand. Right, which is the same as something called lexicon graphic ordering that's that's also what i'm looking for Mexico graphic ordering oh. Well we're going to talk about in a minute. This is also called dictionary ordering. it's it's good, because this is the way you find things in the dictionary. yeah alphabetical. Exactly okay so um how do I decode what if, if I had access to the dictionary, then I could tell you that my night arrangement is this seven bit string what is my night arrangement. that's to encode. look it up right. Okay now let's get let's get back to our original problem if I had to store each bit string of length 109 for each of the night arrangements for 100 nights and 10 castles how much memory with this need right you could kind of think about it, this long long scroll right where he. position is this or each each entry or position is this really, really long string and you store all the positions and you store all the strings it's way too much memory. 109 shoes nine is around 4 trillion. OK, and then each one of those each one. uses 109 bits. So you're talking about 400 trillion bits. Around 50 terabytes. So, in order to store that entire dictionary, you need around 50 terabytes, which is a lot of memory for this stupid problem. Okay, so is this I guess the The next thing we're going to do is answer the question. Is is this process even useful if I have to store such a big dictionary, and the answer is yeah what we can do is, we can simulate the dictionary using an algorithm. And we can basically figure out what position, a particular binary string is without having to look it up, and you can also go the other way, if I give you a position, you can use an algorithm to figure out what binary string is in that position. Okay, so this is called something called a ranking and unranked algorithm the ranking algorithm maps. The object to the position and unranked algorithm maps the position to the object so it's a one to one map it's a by injection between the numbers one through however many right ceiling a log base to have the number of objects by Jackson from that to the actual set of objects. Instead of listing all possibilities if we order the bid strings in a particular way, then we can use a ranking algorithm that converts a bit string to its position and unraveling algorithm that converts a position to the bloodstream. let's look at a possible way to order the fixed entity bit strings. lex order or lexical graphic ordering or dictionary ordering. As a way to order all fixed as the big strings you can compare to fixed nc big strings and he really tell which string comes before the other using this ordering it also allows you if you had the dictionary to find the bit string a lot better. So it's actually the same as like somebody said ordering by their binary values. Okay, good somebody has already kind of on the right track, you check whether the first bit is one if it is then add and minus one choose K otherwise keep the value zero then recursive we do it yeah. Okay, so. let's kind of build up to that so let's say that i'm want to write out all length five binary strings with exactly three ones listed in lexical graphic ordering Okay, so the first one is going to be, of course, 00111 okay so that's going to correspond to the position. of zero. The next one is 01011 that corresponds to 101101 that corresponds to 201110. That corresponds to three right. I need one right 10011 corresponds to 410101 corresponds to 510110 corresponds to 611001 corresponds to 711010 corresponds to eight and 11100 corresponds to nine okay that's all of them, there are 10 of them five choose three. And so it makes sense that we're able to. order them and map them to the numbers zero through nine now just like Kevin said I want you to notice something. Is that because we made it we we ordered them in Mexico graphic ordering or dictionary ordering that means all this start with bro. will come before all strings this with one. Now, using pascal's identity remember. We were able to kind of split all fixed as the binary strings based on if they start with zero or start with one how many of them start with zero well in this case it's four but that comes from for choose three. Right, because if you ignore the zero all you're doing is you're counting fixed density binary strings of length for with three ones. And how about this one. Well, this is for choose to. Oh God. But for choose three really is the number that we're we're after Why is this important well this allows you to distinguish. What the what the position is, or at least give your give like a range of what the position is based on that first bit so if the first bit is zero. Right first bit is zero. Then position. is strictly less than four choose three. And if the first bit is one. than the position. is greater than or equal to four choose three, and this is just a general rule, and just like Kevin said you basically. recursive Lee figure it out all the way to the end. So let's order is dictionary order so that means that if you like somebody said, if you replace all the zeros with a's and all the ones with bees, then what order would they come in the dictionary so. I have another thing here. So, for example, a bee bee bee that's number one that comes before be a be a be in the dictionary, so you just use that as the ordering. Alternatively, you can convert each one of these things to their whatever binary integer they correspond to an order them that way. it's kind of like if the ones, if the you know if the ones are kind of closer to the right that's going to be a smaller number if they're closer to the left that's going to be a bigger number, because you have bigger powers of two. Okay, so. let's order algorithm, we need to algorithms given specific and in K you map a string to the rank in a position to unranked. Okay, so. Kevin has a great strategy here to do a recursive algorithm i'm going to use kind of a shortcut but it turns out to be the same thing. Okay. So, in order to. are given a bit string s or fixed density. Of length and with exactly K ones, the way that you rank it is to write the numbers and minus one down to zero under each bit Okay, so in this case. In this example and is equal to nine K is equal to four. So right eight down to zero underneath each bit okay ready 8765321 and zero. that's the first step, the next step is right, the numbers K down to one under each one so K is equal to force I do 432 and sorry. Okay, then. All of the all the contacts have. Two numbers to act on top of each other, those turn in. parentheses around them. And you six choose four plus four choose three plus three choose two plus zero choose one. So six choose for is 15 plus four plus three plus if you ever have a smaller number choose a bigger number that's going to be zero. is equal to 22. isn't that the exact position that we associated with this already. So I didn't have to look it up, I could compute the position with mathematics, rather than having that big. list okay well, you can go into the list, and you can check your answer right. Good any questions about that. let's do a few more examples Okay, so how about this guy 11000156789 how about this guy. Right it's going to be as equal to nine K is equal to four. Alright, so I write down 876543210. And then you write all of the. The numbers for down to one underneath each one oops. 4321. Right and then you get all of these. binomial coefficients will come on. A choose four plus seven choose three. plus three choose to close one choose one. is equal to. Plus. 35. Oh that's kind of cool so, then we can go check our answer right 109. Is 1100010101100010. Okay, and if you're if you're interested in seeing you know the the first one in lexicographical order is going to be 123451111 does this work still works, because you have 876543210 and then, when you write the numbers 4321 you have. Three choose for plus to choose three plus one choose to us to choose one which is equal to zero Plus zero Plus zero Plus zero is equal to zero and it's positioned zero and then, on the other end of the spectrum. You have 11110000. And do the same thing 876543210 and then. 432 and one. So you have eight choose for a seven choose three plus six choose to plus five choose one. is equal to 70 plus 50 sorry plus 35 plus 15 plus five is equal to 125. Which is the last. last thing down there. Okay So hopefully you all kind of. are able to to rank these things, the process is not super hard. I say, maybe look at kevin's quote here. Sorry notice that this first guy starts with a one, and that means that. The position that means right SUP into all the strings that start with zero are before 70 and all the strings that start with one are after 70. Okay yeah I was lagging a bit. i'll just move on. Does anybody have any questions about this were you able to see all of this calculation. Okay, good all right So how do you unwrap given a position, how do you figure out the. string. This is a little bit more complicated, but we're going to use pascal's triangle to kind of help us figure it out so given a position, p. You need to know what kind of strings you're looking for right i'm looking for lengthened binary strings with K ones, if you don't if you don't have this information, the end of the K it's meaningless because I just give you a position of some list. Okay, so set, what do I need to do this so R equals to pete no I don't need to do that sorry. Because you're given a position P Okay, so our is this thing. So essentially what you do is you, the first thing to do is find the biggest X such that X choose K is less than equal to our, then you subtract off that binomial coefficient. And then you decrease K by one and you keep on going until you get down to the end. So let's look at how it works and we're going to use pascal's triangle, to help visualize what's going on okay so let's try to unranked. Where. is equal to nine K is equal to four. Oh no we're doing one on one okay sorry. Maybe you all, can do this as an exercise. How about one on one so remember K is equal to four so that's the first iteration so. here's pascal's triangle and remember. We have and choose K. Yes, so we have and going down and K going to the right. Okay, so when K is equal to four. That means we're going to look at this column, the fourth column. Okay, so what's the biggest number in this column. that's less than or equal to 101 70 okay 70. that's what we get and that's a choose for. He choose for is less than or equal to one one, so we get. Our now is equal to our minus eight choose for so we get 101 minus 70 which is 31 okay so that's the first iteration. So the second iteration now, we have our is equal to 31 and K is equal to three. So caves equal to three, so what is the largest. number. In this column. That. Less than or equal to 3120 okay good 20. So that's six choose three. To 31 so we get our is equal to our minus six choose three, which is equal to 31 minus 20 which is 11 okay so that's the second iteration. So now our is equal to 11 and K is equal to two just do the same thing. Here the next one is going to be 10. Five choose to. Or is equal to our minus five choose to. Which is equal to 11 minus 10 which is one. Are is equal to one K is equal to one. what's the. largest number choose one that is less than or equal to one is this one right. So one choose one is less than or equal to one. And then we get our is equal to our minus one choose one which is one minus so our is equal to zero. But we're kind of done now, so how is this going to help us. You take all of those squares that you did and pull them over to the side, so we have an eight. We have a six. We have a 10. Okay, so our string is going to have ones in those positions and zeros in all the other positions so let's write up the string here, so if I write the positions 876543210 then it's going to have positions in the eight the six the five and the one and zeros everywhere else. Okay, so it's going to correspond to this string here 101100010 So if I go to. where's my table. They go to the 101 101100010. little bit more involved, but. Really, the calculations shouldn't be too bad. Oh, here we go, we have 55 alright so let's try to do this one, a little bit more quickly. R equals 55 K is equal to four, so we have. 35 right so. Okay, so the next iteration we have ours equal to 20 K is equal to three. Okay, good we get a 20. Okay, so six choose three is equal to 20. So now. Are is equal to zero K is equal to two. Right so you're kind of finding the biggest number that gives you zero so that's going to be. 1200 K is one. that's going to be zero. should be zero choose to. choose to what am I doing one choose to. choose one. OK, so now, that means that ones are in position 016 and seven so 887-654-3210 we have positions at 111100000011000000011 is that right go back to the 55 01. Okay, good. Will we be given a table for any exam questions. you're going to be multi use calculators so. And note sheets and notes and stuff so you can just pull up this table from the slides. Okay So in conclusion. Very version five. The ranking and on ranking for each night arrangement and code it to 109 length but binary stream then rank that binary stream then store the binary expansion of the rank as a 42 bit integer can we do any better, no. Okay, so version five users 42 bits the best we can do, and now we can reliably hold 195 arrangements now questions to think about is this encoding. algorithm or this encoding scheme is it good or is it bad it's good in the sense that it shortens the string as far as you can go but it's bad because it takes a lot of work to to compress and to decompress right and it arguably I think kind of version. Was it version two is kind of the best because you can still do all of the calculations, you need without having to worry so much about encoding and decoding. So it's kind of the best of both worlds it all depends on what you want to do with this data, if you want to store it away. For years and years and years and don't want to look at it, you probably want to use that is because, to get it down to the smallest and then, when you need it, you can decode it, but if you're going to be using the day. Okay, how did I get that number again yeah so I guess classes done now, and we can i'll stick around for any follow up questions for the next 10 minutes or so. With a midterm include week for know the midterm is going to include up to and including. pigeonhole principles stars and bars all of that stuff. Can you prove that you can't do any better with the pigeonhole principle yes that's great, this is a great. Great application of pigeonhole principle. it's awesome. We talked about find duplicate, how do you. I didn't say anything so I was waiting for you to explain what that means fine duplicate. Right okay yeah so. You can kind of. Have a certain number and then tell how many times it occurs, but that's really only going to save space, if your night arrangements are very repetitive. Because, if you have a single different number for each Castle, then you can't save any space. Okay, other than that see you all, I guess, tomorrow, we have the exam so be ready for that and we'll send some instructions over pizza.