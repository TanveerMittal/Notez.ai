Alright start the recording. ready go okay. Does anybody have any questions or comments the homework was a the deadline was extended. deadline for homework five extended. Until tonight. This will hopefully mitigate some of the. problems due to the extreme weather and a lot of the parts of the country, especially Texas, but I imagine that I don't know if you're in Texas, you might not be here. In the. In the class but yeah it's crazy down there, and my brother lives there and he's just saying that things are wild you never seen it like that, before he's been there for 15 years and it's never been this cold so. Any other questions or comments. Alright let's continue, then, so I forgot to finish writing all the learning goals but that's okay we're gonna look at graph search, which is. it's kind of like the the High Level version. High Level version. of many common. graph. dfs bfs it's more like kind of the structure of them, the scaffolding, that we can we can we can look at the graph search algorithm and then maybe. make a few different changes here and there and then i'll kind of give us dfs here and make it different shades they'll give you bfs make a different change i'll give you dykstra so. it's often nice to design algorithms in this way, where you kind of design more like a general idea of how the algorithm is going to work and then you. incrementally kind of get more and more and more specific until you're down to like a pseudo code which you can actually. Implement and you can change that into whatever programming language you want, but what we're going to be looking at graph search is not really a pseudo code it's more of like a. Call it like a mid level. implementation level something like that okay we're gonna we're going to apply. graph search. To a problem. And this problem that we're going to look at the first time you see it, you may not think to use graph theory, you may not think to use graphs and you certainly don't have to use graphs to solve it, but. it's a it's an example of where graphs are useful in solving problems okay so i'm going to start with what we ended with so just to kind of reiterate what we talked about. A walk is a route from one vertex to another. So the kind of the the main quality of walks is that you can. You can. repeat. vertices. A path, I know, sorry, you can know you can repeat edges. A path is a walk that doesn't repeat edges right a simple path is a path that doesn't repeat vertices so you kind of have these different things, depending on what you can repeat them when you can't. A circuit is a path that starts and ends at the same vertex so you can you can repeat vertices. vertices. And a cycle is a circuit, that does not repeat any vertices so it's kind of like a. Simple. circuit. OK, so those are some things we already talked about him we'd already talked about the complete graph but wanted to to show it to you again usually it's denoted as case of N, where and, as a number of vertices and. Here are the first 12 complete graphs now. Certainly K one K two K three they all have one, two and three vertices, but what is this number here does anybody know. Okay, good so that's the number of edges and does anybody know how to compute the number of edges. triangular numbers okay. Okay, so they're triangular numbers. They are computed as n times N minus one over to does anybody know why does anybody know why there's there's that many edges. Okay, so there's kind of a few different ways, you can argue this right one, is that. and choose to. The number of edges and choose to because every pair of edges is connected by an edge that's the definition is such that there is an undirected edge between any two vertices so the number of edges is equal to the number of on ordered pairs. Because. Each edge. Is. Connecting. or let's say because an edge is connecting each pair. Of vertices. And there are. and choose two pairs. Oh God hate it when that Okay, and then the other way is each verte each vertex can connect to and minus one right. Each. Of n vertices. can connect. To N minus one other vertices. Then divide by two. By the handshake llama. Okay, good yeah so that's that now we have the graph K and bar, which is the empty graph or the edge of this graph it's a graph on n vertices that has no edges so. This would be. K five bar and now the reason that we have that it looks like that right K five is the complete graph okay five bar this that bar means the compliment, so the compliment graph. Is. The compliment of some graph you basically if there is an edge between two vertices you take away that edge and if there's not an edge between two vertices, then you put an edge. And so you get these two things so that the complete graph and the edge of this graph are always compliments right. Things called by party graphs a graph with two sets of vertices V1 and V2 such that no two vertices in the same set are connected by an edge, so all edges have to cross over from one set to another. And these these could be directed or undirected kind of depends on the problem you're doing. They are really useful when you're talking about two different kinds of things and you wanted to make a crap out of them, like, for example. You know group, one could be like a group of students. And group two could be a set of classes. And there's an edge from a student to a class if that student is taking that class right So if you never going to have a class taking a class or a student taking a student so it's. it's a it's natural to make it by party graph now, why do we name it and why do we care about it is because, once you know it's a by party graph. Then you get all of these other properties out of it and that's kind of a general thing that happens with graph theory is that. You say Oh, I can make graph out of this, what is the use of doing that is because you inherit all of these properties from graph theory to the problem just by describing it as a graph. Alright, a tree there's two different trees that we're gonna be looking at in this class. there's a whole bunch of different kinds of trees, but. They kind of mostly each fall into one of these two categories one is an undirected tree. it's a tree it's an undirected connected graph with no cycles, and so it looks something like that. Right, if I had an edge right there it wouldn't be a tree anymore right. And it's got to be connected, so if I had another vertex over here that's not a that's not a tree anymore, because it has to connect to components we'll talk about that later. So that's undirected. The only rule is that you can't you don't have a cycle, a directed tree sometimes called a rooted tree is a directed graph with the property that every vertex has exactly one edge pointing to it, except for the route which has zero this is kind of like the more. Common structural. type of tree that we use in computer science. If you're talking about a binary tree you're usually talking about a rooted binary tree. Like a lot of like the you know. Data structures that we use. binary search tree. You know, even the huffman tree is a rooted tree right because they're that one vertex at the top, is very special right you you start all of your codes from that vertex so. it's basically like if you can kind of identify one of the vertices to be very special to kind of be at the top, to be sort of the root of them all, then it's a rooted tree. Okay, so let's talk about graph reach ability, what is this problem that we're trying to do we're given a graph G and start vertex S, we want to produce a list of all vertices w reachable from ass by a directed path in G, I guess, I should say or. A path. In G right if it's undirected graph. And what i'm doing here is basically just saying that the same algorithm will work on directed graphs and undirected graphs. Okay, so. Like I said before, we're going to kind of describe this in a high level, and one of the one of the. consequences of that or one of the properties of a high level description is that, instead of using kind of low level data structures. we're going to mainly be using math language and math objects so we're going to be using sets we're going to be using graphs and we're going to be talking about those sets and graphs. kind of freely without getting bogged down into how we're actually going to implement it will look at that a little bit later, but for now we just kind of want to get the main concept going and get that working OK, so the main concept is that we have three sets X F and you. X is stands for explored, which basically means that you have you have considered that vertex and you've looked at all of its neighbors a frontier. Is all the vertices that you've already reached, but you haven't yet explored you haven't looked at their neighbors but you know you can get there, and then you is going to be unreachable. Okay, so here is the pseudo code or the. Mid level. Mid level. pseudo code. Okay, so we're going to initialize these sets. X is going to start out is empty we before we start we haven't explored anything F is going to start out as just the single vertex s because that's where we want to start from we want everything to kind of come from there. And then you is going to be everything else. Okay, so we we start this while loop. While F is not empty or you just keep on going until F empties out pick a w in F. Okay, so. um. How. You choose. To do this. will determine. Which type. The type of graph. algorithm. will determine which type of graph algorithm. This is. Okay What do I mean by that if F is a stack. That will give you dfs and if F is a cue. That will be give you bfs. Okay. So why don't we. Why don't we choose which one to do a stack or Q why don't we why don't we have like a more specific way to pick the vertex in F right it'll certainly make translating this into a. Programming language, a lot easier, the reason we don't do it right now is because we're going to try to prove the correctness of this algorithm and this algorithm doesn't care in which order you pick the vertices from F. And so the the strength of it doing it that way is that once you've proven it correct for any order of picking the vertices, then you can put whatever order specific order you want on there, and the correctness will stay. Okay, so, then what happens is that for every outgoing neighbor right we've picked this w and every outgoing neighbor why of w right for every edge why. If why hasn't been explored, or in the frontier, yet you move why from you to F basically kind of put it kind of on deck right it's kind of next up to be explored and you do that, for all of us neighbors. If any of w's neighbors have already been explored or already been in the frontier, then you just don't do anything and I guess that's kind of the power of this algorithm is that it keeps track of what you've seen before, so that you don't meander around this graph forever. Okay, then you move w from F to X, meaning that w has been kind of. And then return X right, the only way to get out of that loop is if F becomes empty right so once F is empty. All the vertices that you can reach should be in X. Okay, I have like a little animation here. I think I sort of messed it up by the end, but I think, at least for the first few iterations it looks pretty good. Okay, so this is how we start. This is the initialization. X is empty basically we haven't explored anybody yet we're going to start at vertex a so we put that in F and then you is all the rest of them. Okay, so now we pick a vertex from F so we're going to pick a there's really no choice here. And we look at all of a's neighbors so we look at be first. We look at all these outgoing neighbors so we look at be first be is in you right he has not been explored, or in the frontier, so we move be from you to F, what else is there there's he. He from you to F now he does not have any more outgoing neighbors so we're done with that loop and we move a tax, and that means that next time we see a we're just going to ignore them because we've already explored from him. Okay, so, then we pick another vertex in this case, we could pick any of them right we haven't really decided a general rule, but i'm going to pick be. Okay, so let's look at these neighbors well there's see see hasn't been. considered yet so put it in F there's I hasn't been considered yet so put in an F and I think that's it and so put be in X, meaning that we're done with it. Okay, and the next one is i'm going to do, he so I guess i'm doing kind of like a. queue. Right alright. Well, he doesn't have any outgoing neighbors so we just put it in X Willy nilly. OK. Next, one is see. Okay, so see has one outgoing neighbor which is de de hasn't been explored yet so put it in F. And then we're done with see right. All right now, when we look at D, we look at its outgoing neighbors, it has to right we look at a but a has no sorry wait, what are we doing I sorry I. forgot which direction we're doing Okay, so I have one outgoing neighbor no, it has to sorry okay so first looks at he now he has already been explored, so you just do nothing, and then it looks at F. F has not, so you put it in. Okay we're done with that all right now we go to D. A has already being sports you do nothing he has already been explored, so you do nothing, and you move D to X. I think this is where. Things kind of get weird, but I hope that you kind of. understand the idea of what's going on and by the end. We will have. visited every vertex. So, the last thing I guess I can just kind of animate it here, the last thing is that you consider F right F is the next vertex and you put F up here. Because. All of its neighbors have already been discovered. And notice that G and H they're left in you right because I can't get to them from a, and so this is really what the algorithm should output is this set of vertices, these are all the vertices that I can get to from a. Okay, any questions or comments. Okay here's a another, this is not really an animation but it's like a sequence of. sequence of steps. That you can kind of look at on your own you want. Right and you kind of get this. You keep track of these sets fx in you right and then, and then we say that if we reverse that edge from C to D then we're going to get more. More iterations we're going to be able to actually Oh, and we reverse the edge today. we're going to actually get all of them. Okay, so Moving on, we want to. want to be sure that this algorithm works, so we need to know what it's supposed to do it's supposed to return all the vertices that we can reach from the starting vertex does it actually do that. Well, in order to show that it that it. returns all the vertices is, we need to show two different things, and you can kind of think about these as like if, and only if directions basically like. If a vertex is reachable from ass then it isn't that, then it should show up in X and if a vertex is an x, then it should be reachable from s. So you need both directions, or else you know you could get some sort of like false positives or false negatives, so you want to be completely sure that. Everything in X is reachable and everything that's reasonable isn't hacks and it might take a minute to realize that those are really two different statements. Okay, so we need to do, basically two proofs and producer are very different in flavor the first proof we're going to do is a loop and variant proof that's going to show that every vertex. That. Is in X or F is reachable from s it's every vertex that falls into X makes its way into X is reachable and we're going to do it using a loop and variant OK. So the base case. Before any of the iterations of the while loop X is empty and fss and so trivially all the vertices of X and F are reachable from ass because really together it's only just as. induction step suppose that after the teeth iteration every element of X or F is reachable from sd n G what happens in the T plus first iteration what happens in that next iteration. Well let's kind of just take a look at the body of the loop, the first thing we do is we pick a vertex in F. Right let's call this for a text w Okay, so we picked w what do we know about w is that we know that it is reachable from s right. w from F. By induction hypothesis. w is reachable. From ass. Then, what do we do. We move all the neighbors of w to af. I guess i'd say add. unexplored. neighbors of w to F. And then move w from F to X so since I know w is reachable from ass therefore. All of w's neighbors. Are reachable. From S, and the reason behind that is because, if I have a path from St w then, along with the the edge to his neighbor there's a path from St Louis neighbor. And so you're moving all those neighbors into F, you know all the neighbors that you moved into F are now reachable from ass you know that for sure, and then you move w from F to X w was reachable from as before, and so it must be reachable from us, after so after that iteration. The claim remains true, the new environment remains true you're really only adding vertices into F of X if you're sure that there's a path there. Okay, so. Now, remember when we did these looping variant proofs that you need to after you prove it to be true, you need to use the loop and variant to prove that the algorithm is true. or claim you're going to claim something about the algorithm here we're going to say after the final iteration you output X. Which by the claim only contains vertices that are reachable from us so that's good that's one direction of our proof everything in X is reachable good we never got anything that's unreachable that went into X. OK, so now let's flip it around and and do the opposite direction anybody have any questions about the loop invariant. Okay, so we've done this thing that's good now every reachable vertex is in X, by the end of the algorithm remember we're kind of building this X up as we go. Right, and so we want to show that, at the end of the algorithm we've gotten everything. We can't really we can't really use a looping variant here because we're talking about something that about the end of the algorithm the property of the kind of sets at the end so we're going to use a proof by contradiction. Okay, so here's our goal to is that every reachable vertex is an x so let's use contradiction, I guess, I should say by and. Okay, so suppose some vertex is out there, that is reachable but somehow didn't make its way to X i'm going to show you that that's impossible. Okay, so soon towards a contradiction that some vertex a is reachable from ass but it's not in X by I should I should say, by the end of the algorithm. Excuse me. Okay, so if a is reachable from ass that means there's some path from sta. Right. And so I drew this path down the bottom now s is in X. By the end of the algorithm s has got to be an x right because s started an F and once you got you you, basically, I guess, I should say something like this each. vertex. In X came from F. Right this kind of like there's only one direction of the vertices to go they go from you. To F. Tax. Right you can't kind of you can't go back from X back to F you can't go back from F back to you, so the only way to get into X is by way of F and since S, the starting vertex started in F. In must have eventually got into X okay so s is an x. And a is not in X, this is by assumption. right by the contradiction assumption, so you started out in X and you ended out of X so at some point, you must kind of cross over the barrier of X. And let's say that that point is here, these two vertices from B to C that's the first time you kind of break through X so be as an x see is not an x. Okay, so here's going to be the problem is that since be is an x right. At some point B, so I guess, I should say, since. Be is in X at some point be must have been an F, this is the same kind of argument I was saying is that all vertices. In order to get into X, they have to kind of go through the set F. Then all of these neighbors are eventually put into F C is one of these neighbors right and so see will eventually get put into F and if see was put into F then see will eventually going to X, therefore, see as an exit the end of the algorithm and that's the contradiction. See will eventually be put into X which contradicts the fact that see is never. Okay questions or comments. Okay, so let's talk about the runtime How long does this thing take um well. We can start labeling these things right, but. it's kind of hard to understand how long these things take if we're just talking about mathematical objects, so we need to, we need to start making some choices about implementation. In order to get a handle on how long this takes okay. So how long does it take to pick w and F How long does it take to iterate over the neighbors of w. Okay, so what we're going to do is we're going to assume that G is stored as an adjacent see list and we talked about those last time and the nice thing about a Jason see list is that you can call up a vertex and have the all the list of its neighbors so in order to iterate through. For each outgoing neighbor This is just going to. iterate. Through. A Jason see list. Of w so you call the list of w it gets gives you all the neighbors and so you just kind of go through them one by one, and then you're done with that look. Okay, how do we, how do we handle these sets. With a little bit of thought. You can convince yourself that having actual sets or like lists or like some sort of container that's holding the vertices like like a list I guess. That is going to be. time consuming to deal with right, because if I need to check to see if a certain vertex is in a certain list i'm going to have to go through all the list until I find it so a more efficient way to do this is to keep an array that's indexed by the vertices. and The kind of the value of the array is going to be these characters X F, or you depending on. What set each vertex is in this way, if I want to know which which set is vertex be in all have to do is. call up the array at be right it's kind of like a hash map right you call the array of be and it gives you what sets in, and it also takes it also is efficient, to change the set if I want to move be from you to F, all I have to do is change the value of that array position. Okay, so this might be nice to kind of. see an example of so if. let's say you is equal to. Be D. g. F is equal to. See E. h. And X is equal to a. What am I missing here. I guess half, but I want to use African a B, C D i'll skip F G H I J let's go to J. it's kind of this kind of silly I guess but. Okay, so status. You can think about it as an array index by vertices right and the value of the status is going to be, which set they belong to, so a belongs to X and J belongs to X be belongs to you D belongs to you, and she belongs to you, and these ones all belong to. Alright, and so the reason that we do, that is because operations on this array are constant time. Okay, so. let's think about some of these key words right. move. takes constant time. Because you're just changing. A single. array value. What else takes constant time if y is not in X or F right, this is just checking this is just checking in or a value. And then move. that's the same as this year. Any questions or comments about this kind of going from a high level mid level kind of thing and we're kind of now starting to give it more specific. properties, and the reason is because we want to get a handle on how long do you expect this thing to do, how long do you expect this thing to take. Okay, so the last little bit. about this algorithm in the runtime is. How long does it take to pick w and F let's assume. F. Is a stack. So it takes. Constant time. To pick up to pop from a stack. Okay, so. let's go through this algorithm now let's start at the we're going to kind of do. A similar thing that we did with. With loop based algorithms and how to calculate the run time we're going to be a little bit careful and and keep a little bit more details than just thinking about the worst case scenario. Okay, so. let's start with how many times, does this while loop run. well. Because of this same argument, remember, I said that each vertex goes from you to F to X. Almost all the vertices start in you right and they go into F and the index right there's no way to get back to F from X there's only kind of like a one way street, and so, in the very worst case, all the vertices need to cast through F. So, in the worst case, this iterating at most once for each vertex so in the worst case. it'll be it'll iterate. The cardinality of V times. Any questions about that. Not This is like very, very important in the runtime it gives us a bound, it gives us a way to to make sure we're not doing more work than we need. Okay, we have we've already talked about how if F is a stack this is going to take constant time. And now we have an inner loop how many iterations is this inner loop going to go. This inner loop is going to iterate. degree of w times. right because it's just the degree of w is the number of neighbors that w has. Okay inside of here is a constant. let's call it see takes constant time to to check if y is in a set and then moving ally into a set that whole thing is going to take constant time. So it's called that constant see so that means that this entire for loop. Using kind of like the multiplication the product is going to take C times degree of w okay any questions about that any questions about why this inner loop is going to take some constant times the degree of w. OK moving moving w from F to access also constant, so what i'm gonna do is i'm going to here, let me give a different color let's do red we're going to do is i'm going to take these two constants. and call them see prime. Okay, now we have enough to kind of. calculate a a rough estimate on how many operations are we doing. So. Here is the summation. And remember that, in the worst case. iterate. Through. All vertices. Right so for all the vertices of V, how long is each iteration take it takes some constancy prime plus C times degree of w. Any questions about this summation where did this come from we're gonna we're going to talk about how to simplify it in a minute, but. Just kind of wanted to see if you. Are following. I don't know if i'm like losing you all here we're getting kind of more technical than we usually get so. Okay. So I guess i'll write it here i'll rewrite the summation. summation w saying I think i'm going to give myself another. slide to do it. Okay, so let us. calculate this thing. Okay, we can split up the summation. Okay okay So what is this first summation. See prime times V right exactly good. All right, what is the second summation. Okay, good remember, we talked about this last time, the sum of all the degrees is equal to two times the number of edges if you're talking about an undirected graph is equal to the number of edges if you're talking about a directed graph, so this is equal to to see he. This is for undirected. Or is equal to see you're talking about it, directed. Right in either case. You get that this is equal to big of the policy. Any questions about that this is called linear time. And the reason is because. You often think of graphs kind of the size of graphs by the number of vertices but really the the the total if you're talking about the total amount of information in a graph you're talking about the number of vertices plus the number of edges and so. If your algorithm grows with that complexity, then it's a linear in terms of all of that information. Okay questions or comments. Okay, so what are some consequences. i'm from this. Is faster than you would have thought yeah it's because we are we're keeping track right we're kind of keeping. we're bookkeeping all the vertices that we've seen before, so that you don't go back into them. Okay So what can we do with this. We get a graph and starting vertex and the output is the list of all vertices we can reach, so what kind of questions can we answer, of course, we can answer where can we get to from S, we can also start answering more general questions about the graph. Is the graph connected and we'll talk about what that means. And you can see why this is a great algorithm for that, because connected means that all of the vertices are reachable from each other, so, if I can reach every vertex from some starting vertex, then that means the graph must be connected. Is a certain edge of bridge we'll talk about what that means in maybe maybe next week. But it's basically a. bridge. In an undirected graph. Is an edge. That if removed. Will disconnect the graph. Okay, we can talk about if there are cycles in the graph and we kind of we can we might talk about that next week to, and then we can talk about the degree of each vertex and you could kind of use the graph search more as like a way to count a bunch of properties of the graph. And then, if we use a queue instead of a stack we get this thing called bfs which will actually compute the shortest distances from access to all the other vertices which is pretty cool that you kind of you can get that sort of for free just by changing up. What data structures you're using. Okay, so let's take a little intermission and watch a clip from one of my favorite movies. This link. I can just do this. copy link. here's an honest way to make yourself. Can you all see the movie. yeah Okay, so let me just give you a little background this movie is diehard with a vengeance and. it's kind of silly premise, but there's a. there's some guy who is blowing things up with bombs. And he gives these this guy's a detective and this other guys, just like a store owner, but they. You got to watch the movie to see what how they interact, but essentially what they need to do is solve this puzzle to disarm a bomb Okay, and this puzzle is going to be what we talked about for the next 20 minutes or so. All right. You see, the message, it has a proximity, second, so please. yeah I got it we're not gonna run. To john you see them a five gallon another St. john's with exactly four gallons of water and place it on the scale and the time I will stop must be precise. Last will result in termination if you're still alive in five minutes will play missing. I don't get it you got it no. It did jugs. Obviously we can't fill the three gallon jug with four gallons of water right, obviously I know there we go. We still the three gallon jug exactly to the top right okay now before that three gallons into the five gallon jug give me and she gently three gallons in the five gallon jug right right. now take the three gallon jug it's still a certain way Oh, he said exactly for 50 miles runners playing kids came to the park hey. You want to focus on the problem at hand. Okay pause video for work. Okay, did you get the problem. um I think that this YouTube video that I found is like a video for some other class to to solve this problem but um let's just see what happens when they solve it. We can't take it over there i'll just wait wait a second wait a second. I got I got exactly two gallons in here right right exactly one gallon of empty space right yeah full five gallons here right one gallon on the five hours in the day, we have exactly four gallon come on. Come on. Good good. girl. Okay, so now. let's go back to the slides. Okay, so this is actually a. A well known problem it's called tartaglia is pouring problem and. And at first at first look at the at the puzzle, it might not seem like you want to use graph theory at all, whereas the graph in this thing right there's no network or there's no nothing right you just pouring these things but. we're going to kind of build a sort of imaginary graph or build a graph out of the problem and try to use that to. To to gain some insight about what does a solution look like. Okay, so. The problem here is you well, I have a kind of a different problem but it's essentially the same. They had a five gallon jug in a three gallon jug and they had a fountain so. In my case, the fountain is the eight. Eight ounce Cup. And this basically all you're really going to need you're never going to need more than eight ounces in the problem anyway right, because that would fill both. Both of those smaller cups totally to the top, so we can talk about this as more of like a closed problem where we start with eight ounces in the big cup and we try to get four ounces in the middle cup that's kind of the same almost the same thing. So we want to have four ounces in I guess four ounces in the in the eight gallon cup and four ounces in the middle cup so rephrasing the problem as a graph problem. And whenever you do this, you need to describe what are the vertices here, so the vertices. are going to be i'm going to call them configurations. And we're going to call them l m s. And it's going to be the amount of liquid in each of the large, medium and small cups. Of. What is it what is it these these are coffee cups let's talk about coffee amount of coffee. In each Cup. Okay, an edge. There is an edge. From configuration one to configuration to if what so oftentimes the vertices are going to be some set that you define right some set of things in this case it's going to be configurations or basically triples of numbers. But the edge set usually isn't defined as a set it's more defined like, as a rule, basically saying that if you give me two vertices. I can tell you whether or not they're connected by an edge so, when will two vertices or two configurations be connected by an edge. Okay, good if you can make a valid poor if you. can make. A valid poor. See one to see. Okay, so this describes a graph and we can we can run a graph algorithm on it now kind of the funny thing about this problem so far is that we really don't know how big this graph is or what it looks like we really are only using the. You know the the the description of vertices. And the description of edges so. The problem now. Is is there a path. From. 800 to 440. So it's a problem about finding a path right, because every path in this graph is going to be a valid sequence of pores and every valid sequence of pores is going to be a path in the graph so we really have. mapped these two concepts together and they're essentially talking about the same thing, but the. You know, one of the benefits of doing it this way is now we can just run graph search on this graph Willy nilly and and just see if we get this. Okay. So this is kind of what we already wrote, but here is what is a valid poor so valid poor is going to be anything that either empties a cup completely. or fills a cup completely right because you need to know when to stop, and so you need to have one of those things happen to signal to you when to stop pouring because if you do like a partial poor it's not going to ever be you're not ever going to be sure. How much you've poured in. Okay, so we phrasing the problem using configurations, is there a path from 800 to 440. Now, how many different configurations are possible, how many vertices do you expect to have right. A clicker question for this one. Okay, four times six times nine which is. Four times six times nine which is 2016. Now, certainly that's like a good. upper bound right because, with a little bit of thought I guess you could at first, you could say infinitely many right. Because ounces are some measurement but with a little bit of thought and a little bit of argument you can say, well, I can only really have integer values. Four ounces because i'm only doing valid pores so really This is like the maximum amount that I need now, can I get to all of these vertices maybe maybe not. But you know if your computer can handle this amount of memory, then, then this will be fine, but if you're interested in kind of getting down to what are. What is there a way that we can decrease this number of vertices with a little bit more thought and a different argument. You can say that. The total amount. Of ounces doesn't change. right because remember we starting with eight ounces and we're pouring these cups into each other, whenever pouring them out that's not a valid poor, so the sum of L plus n plus s must be equal to eight. So a way to kind of think about how to get around this is to say. There are four, there are four possibilities for the small cup and there's six possibilities for the middle cup once we figure out what those possibilities are the rest of the water goes into the big Cup. So there is four times six equals 24 ways to fill. The small. And once you fill the small and medium, then the the big Cup is already kind of. accounted for. Right, so now there's 24 now, is it possible to achieve all of those 24 different configurations let's take a look. To almost be okay so here are the 24 different configurations that i've just counted. Right now, are there any of these configurations that are impossible. The answer is yeah possible in, and I should say white. Why are all of these red configurations impossible. Anybody know. unreachable by valid pores but why. Not emptying or filling right so each. reachable let's say. configuration. must have the property. That. At least. One Cup is empty. or. At least one cup is full. Right, because after a valid poor you've either emptied out the cup or have you filled the other cup and, for example, for this one right, you can see that. The large Cup is not empty or full the middle Cup is not empty or full and the small Cup is not empty or full full excuse me, and so there's no way that you could have gotten there. Alright, so remaining the remaining configurations. Are all the ones where you have at least one cup is empty, or at least one cup is full. And it turns out that you can get to all of them, but that, at least to me is not completely obvious just right from the start. And so that's what we have our graph algorithm for excuse me, is to show or to kind of verify that all of them are possible and, of course, which one is in there that we're really interested in is this one. Okay, so i've arranged all 16. Possible configurations here. we're going to start from this guy and we're trying to get here. So. In this is an example of where the graph search algorithm is really great for actually kind of building the graph as you go rather than starting with a graph and searching through it. So where can I get to from 800. Okay, I can get to. 503. And 350. Okay. Okay, so 800 started an F and then you move it to X and its neighbors are now in F now which neighbor do you choose next kind of depends on what type of data structure using let's say the next one, we choose is 503 so now 503 moves to F a certain moves to X. So we have both of these guys are in X and we have all three of these ones are in half. Right. Actually, in fact, we could have. We could have a edge back to 800. Right, but since 800 has already been explored we ignore that one okay. Okay, so, then, what do we have we have X X. F F and now, now we put 350 in X and we look at all of its neighbors which is this one here. 323 now it's actually possible to get to this one right and it's possible to get back to the original. But those have already been discovered so we're not going to consider them and that's kind of the way the algorithm works. Okay, which one, are we going to do next, is going to be 530 so we have X X X have F F, so far, and now we put 530 in X and we can get 2233, which is an F and what else can we do well, we can actually get back to the original. Right. Which is already been explored. We can actually get back to where we came from. And what else can we do. I think that's it. Then we can get to this new new one that we haven't explored yet. Okay, so that's good. Okay now now which one are we doing okay 323 so we have X X X, these are the ones that we've explored so far. And now we move three to three to X and we can get to six to zero, so we put that in half and let's see where else could we have gone here, we could have. poured all of the middle into the large there'll be 503 so we could have gone here, but that has already been discovered, we could have poured. The two into no that's full. We could have poured the little one into the middle one that's going to go back here right but that's already been discovered, so this is kind of the only new one. Okay, and then again we have X X X. squared yeah we did we explored that one you. know I haven't yet I still have. A now we're exploring this one in this is like, if you pour the little one into the middle one, then you get that guy so that's it. And there's other things that we could do right, we could pour. The Middle into the big and we get this. We could pour the small into the big and we can get. That right. And we can pour the. middle small the big into the middle and we can get this one again. let's just kind of keep on going through that that that a. lot more and we get we actually get the. The configuration that we were looking for. Okay, and so what does this mean it means. We found a way to get to all the configurations, including the one we were trying to get to and we can't get to any new configurations out of this set, because we would, if we could have done this algorithm would have found those paths. These are the 16 possible configurations and we found a way to divide the liquid in half. Okay, so. I guess the last little thing I want to say is that once we found it, you might wonder well How did we get there, and a nice way to do this is to kind of keep track of which edges, or which vertices came from which other vertices and so, if you do this, you can kind of build the path. That you've gotten. Right. So you got it from 800 to 350-350-2323 323-262-0602 and then to find 15221432440 so we did how many pores 1234567 pores. Okay, so that kind of brings us to the end of class today and i'll just stick around for a few more minutes to answer any follow up questions that you all have. So, possible to do this tree with the video we saw. You mean you mean there's path. i'm asking about the. The one in the video because they poured out water right so won't be possible, because the sun isn't as some of the gang isn't the same. you're putting the port poured water out basically into the fountain right, and they also got water from the fountain and so. The fountain is really kind of like the big Cup. Okay, I understand, thank you. All right, talk to you all next week, then. Have a nice weekend. Oh, we have a we have a exam next week I guess i'll. i'll post some practice problems for y'all this weekend to get started. See ya.