 Hello everybody, welcome back to the csc 140. The day is still beautiful, luckily for us, although it looks like clouds are starting to roll in, so it may in fact get some rain which will not be bad. So today we're going to go over logic minimization algorithm first to cover the basics of how actually computers minimize the logic functions for us. And then we're going to go into new material. We're going to talk about pass gates, Tri-state buffers, multiplexers, the multiplexers, decoders, encoders, anvil, and the others. Just to remind you that we have homework number two that's due this Thursday at midnight on grade scope. So let me get started. Since today we have a lot of stuff to cover. There's some definitions that I would like to discuss. First, for the two level simplification algorithm, we talked about what an implement this, it is a single element in an onset or don't care set, or any group of these elements that can be combined to form a sub cubed. Notice that this is in sum of products form. So you would be looking for logic once employee cat would be in product of sums. Okay? Prime applicant is the one that can be combined with another to form a larger sub cubes. So you can think about it as a max size implant. In product of sums version, they would be the maximum size implicate around the particular Zara. Essential. And this is really key. Prime applicant is if at the low covers an element in an onset. Now you can also have an essential implicate, in which case it would be in an element of the offset. And this, because it's essential, it will be in any possible cover of the onset. Notice that sometimes we can have more than one cover because we have multiple redundant prime implicates. So when we ran our two-level simplification algorithm, we have two parts to it. First, we want to grow applicants into the primes. Basically, you want to grow horizontally and vertically to make the biggest possible prime implicates. Secondly, you want to cover the onset with this few Prime applicants as possible. And this is very important because that means smaller circuit. And smaller circuit means faster and less power. So that's good news for everybody. So let's go off or an example that illustrates some of these terms. So in the top k map that we see, you can see that I have looked at every single logic one, and I tried to grow as big prime implicates as I can. So starting with the logic one on top, I can grow big column around it and I can also grow this little square around that. Now moving on down to the next logic one in the next row. You can see that here I can grow to, to sum surrounded. The logic one that's right next to it is already covered. There is nothing better that I can do. That's bigger because I already have the big square and I also have the two combination. The third logic one that's over here already is in the column and in a square. So I'm done with that one. The logic juan that's on the bottom left here is already covered vertically, but I can now include also the horizontal cover for it. And that pretty much finishes that logic one. The one that's over here, We can, in addition to the column, we can cover it using a square. And that pretty much gets done with all of the logic. Once, notice that all of the ones that I looked at, there is only one of them that's covered by just the single prime important. And that is this particular logic one. And that would be this particular prime important, which is why this is an essential prime important. So that the central prime, it will be in this minimum cover here. Now if I ask myself, what are some of the other ones that I would like to select? I want to look at the minimum possible number. So this is why with probably select this four, because that gives me a smaller circuit again. And that means that I have to select this too, because that is the only one that is left that's not covered. Okay? So this is how I would get to my minimum cover for this particular function. Then if computer algorithm are doing it, it would literally grow all of these prime implicates that they would select essential prime applicants. And then it would go and look and select the biggest size prime implicates There are left that provide it with the minimum cover. Now let's look at the second example. In this example, I already labelled bunch of prime implicates using the same method that I showed you in the above example. And now I discover that I in fact have four essential prime scares. One here is in another, because those are the only ones that cover those particular ones. And here's the last fourth one. So these four are all required in the minimum cover. Notice that this implement, this one is not needed at all because function is already covered, gotten. So let's formalize this. We want an algorithm for two level simplification for some of products. Now we can do the same thing with product of sums. The differences is that for product of sums, you would use an offset. Everything else remains the same. So I would start with the Karnaugh map will choose an element in the onset. We would then find maximal, this is key, maximal grouping of once and don't cares. Notice in a group and he has to have at least 11. It cannot be a grouping of just don't cares because don't care's we don't care about. And don't cares. Use appropriately if it helps you use it. If it doesn't LP, you don't use it. You want to consider top, bottom rows, left, right column, and any corners around the edges. This, the maximal size one will form prime and pluck. And you want to create a list of all of those prime applicants. So you repeat it until you get all of them. Okay? So you just keep going back until you're done. Once you're done, you then move on to and your visit ones in the K map. If it's product of sums, you would revisit zeros in the cave. And if it's covered by a single primate bucket, it's selected as essential and you put it in your final covering of the function. Okay? And then the last step is if there are any remaining ones, and if it's product of sums, then if there are any remaining zeros, then you select those to get the smallest number and biggest say's. Can I saw would select the culmination of four over a combination of two. If it gives me the smallest cover, we go. So that's it for the algorithm. Now let's go over this as an example. In this particular example, I would start with the following logic one. And in the algorithm I always go from top left corner. So I always start from this corner here. If I start from this logic one, I want to ask myself, what is the biggest prime implicate that can grow around it? Well, first I can grow this nice huge column vertically, which is wonderful. Secondly, I can grow a row right here, but not a whole row. I can just do a combination of two because of this logic 0 in here. And that's pretty much it. Those are the two essential prime implicates that I can create here. The first prime applicant is a prime be. The second one that I have. That's just the two sum is what is it? It's a prime, C prime and D prime. Okay? So those are those two. And here's what that would look like. Okay, the next piece that I'm going to look at is a logic one that's right here. So here, what can I grow? I can grow a combination of two right here that gives me one prime implicate. And this prime applicant is going to be a C prime D. And I can grow a square around here, which is going to give me B and D. Okay? So those are the two possible prime applicants. Then you can see that here in blue. So the next one I want to look at is this one right here. And now I can grow this vertical combination. That's pretty easy. I can also grow this combination around here. Okay? And the last piece I can do is dig around the edge. So there is a question, Does it matter which cell I use as the name of the prime applicant? So I'm not sure what you're asking, but let's go back to this example. I was just label like the prime applicant that's consists of these two particular ones using variables. And that is the only name that this prime implicate can have because that is represented by those particular two once. Same thing here. This one is represented as b, D because it represents the set of four ones, those are prime applicant. So there is another question for the red one. So going back to this particular picture, where the a prime, C prime, D prime, b prime applicant, even if there exists a bigger prime and a prime b. So both of these are prime implicates. We're not talking yet about essential prime and Perkins. So this here is one prime and book and this here is another prime important. One is the vertical prime and, but can maximum size the Androids. Maximal size horizontal. We don't know yet which of these two, if any, will make sense to select as the final cover? We will get to that in just a second. Okay, so let me get back to my three combinations that I found here. I'm not going to label all of them. I trust that you guys can figure that out. This green highlight shows you the three plans that we have just selected. So now when we look at this particular selection, we ask ourselves, what is the essential primes? And you can see now that there are two essential primes. There is one right here, because that is the only one that covers this logic. One. And there's one other over here because that one is the only one that covers this bottom-up logic one. So that means that these two I have to put in my cover. So these two are our central primes. And that is what I show on this next picture. Those are the two essential primes. Now, notice when they look at this, there is only one set of two ones that are not covered. So out of all of the other prime implicates, I'm only going to select these two because I don't need anything else to get my final cover. So this would be my minimum cover. So in this particular example, we went through the algorithm that selects all prime implicates, then selects the essential prime over here. Right? So these are the two essentials. And then finally identifies a minimum cover by adding the last prime implicate that was needed to cover all of the ones we got. Okay. I think you guys are ready for a little poll. So let's launch. I'll give you a minute. Please take a look and let me know which of these are the essential prime importance. And again, we're doing sum of products version. Okay, I'll give you a little bit more time. I see there are quite a few people that are not answered yet. So they go ten more seconds. 543210. And let's see, it's between a and D. So let's see who is right, it's exciting, but we have a little bit of a challenge. Okay, so let's look at this again. Remember that we are here selecting which ones are the essential prime implicate. In order to select the essential prime implicates, we have to find all prime implicates. So we're gonna start with this logic one. And we want to grow as big of a prime input can surround it, does we can. And the biggest finally can grow is this square. And this square can be represented as b, d. Now I move on to the next logic one, that would be this one. The biggest thing I can grow around it is this combination of two. And this here is a C prime D. Then I move down over here and I have this logic one, the biggest that I can grow around that is this particular prime applicant. And that is represented as whether this would be b, c. Oops, sorry. Yeah, so this is BC. The other one that we can do is a whole row over here. And that is represented the S, C, The Prime. Okay? And now we look at this logic one, the last one, and that one doesn't have anything to add. Now if all of these we ask ourselves, which are central primes? Essential primes are the ones which are the only ones that cover a particular logic one. So for example here, this logic one is only covered by this particular prime, mm. So that means that BD is an essential prime. Here is a logic one that's only covered by this one. So that means that AC prime the, is a essential prime. And lastly here is a logic one that's only covered by this row. So that means that this is also an essential prime. Notice that this is not an essential prime. It is a prime implicate, but not essential. Ok, so correct answer was d. So what makes prime an essential is that it is the only one that covers a particular logic one. And you can see, oops, sorry, going the wrong way. You can see that by looking at these logic once, this one, this one, and this one determined riches, an essential prime. So I have a question, if AB is not a prime important, AB is not even unimportant. This case. Prime applicant that make it easier to find minimum sum of products representation for a computer. It's an algorithm that we use. You can do the same thing by using essential prime implicates. In this case, you would be looking at zeros. So if I was doing that, I would maybe take this 0 and grow a big prime implicate around it, then this 0 would grow a big column around it. And then down here, these arrows, I would go grow a whole row. That would be an example. Question If two essential prime implicates can overlap a single spot on the K map. They can overlap. I don't know what you mean by single spot. But here is an example. Let me actually get the, get the different coerce. Whoops, I think I just used the wrong thing, but just the circuit. Let's see, I'll get an orange color. So here is one essential prime applicant, and here's another. They overlap and this point right here. And that is perfectly fine. Both are essential. But they're essential because this logic one and this logic one, they're the only ones that are covered. Okay? I'm gonna get moving to two and multilevel logic implementation. So here is an example of two logic functions, f and g. And I can draw their implementation by simply drawing logic gates like I would normally. So in case of G, I'm gonna draw two AND gates. One has a and b input, the other one has B and C input. In case of F, I have an inverter and I have a logic gate that has a and b as an input. Okay? And now I look at it and I realized that I actually have exactly the same gate replicated place. This doesn't make sense. So instead of replicating it twice and using up six transistors, in addition, what I do is I want to kill one of them and just connect the other to the output. So in this example, what happens is as I reduce the size of the circuit by one logic gate or by six transistors, which is actually quite a bit. But unfortunately does not come for free. Where the cost comes is that now I have more capacitance. So now I'm going to be connecting instead of inside the output of this AND gate is an inverter, right? Because prior gates to it is a NAND gate. So this is an example of where am I and this. And this now is going to be connected to two sets of gates. One set, which is going to have PMOS and NMOS connection. And another said that's also going to have a pMOS and nMOS connection. So this is going to result in four capacitors, two capacitors for the bottom gate, and two capacitors for the top gate. So now I have four times the capacitance. So this means that here, the total delay, whether I go from the PMOS or NMOS, is going to be r times four c instead of r times 2i. So my delay doubled. So that's the tradeoff. I have one I escaped but I got more delay. And sometimes we will choose to add extra gates instead in order to have less delay. Okay? So this is basically the key to these types of gates. You end up with more delay because you have four gates that you connect to. Two from here. So one P and one n, one p, one n, n one p and one, and from here, okay? Okay, moving on to multilevel logic. Now in this example, I have a single logic function x. Notice that these two representations are exactly the same. It's the same function. But in this representation, I have 1234567 input OR gate 1234567, and then a bunch off 3-input AND gates. So seven input gate is gonna have seven series transistors in the worst case, for a total up seven times our delay. That is huge delay. Right? This seminar is going to multiply to see. For delay, the three input gate is gonna have three R times to see the light. So this ends up with very slow. Instead implementation. Because of that large delay. It is CO2 level, because I half on one level it's all AND gates. The second level is a single OR gate. That's the second level. Now here I'm going to have a three level implementation. The first level is two OR gates. And this one will have resistance, max resistance of three. R. Here is by end gate. It's a 3-input AND gate. It has matched resistance of 3R as well because it has three inputs. And here the maximum resistances of 2R. So here I should have a lot faster delay still. Three R, three R, and two R. But now it's three layers. Generally we choose this kind of implementation because this implementation tends to be faster. So that is what we mean by multilevel logic. We mean simply that we have more than just drawables. Ok? Any questions on either that or the previous slide where we did multiple output gates. Ok, moving on, time to talk about some more exciting Gates, low variety and life is good in these are actually some of the most commonly use gates. Here is a transmission gate. Which is a really fascinating gate. It's used in a lot of different cases in the circuit. In this particular gate, I have one control input enable. This enable is connected to, oops, through the inverter to generate the enable not signal, which is right down here. This enable not signal is connected to the PMOS transistor. Up here, I have an n MOS transistor, OK? And this is really an interesting circuit. Let's for the time being, assume that a is input and B is output guy for just a second. And what I'm gonna do is I'm going to look at what happens when enable is equal to 0 versus when enable is equal to a logic one. So let's start with when enable is equal to a logic one. And I'm gonna put my transistors over here, nMOS and pMOS. Okay, so if enable is a logic one, enable not is going to be a logic 0. If enable is a logic one is n months on or off. So if I have a logic one here at the Nimbus and mosses on, how about beam us because PMOS is connected to enable not I have a logic 0 at the input of pMOS, pMOS on or off. It's also on. So that means that both of these transistors are passing, which means that we can connect a to B. So B will be equal to whatever a is. It's as if there is a little wire between a and B. Okay? Now let's look at the next example. Let's look at the situation in which enable is a logic 0. In this example, I'm going to use green color to make things a little more obvious. So if enable is a logic 0, enable not will be a logic one. If enable is 0, is n MOS on or off? It is off, correct? And if I'm a naval not there's a logic one is PMOS on or off. It is also off. We have this interesting situation and which I have, oops, sorry. Image I have to open switches. Here is a, and here is the pMOS switch, here is B. So I have open-circuit. This means that z is not kind of b is not connected to anything. So we can write z at the output, which is an open circuit. So now I have a circuit in which if enable is set to one, a is connected to b. If a table is set to 0, a and b are disconnected. So this connected or connect, sort of like a fancy switch. X0 is just a representation for an open circuit. It tells us that wire is dangling in the air with no voltage on it. There is no logic on it. Okay? So MOS we know is on when gate is equal to one, but n was Pacis once poorly. We talked about that. Pmos is on and gate is equal to 0, but it passes zeros poorly. This is why we put the two together because we end up with a better switch. This switch, which consists of PMOS and NMOS transistors. So the top transistor is n MOS. The bottom transistor, it is PMOS. And the two are connected. This is, this is may be fancier way of drawing it. We can dry as a box because it's just easier. It represents exactly the same thing. So these two representations are equivalent to each other. Ok? So these two transistors, either they are both on, given the way that enabled is connected, or they're both off. If they're both on, then it's like a wire between a and B. You have this first example. If they're both off, then it's sort of like you have an open switch between a and b. Ok? And, and both are odd, then it passes both zeros and ones. Well, this is why be like this as a fancy switch. So when enable is one, switch is on, when enable is 0, then switches off. When switches off, a is not connected to B. And the output B, you would have a logic value of Z, which represents just an open circuit. Okay? Okay, so we're moving on and talking about how do we deal with where do we use this pass gate? So one very common way to use pass gate is at the output of a tri-state buffer. So here's mine able, here's mine able not. And here is the final output y. And let me actually fix this on top. Here is the enable, okay? So now notice that winery have enabled set to 0. That means that y is an open circuit, so y will be equal to z. A in this case does not matter, but I'm Ray is it's not going to be connected to y. So effectively we have an open switch. Okay? The other possibility is if enable is a logic one right here, okay? In that case, y is equal to a. So if enable is a logic one, then we have a situation in which the two are connected. The switch is closed. So either switch is opened, our switch is closed. This is super useful when we want to connect whole bunch of different elements to the same bus. And we're going to assume that this is a bunch of wires in your computer, and normally this is 64-bit wire, set of wires. So in this case, we would want to control when a processor might write data to the bus so that memory can read data. Or May 1 be, data may be flowing from memory into the video. Decoder. Ok. This tri-state enables, allow you to control who gets to write to the bus at the same time. So that's why it is very, very useful to have any questions on this. Before I move on. Okay, I'm going to move on in another very useful place for the past gates. And that is in multiplexers multiplied series represented using this particular symbol. And this symbol, this is two to one mux. There is a selector switch. Selector switch determines which of the inputs is connected to output. If switch is equal to 0, the 0 will be connected to output. Ipswich is equal to one. Then D1 will be connected to output. And that can be represented using this very simple table here. So fs is equal to 0, y is equal to the 0. If S is equal to one, y is equal to d1. Now, we can also expand this into a truth table, the truth table, but simply represent all possible Wilders of these 0 and D1. And then we can take that and the truth table and put it into a K map. And this is a came up version of the truth table. Notice that here we have two central primes. These two are essential. There is also an additional prime, and it is this vertical prime, but it is not essential and it is in fact not needed in the minimum cover. This equation represents the actual minimum cover. And I can put that minimum will cover representation down below using this circuit. Notice of this circuits got lots and lots of transistors, right? Every one of these gates here is six transistors, and this is two transistors. So that's a very big design. I can instead use tri-state buffer. So if I want to design a multiplexer, in which case I will have two transistors here, because that's an inverter. And I would have, each of these buffers has four transistors because it consists of two inverters back to back. So the total design here is eight plus 210 transistors. Okay? Or I can design that using pass gates. Notice that here, select or a bar requires an inverter. So this and this. Connected to both. Oops, sorry, I connected the wrong way. This is connected to both of these elements here. And at this connected to the selector, a signal as well. So the total number of transistors is two for this inverter plus two each for each of the inputs. So this gives me total up six transistors for a two to one mux. So obviously, I would want to choose a six transistor version whenever possible. And this is the best implementation of two to one mux if you're not using any larger size buses. This version is used when i have larger buses. So if I have, for example, a 64-bit bus here and here, then I would want to use tri-state version because that allows me to control and to make signal much stronger. In all other cases, I would want to use the past gape version. Okay? Everybody, okay, so far. So selector, when you implement a multiplexer, selector will always need both itself and the complement. So you'll always have both it and the compliment represented, which means you're going to always need this inverter in there in order to actually design the multiplexer. All right, so let's look at larger size multiplexers. What we've been talking about so far is a 2-to-1 mux. And in this example, variable a actually controls and is a selector. The equation that represents the output z is right up here. It tells you if a is equal to 0, the output is connected to z. A is equal to one. Output, i1 is connected to Z. In four to one mux, we have controls a and b. Now we end up with all combinations of sum of product version of a and B that tell us whether I0, I1, I2, or I3 are connected to z. Same thing again happens when we do a21 mux. Notice that here it doesn't matter the order of variables. So in this example, a is the most significant bit. So if I have a combination 1-0-0, that combination would correspond to one times two to the second plus 0 times two to the first plus 0 times two to the 0, which is equal to four, which corresponds to this particular input being connected to the output. Ok? So that is how I do the mapping from the binary inputs here onto which of these output goes to the final output z. Any questions on this? Ok, let's now take a look how to implement logic using a multiplexer. So in this particular multiplexer, amusing input a as a selector, that means that I want to know whether a is equal to 0 versus where a is equal to one. In the first case, when a is equal to 0, output is always a logic 0. So that is what I write. And that's where I connected ground here or logic 0. Okay? Secondly, when a is equal to one, I noticed adult with y is equal to 01. This exactly equals what value b, s. So that is why I write that when a is one output Y is a b, and y connect B to the input of this multiplexer. So that is how I would represent this particular logic function using two to one mux. Got you guys ready? Let's move on to a little test. And this is actually your chance to show and to test what you know. So let me see if you think that the function that I show in the truth table up here is actually equal to the implementation below. And notice that this is ground. This is the power supply. Power supply is equal to logic one. And in this case a is MSB and LSB. The convention is that always the left one on the multiplexer is the most significant bit. Okay, I'll give you five more seconds. 43210. And we got a humongous majority. Odds are super high, the majority is right. Let's see. So if we look at this function, we see that multiplexer has 0 at the input for all combinations except for 11. Now we look at the table and we see that in fact, 11 combination is the only one when we want to output of one, all other combinations or output 0. So majority was correct. Good job guys. Okay, let's move on and see how we can implement a function using a multiplexer. And in this example, I would like to use variables a and b as controls again, with a as most significant bit, and B is least significant bit. The output is going to be function Z. So we first want to look at what do these inputs correspond to? Input 0 will correspond to a prime B prime. Midterm input one will be a prime b. Next one is a B prime, and the last one is a B, because they correspond to 00011011 in terms of binary combinations. Now we look at our function and we realized that a prime, b prime is already there. So that's super easy. And in fact, when we have a prime, b prime, the function output will be C. So that's why we connect C to this particular input of the function. The next is a little bit more complicated because both AC and BC are missing the corresponding variables. So we're going to actually just expand this using the simple Boolean algebra theorem. And let's do that with both examples will both terms. So that way we can be consistent. Okay, so now we're going to rewrite it as the following combination. Oops, I forgot to write C. Enrich all of the variables are present. A prime, b c prime, or a b c prime, or a prime B prime C. Ok, so we're already done with this one, so I'm not going to worry about that one. The next one, I'm going to worry about this, a prime B. So B prime B exists right here and does not exist anywhere else. And we notice that it's connected to C prime. So I'm going to write c prime here and now I won't worry about it anymore. Then I look at a b prime. Ab prime is only over here. And notice that it is, has seemed x2 it, so I'm going to connect C here. And now I'm done. I'm gonna scratch enough to remember the thumb Done. And now I'm down to only a B combination. Notice that for a b I have two terms. I have a b, c, and I have a b, c prime. This can be simplified where I have c or c prime, which means that a B is combined with a logic one. So in this example, I'm going to put the logic one at the input. And that would finish my problem. So this was one way of doing this particular problem. In another way of doing it. What happened to draw a KML? Here is my came up here, a, b, here, c. And now I put all possible combinations again. And I'm going to take each of these prime replicates and I'm going to put it in my came up. So this is a C, which would correspond to all situations in which c is one and a is one, and that is this one. Now I'm going to do b c prime. So here's my C prime, and here is my b. So this is my B C prime. And the last prime is a prime B prime C, And that would be down here. Okay? So that finishes, represent my representation of this function. The rest of them, I'm gonna put zeros. Okay? Now I'm going to look at these combinations. And I'll see for each of these combinations, which column does it correspond to in this case, 00 correspond to column 00. In this column I have 0101 is the same thing as variable c. So that is why I would connect variable c over here. And notice that the same thing replicates over here. So this is why I would connect variable c also over here. Okay? The next time I'm going to look at is 01. Here, I have this interesting combination, which is 10. This corresponds to the complement of C. So when C is a 0, my output is a one. When it sees a one, my output is a 0. So this is y c prime, this connected here to C prime. Okay? And the last pieces when both variables or logic one. And that is why I connect logic one over here. Okay? I think you guys are following this Is everybody, okay, so far. Okay. Now you get to do this example. I think this is somewhat similar to what you should see in the homework assignment. And I'm going to give you a little bit more time to actually try this one. You should really think about this in terms of what is this function w over here and how does that represent z? This can be solved using truth tables, using came apps or using Boolean algebra. It's really up to you which approach would decide to go with. It looks like we're about to finish. I'll give you five seconds, 543210. And let me share results. Most people think that it's c, but there is quite a bit of confusion, which is why I gave you a little bit more time to attempt this. I know this is somewhat similar to the homework. So that was another reason why I wanted to make sure we went through this in more detail. Okay, so let's look at this. One way to do this is by doing Boolean algebra. So in this example, if I do Boolean algebra, I can use, I can represent w as a function of this first multiplexer. So when a is equal to one, output is c. When a is equal to 0, output there's a logic one. This can be further simplified, and this is one of your theorems of Boolean algebra. You can do it pretty easily by just simply implementing it in a tiny little k map. And you can see here a prime. So a prime, I would have logic once here, and a C would have a logic one here that leaves logic 0 right over here. And if I want to simplify, I will probably go with the logic 0. So the implemented using product of sums and product of sums version would give me a prime or C. So this is a prime or C. Now I move on to the next multiplexer. So this is z output. And when b is logic one out, but this c-prime, when B as a logic 0, output is w. And at this point I can put what my w is. So my W is a prime or C. And that means after a little bit of simplification, I end up with a prime, b prime, or b prime c. And now I can compare it to my results and you can see that majority in fact was correct. It is a prime B prime, b prime c, or a b c prime. Okay? And you could have done this with a truth table. You could have all stop. Instead of a truth table, I would've probably recommended doing it using K map like this. Okay. Hey, let's get move in. One of the primary ways that we use multiplexer is actually in design of arithmetic logic unit. And here I would like to show you just the logic functional unit because we have not yet done the arithmetic's. And so in this particular implementation, if all inputs are 0. It's connected to logic one. If all inputs are one is connected to logic 0. Now notice at the input six, which is represented as 110, we have a logical nor. So here I'm going to put the NOR gate for a and b. But notice that at the input one I have a logical OR SO there. I'm going to put just a simple inverter and connected to the input one. Now notice that I have logical NAND at an input to. So I'm going to put the NAND over here. But notice that I also have a logical end down here at the input five. So I am going to connect an inverted there. I don't want to double draw gates. This is why I'm reusing the gates. And then the last pieces we have is XOR, XNOR, and we kind of do this, oops, the same thing as what they did with the previous gates. I simply add an inverter for the XNOR. And that's it. That's our logical function unit. Now comes the super hard question for you guys. I'm gonna start the poll. So you can get started thinking about this question. Notice we have a multiplexer which is controlled up, sorry, which is controlled by these two selector bits. The selector bits are represented as 10 in binary. These are the inputs. The input consists of four possible values, and it is equal to a in hex. I know it's tags because I represented it as a hex value using this notation. The enable is equal to one, which means that multiplexer is on. If enable is 0, multiplexer would be off. So multiplexer is on. The question is, what is y equal to? So I'll give you another 30 seconds to think through this. Pay careful attention to the order of variables. And two, how the inputs are specified. One, input selector bits are specified in binary. The input is specified using hex value. And D3 is most significant bit that's defined right here. You can see that. That's a good question actually. Okay, 543210. And let me share results. Everybody went for answer B. So let see if b is correct. Ok, let's look at this. So starting first with the selector input, selector inputs are 10. And so that means that I'm going to have 10 here. Because I have 10 here, that means that I have selected input d2, because this decimal two is equal to 10 in binary. Ok. Now let's get back to our specification of what values are on our bus. D3, D3 down to 0. When I write it as d three down to 0, that means that I have ordering of D3, D2, D1, and D0 0 for D3 is most significant bit. I also told you that the value of a is in hexadecimal. So what is a in binary then? If I, a in hex is equal to ten in decimal, in binary it would be 1010. Notice that d2 corresponds to a logic 0. So effectively what I have here is 1010. And because the two is connected to output, the output y is actually equal to a 0, which means that a was actually a correct answer, not be. Ok. Any questions on this? Okay. Moving on up. So what does a 16 mean again, if I write a 16, that means that it's a in hex. Oops, hexadecimal. So be in 60 would mean 11 in decimal C, and 16 would mean 12. A means ten. In decimal. X here means you blew your circuit up. Whoops. Or 0 connected to one. Otherwise known power connected to ground z means open circuit. Exactly. So in hex you have digits 0 to nine, and then a, B all the way through F, where F is equal to 15 decimal ace. Then this is why we reviewed the number system. I think we got all questions. Let's move on to de multiplexer. So the multiplexor can also have an enable signal. If enable is equal to one, then only one of the outputs will be equal to whatever the input, this, everything else is equal to 0. So if I have something like this and my input S, And let's say that the enable is equal to 01:00 AM. I put S is equal to 0, then what that will have on the output is. Y 0 will be equal to x and y one will be equal to 0. Ok? So that would be a de multiplexer. Let's move on to the decoder. Decoder has to select two bits which tell you which one of the outputs will have a logic one out, all other outputs will have a logic 0 out. Stuff enable signal again is used to control whether the whole decoder is on or off. So for example, if both inputs are 00, then only y 0, we'll have one on it. Everybody else will have 0. If I have 01, then only y one will have a one. Everybody else will have a 0. And so on the corners or a lot, they used a lot to address memory. And now I'll give you that the example towards the end of this class. So here's how we actually implement the decoder. This is an example of a 2-to-4 decoder. It shows you all of the logic gates that you would need to actually implement the decoder. Right here. It basically implements these functions here. In this example, I put G in place of an unable to make it easy. But you can just substitute one for the other. And this here are all of the outputs that you're going to get. These are the input controls. So in this example in two to four decoder, we would have, oops, sorry, a1 with correspond to S, 10 would correspond to a 0, enable corresponds to G. And then these Ys would correspond to output 0, output one, output two, and output three. This is what happens when you copy from somebody slide with two different flights that I copied from God. All right, so let's move on how we do logic using decoders. So decoders are nice because they naturally give you min terms. So for a given combination that the input only one of these min terms will turn to one and in fact the only one that corresponds to that particular min term. Okay? So in this particular case, if I want to represent the function AB or a prime, B prime, all I do is I connect to these two outputs using an OR gate. And that gives me a correct output function. Now let's say that I connected these two outputs to a NOR gate. What would I get here? Over here, I would have a prime b prime c prime, or a prime B prime C. Notice that I can actually simplify. So in this example, what I've actually done this, I've implemented z equal to a prime and B prime. Okay? And notice that here, it does matter what is the most significant bit. The most significant bit is always on the left. So if I have a value. 001, this would in fact correspond to this particular mid-term. Okay? Okay, let's do another example. So in this particular example I have max terms 024. So which midterms does that correspond to? Which minterms? Yep. So it will be 13567. So that makes my implementation super easy. Sorry, 01234567. And here's my abc. So to implement this function, instead of thinking about max terms, I represented with midterms. And I simply pull those down into an OR gate. Here is a big OR gate and here is my function f. Ok? Because decoder rep is very easily represented using midterms. Okay, let's move to another example. So here's an example in which I have three different functions. Let's start from the first one. This first function represents 0101. And notice that a is my most significant bit. So this in decimal would be five. So that would be this particular connection. Here I have 0011, so that would be three. And here I have 1111 and that will be 15. So these three put together are my function F1. Okay, let's move on to the next one. Here. The number that I'm looking for is 1100. Then what number is this? In decimal? 12. So correct. So I would use 12 as one of the inputs. The second one is a little strange and has only APC. So what do I do? I represent that with a b c d prime and a b, c, d. So that gives me both of these as my final design for my F2. Okay? So that's my F2. The only thing left is F3. So what is a best way to implement F3? I definitely don't want to have to expand this around all of them in terms what theorem can I use to simplify my life? Exactly? This is a perfect example for DeMorgan's. So this is not a, b, c, d. And here I have ABCD right here. So now all I have to do is just put a little inverter and here is my F3. Okay. Everybody pine on how we did this. Okay. Let me move on to decoder. Applications. Decoders convert binary addresses, two assertions on the Android device. So as I said, they're super useful for memories or for outside devices that have addresses. So for example, USB can address up to a 128. The other USB devices if you have a single hop. So you would use a decoder to figure out which 128 should actually be connected to the hub moment. Okay? Okay, now you can also build a tree of decoders. So in this example, I take six input values to create 64 possible lines. And I do this by cascading decoders. This allows me to have slightly smaller decoders at each stage. So be the first setup, the curse I create the addresses for the eight other decoders. Notice that only one of these enables is going to be one at the time. And which one is a function of the most significant bits of the address, the top three most significant bits. Once one of these is selected, then that next decoder, and let's say, for example, that if all these three were 0, it would say like D 0. Now these three bits of an address would decide which one output. And if all of these three were one, then I would have y seven beat the only one that has a one, everybody else would have zeros on it. Okay? So this is a great example of a tree of decoders. We can also build an encoder. Encoder basically says that the input you have single one. So everything is 0. 0, but a single one. And when you have that condition satisfied, then this well, just encode that into binary value. Okay? Encoders are not used very much in circuit, so this is how you would design it if we're going to implement that. Generally, I don't expect you to see much of encoders after today. Here is a great example of how we actually use in practice multiplexer de multiplexer and the decoder. Let me start from the decoder. This example, we will take an address which might be provided by a processor. One of the processors that you might have. This address is multiplex, because we decide which of the processors. So p1, p2, pk shouldn't be controlling this single address bus. There is only one address bus that goes to memory. Once the multiplexer has selected that the decoder will decode that address, and it will enable only one of these memory banks to be accessed. That one memory bank will maybe put the data onto the bus. This is also a bus. And then the multiplexer will route it, say, for example, to the PK processor. So this is an example in which pk processor was trying to read data from memory. We can also have a situation in which a processor may write data. So for example, if I have a situation in which P two was selected to access any activated the different bank in memory. Now, the multiplexer will select the data from P2 to write the data into that memory. So this is how you would use the multiplexers or de multiplexers. Every single processor that you've ever seen has this type of design in it. And usually will have similar pattern with all of the other IO devices that you might have. For example, if you have a sound input or if you have wireless input, all of these types of devices will have this kind of design at them. Okay? Okay. Any questions on this before I move into others? Okay. Moving on to others. So I've already introduced you to half-hour. There has two inputs and two outputs carry out. And sum. Here is the truth table and the logic functions for it. Have other is great. If all you need is to just to single bit binary numbers. It's not so useful if you actually need to add multiple bit binary numbers. In that case, you would want to use fool either because it gives you a carry in input. It also has two variables. Single bit inputs, has a some output and it has carry out. Because I have carry in. Now I can create larger size. And I'm going to actually simplify this. I can create larger size binary additions. So here's my C out. But I can now put it as an input to the next set of bits A1 and B1. And its input, which will produce carry out. And now all of the sudden I have addition of two bit binary numbers. A number a that goes one to 0, and b that also goes to 0. Now notice that this carry n can be set to 0 because I'm adding only positive binary numbers. Okay? I can generalize this further to create an n-bit bus that takes n bit values. So for example, in your processors today this might be 64 bits. So you would have 64-bit a, 64-bit B that would produce 64 bit output some. But there would be only one bit input carry and one bit output carry. Because if you add two 64-bit numbers. You can have only a single bit carry out. Now going back to our simple version where I have only single bit inputs and a carry in. This is a truth table that I would have, which then for example, the fiber adding 01 plus the carry in of one, I would have output of 1-0, which in decimal is two. Which makes sense because I've just added one plus 0 plus one in binary to get a binary 1-0, which is true. Same thing would happen. F11, in which case the output would be one plus one plus one in binary again, and these are all additions. They're not ores. And this gives me 11 in binary, which is equal to three in decimal. Okay? And sorry, this should have been decimal. Notice that the same output happens if carrying is a 0 and a and b are both one. You still have output of 1-0 would carry in of one. So now I can create the key map, one for care yet and one for sum. And I will get equations that correspond to this. Now I haven't taught you how to get XOR is out of the came up. So you should just trust me that this is correct. This particular carry out, you should be able to get easily from a came up version. And I see that the question, the question in chat as if C And let me add three bits instead of two. It's true that that is a deference the carry and this the difference between FullAdder and half adder, full adder. Let's me at two single bit binary, sorry, three single bit binary numbers, where half adder allows me to add only two single bit binary numbers. So that means that with Father I can build multi-bit the others. So if I put this together, I can create, as I said, a multi-bit adder. And in this example I have 32-bit there where I've collect connected each carry in. So carry out of my first stage, connects to carrying of the second stage and on it goes until I get to the final carry out. Initial carry in if I'm adding only positive numbers would be set to 0. Okay? Now notice when I have so many deference, full adders connected together. If I wanted to figure out delay from when I generate the first sum until I can generate the final sum and the carry out. I actually have to look at how long it takes me to go all the way through. And this is a function of the carry chain. It's inside of each carry. I have a delay of these two gates. That means that the total ripple carry delay, and this is called the ripple carry either because effectively carry ripples all the way through from the 0th stage all the way to my 31st stage. It's going to be equal to the number of stages, which in this case would be 32 times the delay of single full adder. Okay? And that delay is two gates shown up above, okay? So you can see that ripple carry either is it fairly slow? And it's slow because we have to wait for this carry to ripple old away throw. So starting next time we're going to talk about carry look ahead. Adder, which makes things much faster. It allows for certain sizes of others to pre-compute the carry. So therefore, you don't have to wait for the data to ripple all the way through. Now I'm going to stop right here because I think you have everything you need to answer all of the questions on the homework. I wanted to give you guys a chance to ask any questions that you may have on anything I've covered so far. Are there any questions? Now? One question is, why is it called the ripple? It's called the rebel because you have to wait for the carry out of 0 stage to be computed so that you can compute the carry out of first stage and then you have to wait for the next stage, and then again, and so on. It goes until you get out. So it literally takes you in 32 stages, 32 times two gate delays in order to get the final output. So it's sort of like the carries rippling through all of the gates. That's why it's called a ripple carry. Okay. Any other questions on anything related to either this or to homework? And just to kind of give you a quick overview of what we did today, we covered we finished our optimization of two level function. So we talked, and we talked about how to find prime implicates an essential primes and how the algorithm for optimization of logic functions works. We've talked about two and multilevel logic. And then we talked about multiplexers, decoders, adders. And we will talk about in future on comparator multipliers and other ALU elements. Today we covered only muxes, the maxes decoders, encoders, ripple carry are there. And we also covered Tri-state buffers and pass gates. Somebody asked, when would the Homework one results be out? We are hoping to have them out sometime today. The latest tomorrow. Professor? Yes. I could ask a question on the homework. Yes. No problem. I got eyebrow. Okay. Which homework? And number four and I was questioned for. Okay. So as I wanted to ask, so when the humidity, when hedge is 0, l is one and the rest, the temperature and the manual, they don't matter, right? Humidity is one. Someone's the humidity and sera, if humidity is 0, the light should turn. Audit says what did you say again? If humidities they're out them and then the light turns on in the restaurant app matter. It doesn't matter what m is or what t is. It doesn't look like it's saying anything about tea or under that condition. When you read through it. But I'm not accept manual override is activated. The light turns on regardless of the state of humidity. So be careful of that statement. In this case, when humidity is 0, does the light turn on regardless of the Manyuan temperature? So notice that in the very mixed up it tells you the manual override, which means that it overrides anything when it's activated. So if m is one, it doesn't matter what Hs light will turn on. And can that part but my question is like the for the previous part, if humidity is low, that light should turn on. Does that mean that the light turns on regardless of the state of the temperature or manual. It though, and it's regardless of temperature because temperature doesn't matter on neither case. Notice that the second case tells you that manual override, which means it overrides anything else. So if you have a situation that m is equal to one, light turns on regardless of humidity or temperature. So that means that that overrides or takes over the previous statement. Okay. And and I'll say I have a question regarding on question two, separate question to see. I was learning when I was drying out, so my function itself was a NAND not be manned BY nancy. Manned not be NAN, not see. And read a two input gates. I got train six, trend training. So I would, I would suggest that you don't get bouncers over maybe because everybody's list. Right? And so in this kind of example, you want to just get to the actual question that you have. And in this particular part, it boss you. What is the minimal version? It does not specify, but you have to use only two input transistor, that two-input gates. So you can use bigger than two input gates. When you use bigger than two input gates, you're obviously going to have more transistors than what we counted in class. Okay? On the air to try and compact compared to the number of transistors you can put gates, it decrease your total number of gates. Transistor should be less. That depends really on how the circuit this put together. So I would suggest drop or yourself a simple example and see what actually gives you a smaller design. Because if you have two NAND gates feeding each other, that's going to be four transistors each. And that would give you a 3-input NAND, right? In ad, if you do a 3-input NAND and transistors, you're going to have three nMOS and pMOS transistors, which is six transistors. So which are okay. Any other questions? Question, Thank you so much. Problem, And thank you for being patient and calling it again a little later. I appreciate with anybody else have any questions? Okay. I thank you all and good luck on homework number two. By