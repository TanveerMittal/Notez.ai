 Mm-hm. Everybody is wonderful to be with you again. Loved the day-to-day, By the way, I thought it was going to rain, but looks beautiful. My window. I hope it looks great wherever you are. So today we're going to continue talking about arithmetic components will add some more nice devices that will allow us to actually build ALUs. And sure, we complete this. We will be done with all of the combinational logic. And our next step is actually going, going to be to design some memory. That's most, most likely going to happen after we're done with the exam. So where we are today, as I said, we've covered pretty much everything I was going to cover for combinational logic once we finish with today. The excitement of today is others, subtractors, comparator, shifters, and then ALU. The key deadlines, I forgot to write down the homework number two is due today, but it is today at midnight. And you are welcome to turn it in when it's 10% subtracted from your grade by tomorrow night, which is Friday night, midnight. Anything turn, then after that get 0 points. And we will hopefully be grading it and posting it by next week. On Tuesday, no later than Tuesday because I really want to make sure you have greeted hallmarks and solutions in your hands in time for the exam. The exam number one is next week on Thursday. It will have four questions. You will be getting questions on canvas and you will turn to men on great scope during the exam time. So next Thursday there will be no class, but we won't be monitoring private Piazza posts only. There'll be monitored only between nine AM and 10:00 PM Pacific. So if you are concerned and want to have your questions answered to make sure that you take exam during this time slot. You will have 24 hour period to take the exam. So you will be in fact. And we did that 24 hour period. The exam itself will be 60 minutes and this is 60 minutes from the moment you get the care that the moment you turn it in on great scope. You can answer questions of exam, either on your computer or on your iPad or in some tablet, or you can print it out and then scan the answers in. It doesn't matter to me how you do it. What matters is is that you turn a minimum grade scope correctly. The exam is open book, open notes. I mentioned that there are four problems. It is total 110 points, but it's graded out of a 100. So that means essentially that you're gonna get bonus 10% on this exam. If you get all points, you will have extra 10%. That should hopefully make things easier. The other, It's that next week we will not have normal lecture time. Instead on Tuesday, I will take both lectures about 930 and this lecture time to cover some sample exam problems that may give you an idea of the types of problems you might actually find on your, on your exam. Number one, I will also post sample exam from previous year and solution on the website. And I think we'll try to post it on Canvas also. And we're gonna posted by Tuesday as well. The idea why you'll have a chance to take the exam, the sample exam, at home yourselves, and then evaluate how well you do. And if you have some questions, you can ask me either when I'm lecturing on Tuesday or you can also ask them during the review session on Wednesday. Obviously next week's review session is all going to be about the exam. So you will see some problems on the review session that are fairly represented. Therefore, what's going to be on the exam? I think that's pretty much it from my updates. Do you guys have any questions related to this? I see a question. Then we'll even have homework next week. I am not assigning homework today for next week, you will get, However, the week after and that the homeworks are going to cover material we'll cover today and material we're going to cover Tuesday after next. So the question is, is exam expected to take 60 minutes or does it include time for you to upload? The exam will last 60 minutes. We will give you a bit of grace time to upload. I need to figure out exactly what that's going to entail. So I'll let you know the details by next Tuesday. Next Tuesday, I will actually also have a TA give me off how exactly all of this is gonna work. So for those of you who haven't done this specific combo, starting from great scope, starting from sorry, Canvas going integrate scope. You'll have an example that make the I will show you. So hopefully it'll be pretty clear. Basically it's very straightforward. What will happen is you're going to get your particular version of every single problem on canvas. And the only thing you need to be careful of is that you upload the correct version to the correct bucket. The great scope. If you have technical prob Piazza times you can certainly send an email. I can not guarantee that anybody is going to be online between 10:00 PM PST and the next morning, 09:00 AM to answer. So if you are really concerned, I strongly advise you to take exam between nine AM and PM. Now, having said that, I would also say when you answer questions on the exam, if you make certain assumptions and especially if those assumptions are made outside of the time that we're holding Piazza answer sessions. I strongly advise you to write down what the assumption you may then we'll do our best to give you extra credit as a function of that assumption exam from last year and each answer sheet will be uploaded on Tuesday. I one thing I need to warn you is that last year's exam lasted longer and therefore it's going to be more complicated. I think it had tickets instead of four. And I don't remember if it included some of the questions that your exam will not half because I think the timing of the exam was a little bit different. So and I will let you know all of that when I dig out that sample exam next week. So no worries. And if anything is unclear by all means, just ask me any other questions. Okay. I don't see other questions, so I'm going to get started with what we're going to cover today. So today I want to review very quickly ripple carry out there and I'll tell you add are pretty much always appear on exams. So if I were you, I would make sure that you feel super comfortable with half hour, they're full lather, ripple, carry other. And today we're going to also talk about carry look ahead adder. So a ripple carry adder is designed when the chain bunch of 1-bit adders together. So in this case, we're assuming that we have full others. And we know this is a full adder because it has a carry in and carry out in addition to the inputs and the sum. So for FullAdder, you always have a carry in input as well. And this is what allows you to chain these and other others together. So here is a carry out of this stage that connects to then carry in the next stage, stage number one. And on it goes. So carry out of stage number one is going to connect to carrying of stage number two and so on. Now if you look at the last times lecture we talked about, and I provided you with the truth table for both sum and carry. And if you did the K map, you will figure out that carry out is actually a function of two components, a gate a, B, a, and B, which effectively will produce output. It's as if my inputs a and B, a single gate delay. And this is what this means. One gate delay. You will have an output a and B. So it takes literally just funky delay. That's true for all of these bets. So for every single, for a and b, for every single stage where we produced after just one gateway. The other piece of this that is a little more complicated. It has an or gate. So this OR gate is also one gate delay. And it is labeled as an at one. So that's this OR gate here. Right? And here you can see that it's one gate delay and it's kind of the same story regardless of whether I'm at the 38th level, FullAdder Ahmed, 0th, that single OR gate will data inputs a and b, and it will produce an output after just one gate, which means after only single gate delay. The problem happens when this carry, this carry depends on whatever was at the previous stage output. So this is y here we have a dependency of all of the gates before it. And in fact, this piece, both the OR gate. So this is the OR gate that's depended on and gates. And this, AND gate. This is, and here is our app. And this is C In or both of those depend on all of the results from previous stages. So this is what is a function of all the stages before it, plus a single end and a single OR gate of the last stage. So this is why we say that delay in Ripple Carry is the function of the number of stages we have plus the delay up any single-stage. And delay of any single stage is again gonna be a function of this carry chain plus these two gates. So it's effectively, if we have 32 gates, it will be 32 times the length of the single 4-bit avatar, which is a function of two gate delays. Okay? Any questions on this? So this, this is exactly why ripple carry is a very slow design. Perhaps 64 bit ripple carry, either my delay for 64-bit, the other is going to be 64 times full adder. So he just gets linearly slower essentially. And this was then motivation for us to design a slightly faster merge to Lynn just carry look ahead version. Now notice that in the carry look ahead. We have again two components. We have a sum which is generated in two gate delays because it's a function of only the inputs. And then it's going to be a function of the carry to that current inputs. But they'll show you here in a second that this particular Carey in fact will not cause a lot of the additional delay. Because the carry here is going to be precomputed. Now, the carry for every single stage is again a function of the inputs to that stage. So here are the inputs plus the carry from the previous stage. Now notice an interesting thing. Here, I have this XOR gate and this is an example of the situation in which I'm going to reuse an XOR gate result in order to generate the carry output. Then in fact, this is connected to the wrong place. It should be connected right here. In order to generate the carry output of the next stage. Okay? Now notice that this is not exactly the same equation as what we had on the previous stage. So in the previous slide, what we have is this equation, AIB or CI, and then AI or BI. But if you compare what happens when we actually implement this carry using the overall equation, you will find out that these two implementations are equivalent to your basically comparing to logic ones using a slightly different approach, slightly different gate, but you're still covered the full equation. Okay? So the other interesting thing is that this gate here is a function of only two variables, a and b, which you can compute in a single gate delay. So both of these happen at delay of only one gate. Now these things are called generate and propagate. Y generate and propagate. So it generate, is z equal to one. Then what happens is the carry out of the, this particular stage will be equal to one. So we will generate a carry of one. That's why this is called generate. The other situation, if generate is equal to a 0, then we have to evaluate what happens with the second half of our term. So then we have a situation where carry off the next stage is equal to whatever that Carrie was times the propagate. Oops, sorry. Oops, this is a carry and then that's equal to carry timed and that propagate. So now we have two options. We have option where propagate is equal to 0, in which case Carrie. Of i plus one is going to be equal to what? If propagate of i is equal to 0? What is the carry output equal to? It will be equal to 0. So in that case, we don't care. In fact, what the carry in is. The other option is if propagate is equal to one, then the carry to the next stage is going to be equal to whatever the carriers in the current stage. And this is why we say that the carries propagating. Because when propagate is equal to one, then we're propagating whatever the Kary was to the next carry stage. Ok, so now that we've looked at this, we can also look at what happens at stage carry of stage one given my stage 0 values. So if I have a 0, b 0, or carry 00 x or v 0, that's the same thing as saying I have generate 0, 4D, carry 0, anded with propagates era. And that is exactly what I drew here for dispersed stage. Now why does it say at three? It says add three because in order to generate it, I have three gate delays. So in order to create g 0, it takes one gate delay. That's this. And gate a, B. Same thing happens with propagates. I have one gate delay here in order to generate propagate because I need the next OR gate. So this is also one gate delay. And then gate delay here. So this is my second, the gate delay, and here's my third game. This is why we say that the carry of one is created after three gate delays. Okay? Now what happens with the carry of two? So if I want to do a carry of two, that is a function of, generates one or carry of one. Anded with propagate one. January fun and propagate one that are created just by using a and b. So a single gate delay, I don't have to worry about it, but carry of one, I can actually just plug in this value in here, in instead of carry of 12 precomputed the effectively. So now I have generate 0 or care. Prop again Sarah ANDed with propagate one. And if I further simplify this, what I get this generate one and then generate Zara, propagate one. And bad carries era, propagate Zara, propagate one. So that is exactly what I put in the bottom left-hand corner. And you see that with every stage these gates gets bigger. Now if I go to the third stage, so if I do C3, that's the same story again. Now will have g2 ord with c2 p2. And to create this, I will do G2 4D width. And now I just that input, whatever I have four. C2, which is G1, generate one or generate 0, propagate one or carries propagate, propagate one. And that all would propagate T2. And that is exactly what you end up with down here. Now why do we say that this is also in three gate delays? It has to do with the fact that these guys, to create, generate you need at least one gate before it, and that is the end gate to do propagate. You also need one gate, and that is this x or gate. And now you have one gate here. So now your two gate delays, one gate here, and this is three gate delays. Now, obviously, this is super simplified. The problem with these gates is that they're not just a two input gate, they have whole bunch of inputs. So by the time we get to carrier for the biggest input gate has 12345 inputs. So this would be in the worst case. It will have five resistors in series. So it'd be five times resistance times two times capacitance for a total delay of ten RC, which is very slow. Right? So this is why we don't go usually beyond 8-bits for carry. Look ahead. Because you end up with fairly large gates which tend to be fairly slow. And in reality, you would never actually open this fusing these wide gauge would, you would probably do is create the tree of smaller gates to get better at delay. So I got a question on what I only see two gates in the row. Why is it that three? That's because I was lazy and I didn't draw the other gates. So if I were to draw the previous stage, what I would have to put in, for example, for generate Zara is this gate a 0? And then you would have to fill that out for all the other ones. For p0, p1, p2 and G1 and G2, same story. So for example, P2 would have an XOR gate. If I can draw the x or gate, there we go. And this would have a2 and b2. And notice that all of those gates depend on only a's and b's. So as a result, you can actually get the results in just the three stages that I showed. Now again, remember, I keep three stages you end up with these big fat delays. Okay. Any other questions? So here is a question for you guys. I know you're dying to have a pole. So here comes the first poll of the day. The first Paul asks you to design a 64 bit adder. And the question is, how do you get the best performance in your 64-bit data? Should you design it at 64 bit ripple carry out there. So that would, whoops, sorry. So that would mean that you would have a bunch of these single pull adders connected. So you have from 0 to 63 stages, okay? The other question is do the do 64 carry, look ahead that era and remember how we did our generate and propagate. And eventually you would want to have a generate 63 and propagate 63, go into a set of gates that create the carry. Or would you do 8-bit section? So here I will have eight bit carry look ahead, connected together to create the ripple. Right? So you would have bunch of dose connected together. Or once you do a 32-bit section, ripple carry adder, connect that with a little piece of carry. Look ahead so that you can actually connect the other 32-bit section of RCA. So which one do you think is the most appropriate option? Okay, I'm going to give you five more seconds, 43210. And here are the results. You can see that most of the class likes the C option. And that turns out is in fact the best option. So great work everybody. This first one would be to slow. It will take 64 times the delay of the full adder. This one suffers from very wide gates at the later stages. So well then the big, actually slower than the ripple carry, possibly. Because you get this great balance, you have fast TLA stay 8-bit connected by only just a single ripple. And this single lipid ripple is super easy. It's just couple of gates. This is good because you have 32 times the delay of a full adder. Whereas the carry, look ahead. This again just two gates. So you end up with fairly slow dealing. Okay? It seems to me you guys got this really well. So we're ready to move on to subtractors. And turns out that all rest of the lecture today you'll discover that in fact, all you need in life is a bit of logic and adders. And you can implement any arithmetical logic unit you want. And that is the beauty in fact, of hardware that once you learn a pMOS and nMOS transistor or everything else is built out of it. So here we are with subtraction. In order to subtract in binary, we actually always do Two's Complement addition. Subtraction is in fact Two's Complement. Addition. How do we do Two's Complement? While we take a number, a positive number, we then negate all of its bits and we add one. So we take seven. And notice that here it matters how many bits? So if we have a 4-bit number, seven would be represented as 0111. We now complement numbers. So to complement, you get 1000 and then you add one and you get 1-0-0 one. Now notice an interesting thing that happens. The interesting thing is that when we use this complement, we will always have more negative numbers, that we have positive numbers. And this is because we're using one of the binary combinations for a 00 counts as a positive number. So how would we do subtraction? So how would I do four minus seven? Well, if we do a decimal, it's super easy to just negative three into do 2's compliment of negative three, we would just take 0011 and to get its representation the negative who would compliment it? And then we would add one. So it will be 1101. And we double check whether that's correct. And in fact we find that it is, that's good. It's good news. I know how to subtract seven from fourth. Now how do we do it using Two's Complement, we would take four in binary and foreign binary, 0, 1-0-0. We will take negative seven in 2s complement and that we already figured out this one zeros 01. And now we can just do standard binary addition. So the result will be 1011. And we look this up and compare it. And you can see that in fact, the result is correct. It is negative three, okay? So I assume that all of you guys know 2's compliment and you know how to do subtraction using just integers, positive and negative integers. I'm not gonna cover decimal in this class, but your textbook goes into details of this and also feel free to look it up. I do want to talk about how we detect overflow when we do addition and subtraction. Because that actually turns out quite important for implementing and designing your CPU. So overflow happens in two situations. In situation number one is if I add two positive numbers and I overflow and end up with a negative result. So in this case, I had that seven plus one and I should have gotten an eight. But instead, what I got was a completely wrong result. What I got was negative eight. Exactly not what I want. Bad news. The other cases, when I add two negative numbers, in this case, I ended up with a positive seven, which is impossible if I started out with two negative numbers. So in both of these cases, we see that the problem occurs when the sign bits of each individual operand are different than the sign bit of the final result. Now notice that in this equation, I label these bit. So this follows a3, a2, a1, a0, 0, and then same thing with b, for B3 to be 0. And then the final result, the sum three down to sum 0. The last case when there is no overflow is if I have different sign bits in the operands and I end up with the sign bit that doesn't match both the conditions for overflow or only if I have two zeros for the assignments, but the sum is a one, or I have two ones for the sign bits, but the size, the sum sign bit is a 0. Notice that this requires two AND gates, one OR gate. And it's going to require three inverters, which is actually quite a few gates. So it's not in fact the most commonly used method, but logically this method works just fine. Way to do this is to look at the care of the previous stage and the last stage and compare them. And you will see if you carried that overflow occurs when the two carries are different from each other. So this is why we usually implement that just using a single XOR gate. And these carry. So you're gonna have, anyway because you're going to be computing, you're going to be propagating this carries from one stage to another Anyway. So you will know exactly what they are. Okay? So now that we've covered the basics of how subtraction and how I can detect overflow. We're ready to start putting together our subtractor. So to do this to the tractor, we take an adder and here is our either and we add to it ability to complement inputs of one of the variables. So in this example, I'm implementing a minus B. And I've also provide a carry in of 0th stage. And I said it to logic one. This symbol here is just VDD power supply, which is approximately one bolt, and go up. Now another n-bit adder. So what I'm assuming here is that I have ripple version off a whole bunch of full adders and into the 0th bit. So here's my 0 bit. I'm going to put the one. And then on every single bit, I'm gonna input B, not. Ok. So here would be my b n minus one and a n minus one. Then the output obviously is the sum minus one and also carry of minus one. Okay? The symbol for it would be a simple subtractor symbol. So now that you know everything, you guys can help me analyze this particular design. This design is a design of a super cool circuit. This amazing circuit has either, whoops, sorry, it has an adders here and mucks up here. So what I would really like to know is when does addition occur in this schematic? Does it happen when select signal is true, urban select signal is false. I'll give you 54321. And here are the results. Most people like option B, but there's a pretty insignificant fraction that like the a pen and whoever chose C, It was a little lost this morning. I know it's sunny, but it's pretty clear that there's only two options here to select from. I guess some can be a little distracting when one would probably prefer to play outside. I certainly don't love going outside. Okay, so let's look at how this works. In this particular example. I have selector that is connected to the carry in and it is collected to also the, every individual multiplexer that I have in this design. So this basically means that if I want to add, what I would want is I would want to input a to my either. And I will also want to input B, not bean. So in order to do that, Selector has to be equal to 0 here. And in the first stage I would want it carried to be 0 because I'm doing addition. I don't need two's complement. So correct answer is answer B. Good job, majority. Now if I wanted to do subtraction. So if I wanted to implement subtract a B and sum operation, which is basically S equals a minus b. In that case, select should be equal to one, so that I can get B 0 complement that connected to the input B and a 0 as it is. And this will then allow me to get both the problem and the second variable. And it would provide a carry in of 12, the initial stage. Ok. Any questions on this? Okay, so let's move on to a more crop components. The super simple one is when we want to know if two variables are equal to each other pair two variables, doing an XNOR gives me a very easy single gate solution to comparing two bits. Basically, XNOR gives an output of one if two bits are the same. So that's why we use XNOR is as a first stage. And now if I want to know if everything is equal, I would want to know if any two bits are the same, and then if all of them are the same, equal should be equal to one. Otherwise, if I have a situation in which one of these is not the same, then I use this end gate to tell me that they're not equal to each other. Okay? So this is an example of e equal assembly function where I'm comparing a and B and maybe I'm setting a flag that tells me that equal or not equal. And if it easy equal, output will be one. If it's not, the call output would be a 0. Okay? This one is a little bit trickier. This is when I get less that compares. So here, notice what I'm doing. I'm using a subtractor. So if I do a subtract or what I'm effectively saying is that I have an ad there. But to that either I'm going to add an inverted version of B and to the 0th input, I'm going to put the logic one as a carrier. Okay? Is going to come some. Now if I'm comparing two values, if a is actually less than b, so let's say that I'm comparing, for instance, if I track the two, what I'm going to get is negative three. And remember when I get the negative number by most significant bit is going to be a logic one. So this is the insight that I have when I pull out just the single value. So in this example, I took my most significant bit because I know that this P bit will be a logic one. If a is less than b after subtraction. Now what happens if I want to get a is greater than or equal to B. How do I implement the a is greater than or equal to b. Exactly. For a greater than or equal to b, i would just not the output. Now what do I do if I want a is strictly greater than b? So that's an interesting one. Then think about it logically, what you really want this, you would like to take a situation in which neither a nor B are equal to 0, right? So they're not equal to each other. And we already figured out how to do a is not equal to b. That's the same thing as not a equal to b, which was the previous design. Right? So in this case, the logic that we want is, we would like a is greater than or equal to b to be true. And where would want not a is equal to b. So we would effectively be taking this input, putting an and gate and adding to it not off Result of a equal to b. This one here is the carry in off the 0th stage. So this actually see any questions about this? I'm going to move onto shifters. There are three variety of shutters that you may run into. But in this class, I generally look at primarily logic or broad theater style for logic shift or shift values left to right or right to left. And we fell empty spaces with zeros. So you can see examples on here. So if we shift to the right two values, we're going to add two zeros on the front. If we shift to the left with two values for we're going to add two zeros to the back. Or arithmetic shifter. It seems logical shifter, but on the right shift fills empty spaces with all the most significant bit. Instead of on the left shift you're going to get, okay. And wrote Danner just rotates things in the circle, whether it's in the right, circular, left, circled depends on which direction you're going. Okay, so that's at four different ways that you could shift to. Let's look at this particular shift or design in this shifter. First. Let me ask you what the element is this. So what exactly are these things here? It's a max, correct, great work. And this is in fact a two to four mucks. It has two selector inputs and four outputs, sorry, two selector inputs, a single output which is going to be collect connected to one of the inputs to the max. So because we have two selector input, we have four possible combinations. So let's look at every single one of these combinations in turn. Let's start with combination 00 and look at what happens as we look at a3, a2, a1 and a2 are up and how they relate to outputs Y3, Y2, y one, and y is 0. So first of all, with 00, what is y three connected to? If the input combination is 00, what is y three connected to? A three, correct? Then they can actually make a little table. So if we say that our control is 0-0, we can look at for that, to try to why this. Y three, y. So eight. What is y three connected two versus, so here it goes, 011011. So here is our control and here is what my 3S. So if, what if control, these bits are 00 y three is connected to a three. If bits are 01101111 is white free connected to ground the exactly so logic 0. Now we can do the same thing for y, y2. So here's 00011011. So if combination is 0-0, which would be this one. What is Y2 connected to? A2? If combination is 01, what is Y2 connected to? A three? And the other two options are 0. Okay? Now why don't we go to the next one, Y 10001101100, where connecting Y 121 at 01, we're connecting it to a2. And that 1-0, we're connecting it to a 311. It's connected to a 0. And the last one, why 0? State 01011. And here we see that the 00 y 0 is connected to a 0. For 01, it's connected to a what? Then a2 and a3. Now how does that look like when we think about it from the wire perspective? So if I'm looking at 01, for example here, and I have A3, A1, A2, A1, A0, 0. And here is my Y3, Y1, Y2, y 0. And control is a 01. What's going to happen is on 01 control Y3 will be a 0, but y, y2 will be connected to, but I just miss rho. Y two will be connected to a three. Y, one will be connected to a three. One. Do a better job of writing this. And then y 0 will be connected to A1. So we have shifted by one bit, logic shift. Shift, right? By one bit. Why logic? Because we're feeding zeros. Okay. Now let's look at what happens when we have control 1-0. So here just a3, a2, a1, a0, 0, combination. Those is once they're on the control appears y three, y two, y one, y 0. And here we can see that when we have 10 combination y one will be connected to a three. Y 0 will be connected to a. Three. Y 0 will be connected to a, to the other two will be connected to 0. So now we do logic shift, right? By T2 matches exactly what 1-0 is in buying ring. And the last feast care 1-1 is essentially logic shift by three. In this example, we have a situation in which y 0 is connected to a three and all the other ones are logic 0. Okay? Now notice that to do a connection and with 0 we're just not shifting. So this is no shift. So there is that if we don't need a programmable shift, that tells us by what amount we're going to shift to the right. We can implement this just by moving wires. We do not need a multiplexer. We need a multiplexer only infant need a way to make it programmable. How far are you a bit of a shift? Now all of this so far was shift to the right. How do we do shift to the left? What would we need to do to shift left? So for that, you would really want to have an additional multiplexer. Which tau z, or are you doing a right or left shift? And the multiplexer needs to be at every one of these inputs controlling. Where should the Zara Bay versus where should the 1B, where should you connect an input a to the next stage multiplexer. So this is a two stage, two stages of monarch. But same story. Any questions on this before we move on to multiplier? Okay, I'm going to move on to multiplier. So he multiplication. You do multiplication in binary. You pretty much the same way with dotted decimal except it's much easier. Because in binary, if I have a number 1101 and I'm going to multiply it by one, 1-0-0. I would actually multiply every digit in turn, acceptance in binary I have on the ones and zeros. It's super easy. If I multiply by one, I just copy whatever I'm multiplying. And if I multiply by 0, then all I get is 0 out. And after I've done that, all I have to do is add it all up. So notice that this basically boils down to a situation in which if I have z or else I need to make sure that our paternal 0, if I have once the output leads to me whatever was at the input, then this is an AND gate. So this is why multiplier the first stages, set up a bunch of AND gates that generate these partial products. So here is my processor product one, partial product to partial product three and post-war product for. And that corresponds to these guys here. Now once I've generated these partial products, I need to add them together. So here I show an example of a sequential ad where I'm going to add the first two together and then add the next two and the next two. Now, the nice thing about this is that logically it makes perfect sense as you look at it. And not so nice thing is that you have to actually wait for the, all the previous two Earth before you can get any result on the third one. So normally a better way to do this is to do a tree. There's where you do addition like this. So you add these two and these two, and then you add the last result together. There you can end up with much faster results, especially as you start having more stages in your system. Ok, so imagine if I have 64 bit multiplication, I would end up with a lot of addition stages. Multiplier. Does it explicitly or require a shift. They just requires that you place wires to the right place when you do addition. So this is why I showed you on the previous slide. If you don't need a programmable shifter, you really don't need multiplexer. You just move wire to the right place. So for these zeros, when I do addition, I'm simply going to connect the input to a 0. And these partial products, I'll just place the wire in the right place on the other. So that didn't multiplier. Now note, I'm showing you this so that you can be aware of the fact that for multiplier all you needed to others and some AND gates. I'm not going to require that you know how to design the multiplier on any test or any homeworks. I just thought it might be fun to see that. In fact, if you understand how to add. How to do logic, you can build pretty much any arithmetic operation in binary. And the same is the case for division. So in Division, the weights implemented in binary, and again, this is an integer division is by doing but using both adders and subtractors. So here you're gonna do successive subtraction. So I found dividing decimal five by decimal two. That is how they are represented in binary. I would start from the dividend and I would subtract every single time from my dividend, whatever my divisor is to obtain the result. And the result is greater than my divisor, then I can continue doing my subtraction. Every time I do the subtraction, I would add one to the quotient. And so here is where my adder is, and here is where my subtractors, that subtractor is also an adder where the NOT gate and carry in equal to one, right? So essentially I have to others, but one act in the subtractor form, the other behaves as a normal adder. So let's return back to this step. After I've done the first round of subtraction, I see that the result they got three is still greater than my the visitor of two. So I doing other subtractor tracked in, again to from three. Now I get a decimal one, and this is in fact less than two. So this means that I'm going to stop subtracting. And whatever I got as a result is my remainder. And I'm going to finish by adding to the quotient in other one because I've performed one were subtraction and that now becomes my results. So the result is two in decimal or 10 in binary, which is correct because if I divide five by two, I'm gonna get to in decimal with remainder of one. So the and effectively behaves as successive subtraction. Then it requires subtractor and another which is basically to others. And this pretty much covers all of the different components that they're going to go into your earlier design. I still like to do next is talk about some examples of failed you used and discuss some strategies you should take to solve new problems, which you will most definitely have on the next homework assignment, which we're going to assign on the day of the exam. And you will not have a Liu problem on the next exam before I move into IOUs. Okay. So let me give you a first example of an ALU. And when I say an tell, What I mean is arithmetic logic unit. And remember that we already talked about the logic here that we did logical function unit last time by simply using a large multiplexer and connecting logic gates. Today we're going to talk about how to combine the two pieces together. And typically what happens is in ALU, you would have an operation which is going to be your control signal to various multiplexers you may use to produce the result. This result may be either logical or arithmetic operation result. You will usually also produced flag. So example would be overflow or 0 flag. Flag tells you if result equal, equals 0. And overflow tells you if you messed up with your addition or subtraction and ended up with an incorrect result. So that way you can detect it and either fix it or just respond in your code that there was an error. You will carry out because this enables you to detect when you, again, if you would like to actually have a wind, there are arranged in the next assembly operation and then you have inputs which are n-bit inputs. So this ALU is an n-bit ALU. Typically in today's processors you have 64-bit alias. And some examples of functions that you may have in their patrol signals would be logical functions like AND, and OR. They may be also arithmetic functions. And here is an example of an ALU operation. Or it might be something that combines arithmetic and logic. And this is an example of a function where we get a result a less than B, set equal to logic one basically. So if a is less than B output is a logic one. That's what set on less than means app. So those are just some examples. On this slide. I'd like to show you a sample one bit ALU first, and then how to use it to create the 32-bit ALU. And you could do the same thing to create the 64-bit ALU. So it might want to tell you, I have an AND gate. I have an OR gate and I also have an ad there. I use this operation to select which one of these will go to the output. So I can either have an add an or, or an ad to build to the output. Notice that in this particular design, I'm using only three operations. Is it possible for me to have a mux that has three upper three operations that we want to select that has only three inputs. So first of all, to do three operations, how many bits do I need to represent that? I would need two bits. So it to bits I would have combinations 00011011. So can I design a max that has only three combinations, the three that they represent in this device here. And that's a very good point. The comma chose dunya is the last. But so the answer is really, no. I want design a mux that is only three inputs. What I end up designing is a max that has four inputs. These three are used, and this one is left as an open circuit. And it essentially becomes a don't care in our implementation of the function. Okay? So now if I want to combine the single bit, one bit tail views into 32-bit ALU. What that will do is I will take a carrier into the 0th stage. If I'm using only add, then this would be a 0. But if I want to happen an option of implementing a subtract, then I may want to be able to provide also carrying of one to the 0th stage. I know this is 0th stage because it's labeled as a and B 0. And then I want to connect carry out of the 0th stage to the carrying of the first stage. And on it goes until the last stage, but sorry, until the last stage here. Note that the operation is connected in parallel to all of the single bit adders. And note also that results all appear in pair. The other important thing to notice that these gates all operate in parallel. So when I provide inputs a and B in a single gate delay, I'm going to get a result here, here. And after few gate delays, it will have a result of that. I will select one of those a result outputs to appear on the final result of the multiplexer. But all of them will in fact be computed. They will all be computed in parallel. This is why in Verilog, you actually model the fact that all these operations run in parallel. In contrast to what you might do if you were writing code in C or in any other programming language. Okay? So here the question is, is this a ripple carry design? And the answer is yes. This is most definitely a ripple carry design. And this is the only type of design I'm going to ask when I ask you to implement are in here. Because doing a carry look ahead and then they'll view is a little bit more complicated. I would certainly not put that level of complexity on exam, for example. Okay. All right. So you guys ready to move on to the next question? Do I have any questions on this? I don't see them. Okay, so let's move on. Here you get the opportunity to answer another exciting poll. So here is a question. I'd take my single bit ALU, and now I want to make it subtract also. So the question is, how do we get it? Okay. I got 543210. This was like very, very big. I took ten seconds to count five. Majority says the answer is D. Let's see if majority rules. So looking at this, in order to do subtract, first thing we notice is that we would need this carrier and to be able to provide also logic one in addition to logic 0. So we would want to provide an option to use one instead of the first carrier. So this one is definitely true. In order to do two's complement, you also need one more piece. You need to be able to invert the inputs B. And that should go across all of the bits. So we also need to provide an option to use bitwise not this is why majority does in fact rule. We need both options, 25. Now if we wanted to do b minus say instead, then we would like, and actually let me get a different color for this. Let's, I don't confuse you. So if we want b minus a, then you would want options 15 and get right. Okay, so let's move on. Here is full 32-bit ALU and we get another poll. For this, Paul, I want to know how would you implement an OR function? So you have the design up above of a single bit. In this design, notice that I now have the ability to use this b invert control to provide either B or not B. And notice that the operation now has four possible combinations, where the last combination is just the output of the less than comparator. Okay? And your job is to figure out what signals will accomplish in the OR function. Okay, I'll give you ten seconds to look at the single bit design, look at where the controls are connected. And remember you need them OR operation. And 543210. Here is the results. Majority likes the Option B. Let see if option B is indeed the happy option. So let's take a look at this. Oops, sorry. So again, we're looking for an or. This is our OR gate. So we would want the operation to be equal to one. This means it's one of these two answers. And the inputs to the OR gate, one of the inputs is a over here. The other input to the OR gate comes from down here. So here it becomes important whether we get b or b naught. In order to get B, we want b invert, which is this signal here, to be a logic 0. This is live B option is the happy option. So congratulations majority. Notice that here CAN totally doesn't matter. We just don't care about it. It can be whatever it wants to be. Gay. But went on to the next question. Now I would like to implement an ad and hopefully this will be super easy for you since we already did that or oh, wait, we didn't launch the poll. Already. I'm sitting here going, why am I not say get it changes. Thank you. Let's will happen. So, so out my window I see this beautiful green hell palm trees and blue skies. I've been day-dreaming a little sorry. And hoping that the weather hope for this weekend so I can get the help for a nice hike. And it's nice that it actually rain that. Hopefully in a few weeks, the desert tool stirred blooming. Love going out to the desert when the bloom is on. It's incredible to see. Ok. Now I get much better results. Thank you. Let's give it a few more seconds. 543210. Here you go. Majority says answer D is correct. So let's see. I agree. So here we're trying to implement an ad. To do an ad, we're definitely going to go down here. Total hour per h. And these two model, it turns out that all of the total operation to, so that's not terribly illuminating. The other aspect of this is that if we're adding carrion should be a 0. Well, there are two situations in which carry in is a 0, so it's either a or B. And the last pieces, if we're adding, we want B to come into the other. We do not want B naught. So that means that B inverse has to be a 0. So B is a 0 over here, which means that d is the happy answer. So great work everybody moving forward. And to now hopefully I'll figure out how to relaunch the bowl. And so here is the new bowl. Now, I would like to implement a subtraction. So how do I subtract? Okay, 543210. And I think you guys are totally getting this great work. Majority says, See, I'm pretty sure that the right answer was c, But let's take a look at it just to be sure. Oops, sorry. So again, it's subtraction. In this case to do subtraction, I know that I'm gonna do adder, so the operation is two, which again isn't too helpful. But they know that carrier has to be equal to one in order to do two's complement for subtraction. So that means it's one of these two results. And secondly, we know that we would like to do be not so b invert also has to be a one. So that actually narrows it down to this option here. So great work majority. You guys are doing pretty incredibly well today. Okay, so now that we have done a great job of analyzing a 32-bit ALU and various op codes we can provide to it. Let's look at how we would go about designing email you. And this is pretty typical of what you might get in a homework or may be in the exam. So what I'll do is I'll start. I would normally give you a truth table and I would ask you to actually design the ALU using circuits. So I'm going to go through this example starting with a truth table and I'll show you how I would think about how to approach this kind of design problem. What I always do is I first look for arithmetic functions. And in this example I have two arithmatic functions. I have add and subtract. And then I would look at the op codes for those two. And I'm going to realize that the two least significant bits aren't exactly the same for both add and subtract the only differences in the most significant bit. So I know that four subtract this most significant bits should be used for carry in to the lowest stage. And it should also be used to generate the opposite of b. It shouldn't be controlling the multiplexer, okay. I look at my logic function, and in my logic functions here I haven't, And this is my or no. Notice that again here I have an n, but with not B. And here I have an OR but would not be. The interesting thing is that these differ only by the first bit. Again, the other two bits are the same between the two ends. The same thing happens over here for the, or. The two least significant bits of the opcode. They're the same for Dior. Their products isn't the most significant bit. So this gives me a hint that to generate not B, which I need all of these three cases I'm going to need be not. I'm gonna use a multiplexer which is controlled by the F2 control. So this is exactly what you see over here. This F2 control controls the multiplexer, which will tell me if I'm going to pass a b out to the output, or I'm going to pass B naught to the output. Ok? So that is how I determine that. The next thing I'm gonna do is I'm going to look at how I generate the final output, the output y. Whoops, sorry. I just go back to my original. Sorry. I kind of messed up a little here. Okay. I'm going to have to restart the sharing, so bear with me a second. We'll get it back that I had I pressed on the control instead of writing on the screen. That was the problem. Let me get that all fixed up. And unfortunately, it's not the simple is I would hope. But here we are. We didn't lose much other than a few minutes of time. So basically what I want to see is first how to generate this output Y. And I do that by looking at how do I distinguish. Fine, I'm doing arithmetic vs, vs logic functions. And that is this last multiplexer. So this multiplexer will represent the combination 00011011. Now, this perfect, perfect. All I say that I didn't use this combination, so here I would probably just leave it open. In this particular case here what I'm showing is how I could possibly also implement the less than operation if I want to. And when I say 0 extend what I mean is that if I have n bits, would have all the zeros except the last output would be a one. If say a is less than b. Okay? So that allows me to always output n-bit output. Even though result of comparison, there's just a single bit. So now going back to my you, you see that my AND gate is going to be connected to combination 00 regardless of whether I'm doing a and B or a and not B or gate is going to be connected to 01. Again, regardless of if I'm doing a or B or a or b not. And then you can see that there's going to be connected to 1-0. And that again corresponds to these two particular combinations. And now I'm ready to connect all of the pieces together. The only part left this connecting F2 as a carry in to the 0th bit. So that is the last part of my design. Ok, any questions on this? Okay, I think we answered all the questions. One question, those wise enough to attach to the other. It's attached in order to provide the carry into the lowest stage because then we can add one when we're trying to subtract. And we're adding one and the lowest stage because the opcode F2 is equal to one for the subtraction. Okay? So if I have no other questions, then I'll give you another example of a problem that has occurred on previous homeworks. This particular example will not occur on an exam because it's a little too complicated for an exam. But if it has occurred on the previous hallmark, and it is basically a problem in which you are giving a socket area circuit. You have to create that table. So in this circuit, I always start with an adder again. And in this case the other one has a little more complex functions. Notice that I have three different options. I have two facts, and I have one add. And you can see that that's what's going on. By the way, these triangles are muck says, this is really an old slide. And there was back when I didn't have a symbol for the max. For the two to one bug strong. Well, so these are all this and you can see that here we're selecting among their friends to inputs whether I'm gonna be adding or subtracting. And here is your carry and selection, which also tells you whether you're going to be dealing with b minus a or a minus b. Ok? So this is connected to the input I1 of the final multiplexer. And you can see that that would be represented by all of these combinations of selector bits. Okay? Now notice that all of those combinations will require that selector to is a 0. So that is why the soul corresponds to input 01. Now notice that the second input over here is a more complicated combination of the selector inputs. And it is for your homework assignment to figure out how I actually map these pieces onto this circuit here. The other piece that's interesting is the second input here. And you can see that this input provides you with an XOR and the movement or ideal or, and so this is effectively your logic functions. This is your arithmetic functions. Okay? And then two, the ground, that was this top row and this here is the logic one or power supply. So that is how I would approach this kind of a problem. Do you guys have any questions on anything I've covered today? We just officially run out of time couple of minutes ago. Or any questions on anything else? Yeah, this ALU design is much more complicated. This is why I would not put that on the exam. It did appear on an old homework. And as I said, it was only there for you to analyze the circuit and come up with a table. Any other questions or comments or concerns that you may have? Professor, I have a quick question about K maps. Yes, go ahead. Sharing. Cool. So my question is that I don't understand that we can create a squares in the corners of the K map, namely like tiles 08210. I'm wondering if you can do the same thing vertically with tiles for 12614. Huh? I don't know the numbers by heart. It, it will be like this center, like two columns. What these columns here certainly could. Okay, let me pull up the slide where I have an empty came up and then I can take a look at this just a sec. I got a bunch of these here with the numbers. Sorry, let me just get that out. So this is where you want to use your cheat sheet. Even the best of us need the cheat sheets for labeling the K maps. Here we go. I just found the great came up and let me get it in a form where I can actually share it. Sorry, this is taking a little while, but it's a little bit of a flu experience there. Okay. Now you're seeing based frame C, Okay? So you said which runs? I was wondering if you can create a square basically like vertically from like four to 12 to 64 will require like for yeah. This yes. Most definitely. Okay. Okay. Yes. So it folds both vertically and horizontally. Okay. Got gotcha. This is OK. This is fine also, right? Yes. With this, this is also possible. Yep. Hello leads to a possible and same thing horizontally, right? Yes, exactly. You can fold along any axis. Thank you for the senior cannot do is diagonals. Diagonals are bad. Cocoa. Any other questions? I had a question for further. Pos, implementation after came up will be zeros instead of ones. Exactly product of sums. You're going to be looking at zeros. Okay, thank you. That's definitely true. Any other questions? Okay. There are no other questions then. Thank you so much. Good luck with finishing up homework up here, mostly done. And I will see you next week. On Tuesday we'll do review. So there is no new material on Tuesday. And on Thursday you'll get the exam. So I will not be holding cloths, but we will be answering private questions on Piazza between nine AM and 10:00 PM. Thanks. Bye. Have a great day.