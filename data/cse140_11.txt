 Will be 0. Hello everybody. Welcome back. It is wonderful to have you. So today I will finish up the sequential circuits. Then I'll do that by going through a pretty detailed example of how to draw a timing diagram for something that consists of couple of flip-flops and gates in between. Now this particular example will not be on the exam, but as a similar version might be on homework, next homework. And also simple or version that doesn't have timing might also appear on the exam. And then after that I'm planning to get started the RTL, but they'll also use RTL is a way to do a little bit of review in preparation for this next exam. Now before I launch into that and answer any questions related to exam, I wanted to touch on a little bit on how does one decide between PhD, masters, versus bachelor's degree. And the reason why I'm bringing this up now is because I often get these questions from students. And actually this morning I was in the middle of interviewing PhD students for positions in my lap. So I thought you may want to know how the process girls. So for PhD, I would say it makes sense to go do that degree if you're really interested in research or if you really want to get a job in academia. Now, I love my job. I think it's the best job ever because I get to work with amazing students such as yourselves. So I would not trade it for anything. I had worked in industry for ten years. I also enjoyed that, but I really fell in love with academia once I came here to UCSD, I would say for getting into a PhD program, the really key pieces, having research papers published, preferably in really good top conferences and journals. And now the obvious question is how do you publish? You know, if you're an undergrad, this may not seem obvious. The best thing you can do is join research theme of any one of the faculty and see a C or a C or other departments and work with their students and learn how to actually do research and go through the process of helping write a paper and then eventually writing your own paper. This, this is very good path because it allows you to see a little bit of what research is like. So that will enable you to see how much you enjoy that kind of process. And also prepares you really well for the PhD should you decide to go in that direction. And it gives you much higher chances of getting into a good PhD program. That haven't said that. I have also accepted students in my group who have industry experience, who don't necessarily have publications. But in that case, I'd look for experience that's very relevant to my particular research. And I look for trying to see that the student is interested in research and would be able to actually pick up those skills pretty easily. Sometimes I will hire students from Bachelor's degree who don't have publications and don't have industry experience, but it is very, very rare. I should also mention that when you go for, when you apply for PhD degree, you can expect to have all the funding that you need to actually finish the degree and you will also be paid. Now the salaries are great, but it's a whole lot better than you having to pay for the degree itself. They become PhD if you're starting it from Bachelor's, takes about five years, usually first year and a half or so is spent getting a master's degree in thinking subclass historian, masters. And after that, you primarily focus on research. I have had students who've got their PhD within three years. I have had students who have taken longer, closer to seven years. It depends on different individuals. Off my students, I've had number go into academia, but large majority actually ends up going into industry. With PhD, you would end up in research labs in industry. You would also get a chance to start up your own company. This is oftentimes done based on whatever work you've done for your PhD. I've had students go into patent law for example. So get a law degree after their PhD and become a lawyer. I've had students go into management either after PhD or after bachelors, masters. And then I've had students get leadership positions within companies. So PhD degrees, you'll often find people at a director level or higher. For example, when I was an Altera, our vice president of engineering was a PhD degree holder. Our director also had a PhD in engineering. Now, that kind of hopefully hovers topic of PhDs. I would say master's degree is the best degree to have in engineering if you're gonna go to industry, because it gives you the largest selection of jobs and I would say more interesting jobs than a bachelor's degree. What? It also gives you a higher starting salary. And in at UCSD, you really have a nice opportunity to apply for a five-year BS MS program. And I would strongly encourage anybody who qualifies to apply because for relatively low cost of just a single additional year. Going to get a master's degree, which is go to pay off handsomely the rest of your career in industry. So I would say if you know for sure you don't want to do research and you're not interested in PhD. I would definitely go for a Masters degree. Bachelor's. You can still get good jobs as you know. You just won't have as big of a selection and you won't have as much flexibility when you go into companies. And so that's kind of my high level summary. Do you guys have any questions on anything related to what I talked about, PhD, masters, or bachelor's. I'm happy to answer now or if you like, feel free to send me an email or meet up with me. So what are some of the positions that you can get with masters that you can't get with bachelor's generally, those positions involve a little higher level of responsibility. So when I was at Altera, What I saw is people with master's degrees would get better positions in Design Engineering department. So there would be responsible for, for example, leading design of one of the new chips or leading a definition and architecture of pieces of software that might be design versus a bachelor student, might be initially placed in testing Department, or might be reporting to a student that has a master's degree. So you tend to have a little bit more control over the type of work you get. A little bit wider selection of positions. The BS, MS program, I believe really primarily looks at your grade point average. So I think it's actually easier to get into than if you were to apply as an outside student into our traditional master's program. So I think, oh, I should also mention that students with master's degree, especially those that did a little bit of research, can also get jobs in research labs. So I, when I was at HP Labs, about almost 70% of people in the lab had master's degree, did not have a PhD. Now, the letter p, those with PhD tended to be the leaders of the groups intended to really have a much higher say in what direction HP Labs should take for research. But certainly a master's degree. You can get a position in a research lab in industry as well. Any other questions? Okay. What about postdoc? That's a great question and I would say so it depends a lot on the area in, in, in computer science or electrical engineering. My experience with my students and my students tend to be oriented toward computer architecture, embedded system design, circuit design. So span from electrical engineering, computer science background. None of them needed a postdoc to do get really good industry and academic positions. So there was no neat, they went directly. Now for students who are more on the theory side. So if you're doing machine learning theory, if you're doing crypto theory. Anything that's a little bit more theoretical, students have gone into post-docs. It varies, like the length of the postdoc. The more theoretical you aren't, the longer the postdoc before you get a good position in academia, the more practically or degrees meaning, the closer to actual design of systems, the less of a need for postdoc Pepsi, generally you would go for a postdoc if you either don't have quite enough publications or you got a degree from an institution that isn't as good as the institution you would like to go. You know, you would like to. So for example, somebody that had gone to a second thier PhD will want to get a postdoc at the top tier institution before looking for a top tier academic position. Okay. Do you have a gap here before masters? Yes, you can, by all means very possible. It's been done. I have done it myself. I had actually a four-year gap. Now what I recommended, I would not recommend that because you forget a lot and you also get used to a completely different lifestyle. So going back to school, it's very difficult to motivate yourself. So if all the people that I knew in my year at Stanford who had the gap between masters and PhD. All of them said that they wish that they had not had the gap and many never made it back into PhD. So if you're interested in PhD and you know that this is something you want to, you should probably go straight. That would be my recommendation. Any other questions? Let me get started. So let's see. I already talked about where we are today. The stuff that's going to appear on exam is everything except for the timing. So this and stuff that was before and stopped before, obviously you need to know because otherwise you can't design anything in finite state machines. What comes next? I'm going to give you an example of a timing problem and I will get started with register transfer level design. Homework number four is due today. It is due at midnight. You can turn it in one day late, but it will cost you 10% of the grade. We will not assign homework five today. We're going to assign it next Thursday. And that is because you have an exam on Thursday. So I want to give you some time to review and to get ready for the exam. Next week on Tuesday, I'm going to go through a bunch of examples from previous exams and next week on Wednesday, the TA is going to cover previous year's exam and we'll answer any questions and give some more problems in preparation for the next exam. The next exam will have exactly the same format as the last one. The primary difference is and how we handle the submission and downloading of exam. Again, you're going to have 24-hour period. The exam is going to start at nine AM on Thursday next week, and you will have until nine AM on Friday to take it. The exam will be designed to take 60 minutes. It'll be a 110 points for problems we have. In the process of finishing the design of the problems, it should be slightly easier than the last exam. Again, I'm kind of aiming for at least 75% average in the class. If the average is lower, I will again curve the exam. The exam you will download from great scope. Again, it will be for different problems, some great scope. Make sure that you look at both pages if there is more than one page in PDF or for your problem. And you will submit the exam onto the grade scope. Now we looked at the statistics of how long it took people to download and upload. Everybody was pretty much done with 1015 minute tolerance. Actually everybody was done within about ten minutes. So we decided to give you a 15 minute grace period. In addition to the 60 minutes to handle the download and upload, what I would suggest you do is download the exam. So pretend 60 Minutes uploaded immediately, whatever you have and then if you have additional time by all means, try to review it and upload again. Now having said that, if you are beyond 15 minutes, between 1520 minutes, you will lose half of the grade on your exam. And above it, 20 minutes, you will lose 80% of the grade on the exam. And the other thing that I want to remind you of is that we will hub will move office hours next week from thursday to Wednesday because on Thursday, obviously you have the whole day for the exam. And on Thursday, bubble hole will put piazza in private mode only. And we've all have TAs and Tutors dedicated to monitoring Piazza between nine AM and 10:00 PM on Thursday. After 10:00 PM on Thursday, we will not guarantee that anybody will monitor Piazza posts. We might, but there is no guarantee. So I want to advise you to take your exam between nine AM to 10:00 PM on Thursday. Ok. Any questions on anything on here or anything related to exam? Okay. I have no questions. I'm going to get started on my example problem. The first piece of an example problem actually is defining that time period. This time period corresponds to 200 picoseconds. Now let's assume that the clock edge does not occur here. Can I just to keep it simple, Notice that the clock period is right here, that is 200 picoseconds. That means that each one of these gradations IS 50 picoseconds. Ok? The other thing to note is that each flip-flop has a delay. 50 picoseconds. Notice that these are rising edge flip-flops because I don't have a bubble in front of the clock. The other big thing is notice that I have set up and hold time of ten picoseconds. So this means that on every rising edge, I'm going to have to look at a little time before and a little time after. And make sure that my inputs to the flip-flops are stable around that the rising edge. Now again, assume no rising edge, no edge here. Just for the simplicity, okay? Okay. The next thing, NOT gate is 25 picoseconds, NOR gate is 50 and, OR gate this 75. Notice that here I'm assuming that the minimum and maximum, so min and max are the same. I did that to make life easier because it will really be a pain to not think about them to have to draw this for both minimum and maximum delay. Okay? And now it also does make sense that the OR gate would be 75 picoseconds because OR gate is built out of a NOR gate and an inverter. And if NOR gate this 50 and inverter is 25, then OR gate makes sense to have 75 picoseconds. These slides should be on the website and also on canvas. Okay, so now that I've done this, we're ready to start drawing. Now notice here that I have x input already drawn. This IPA has kind of triangle waveform, so there is some amount of time that it takes for it to get to a logic one. And this is fairly realistic impact. Real waveforms look like this. They're more analog. Normally you would never see in actual circuit something that looks like this. We just draw the straight the edges to make your life a little bit easier. Ok, the other thing that I want to notice that we're starting with S one equal to one, x2 equal to 0, S3 equal to 0 is four equal to 0 and y equal to 0. So that means that D flip-flop one has 0 stored and b flip-flop two has also 0 stored in there. Okay? So that's just our initial condition. Notice that the S1 is right, that the input of D1. Notice that test2 is actually our Q1 output. S3 is input to the two right over here. And as for, as our Q2 output, okay? Okay. The next thing that you should notice is that S1 is essentially right after this little inverter. So we're going to look at 25 picoseconds after exchanges. So x changes right after this grid element, which means that as to what change 25 picoseconds later, which is right over here. So fs one started as a one. Will drop down to a 0 right here. It would remain as 0 all the way up to here. And this is again 25, because seconds later. And now it would be at the one end, it would go as a one. And again it will drop down to 0. And now again we go back up to a one and we dropped to 0. And then we stay as Zara go back up to one, stay u1, drop to 0, and then go back to one. And here we are. Okay. The last one is a one. Does this look, does everybody on board with this so far? Okay. The next thing is, we're going to look at S2. So S two is whatever Q1 is going to load at the rising edge. So here we already dealt with S2. S2 is 0, so I'm just going to draw 0 up to the rising edge. I have 1234 rising edges for which I need to look. Now remember I have to look at set up and hold time around the rising edge. So here I drew clock as a squared to make my life easy. I drew x with these funny lines because I'm about to talk about whole time violation. And that is also why I drew s1 using these little triangles. But very shortly with us to, I'm going to stick with straight edges because my life is a lot easier that way. Ok, so let me first get to this point of the rising clock edge. Once we're in a rising clock edge on the D flip-flop, number one, we know that this Flip-flop takes 50 seconds to move the data from input d one to the output Q1. So that means the sooner we're going to have any change would pay 50 seconds later after that rising edge. Ok? So remember that the change won't happen 50 seconds after the rising edge. Okay? Now I'm going to look at what is my input to this flip-flop. So what is D one equal to? Add this rising edge? And what I see as a problem, but I see is that the one is stable right before the rising edge. It stable at a 0 setup time is not violated, but it changes right during the whole violation. So here's Mike hold violation. Okay. This whole violation means that my whatever I love then will be next because I just don't know what actually will happen when I violate the whole time. So as to are Q1 is going to remain as 0 up to this point. And then I'll go into an x state all the way until the next edge, which happens right here, get. Now, this tells me that I would like to set up effects hold violation. How would I fix this hold violations? What would I need to do to make it better? So this is important for you to know for the next homework or exam or Tom would do is I will just put a buffer in here. And then we'll delay the time at which S1 changes, which means that they would have d1 stable for a little bit longer and that would fix the whole violation. Okay, let's move back to where we are right now. We have not fixed the violation. So to fix it, you just stay there, add a buffer. That's the answer. But for this drawing, I'm going to assume that it was not fixed. So now I'm back at this next stage and ask myself, what is my S2 at this edge? And you can see here that this too is stable because it has changed 25 nanoseconds before that rising edge. So setup was not violated because remember setup time is just 1010 picoseconds and hold time is also ten picoseconds. That's not violated because my S1 is stable after the rising clock edge. So at this point, because S one is one, I would have to go to one and it will remain one up to the next rising clock edge. And then 50 picoseconds later. At that point again, I ask myself what is my S1 or D1 input? And I see that it's a 0 and in fact it's stable around the set up and hold constraints. So now I can go down to 0 and remain at 0 again, up to 50 nanoseconds, picoseconds after the rising clock edge. Again and look at what is my value of d1 at the input. The rising edge, turns out it stable for setup and hold time. So now this goes back to one and it remains at one until the end. Okay? If I add the buffer, it will completely change the waveform. That is correct. And I'm not going to draw the waveform today. You guys can do that for homework, but it would get rid of the problem with the whole time violation. So what I'm going to do today is I will just draw the waveform assuming there is no buffer. Okay? Alright. Now notice I have s1 and I have S two. Now I can generate my S3, but be careful with the 50 because second delay, so S three is going to change every time I have 50 picosecond delay. Now to remind myself, like to remind myself what does NOR gate due? So if I have 00011011 OR gate would have given me one output every time one of them is one, but NOR gate two is going to get 0 out, but unless both of them are 0. So I'm going to be really interested in looking at when both of these, S1 and S2 are 0. And notice that that happens during this time here. This is when both are 0, right? And I have also a little piece here. When both are 0. The rest of the time, at least one of them is a one. So I know when at least one of them is a one, then the output is going to be a one. And I'm not gonna, I'm sorry, at the output is going to be a 0. And I don't really care what the other input this. So this is really important because this basically tells me what happens with the don't cares as well. So at first we started out with this three being a 0 and S3 is going to be a 0 until we reach a situation in which both of them are 0. Now notice that neither happens right here at the, at the middle of this particular period. Now because my NOR gate has delay of 50, any change will happen 50 picoseconds later. And what is that change? That change is going to be going up to a logic one. And it's going to remain a logic one until again, 50 picoseconds after the next change. That makes change happens right here. So I'm going to go here and I'm going to drop down to 0. Ok? I dropped down to 0 because my S one goes to a logic one and that causes me to drop down to 0. So now I'm gonna remain at 0 up until I get at least one of them, one of the input 0. So here I have logic 0 input. But that actually will not affect anything. So at this point, what's going to happen is I am going to look at the situation where I have this logic one. In this logic one is going to cause the output to be a 0 regardless of the don't cares, because the logic one dominates AND, OR NOR gate. Right? Now when I have a logic 0, which is during this period, in that case, the output is whatever D out. But other input this, and in that case I'm going to see the don't cares. So notice that my S1 MPA drops to 0, right? 50 nanoseconds after this edge. So it is at this point that those start getting don't cares. These don't cares are gonna happen only as long as I have a situation in which my other input, this one is not one. So this thing will go to one right at this rising edge, right over here. So at 25 nanoseconds, so basically at 50 nanoseconds later, which is right over here, I go back to our logic 0. So that would be a logic 0. I'm going to remain at the logic 0 until 50 nanoseconds after this particular change happens. So that's going to be here and I'm going to go back up to a logic one. Stay the logic one for 25 nanoseconds because this happened in the middle. And then go back to a logic 0 all the way until the end. Ok. Any questions about this one? Is everybody okay with the way that the S2 and S3, S3 is obviously our input to the next flip-flop, d2. Okay? Sorry, there are no questions. I'm going to move on to my next Flip-flop. Now remember again that this output changes 50 nanoseconds after the rising clock edge. So I'm going to look at whatever is my S3, which is the same as d2 and the rising clock edge. And then I'm going to change to that 50 nanoseconds later, but they need to make sure that's set up and hold constraints are met, which they are in the case of the first pricing blockage. So now I'm going to stay at the logic one until the next rising clock edge. Now notice here that this rising clock edge, I have a problem. I have a situation in which I have don't cares. So this means that this clock edge up though, next clock edge and then 50 nanoseconds later, I'm going to have bunch of don't cares coming out because my input was a don't care right at the rising clock edge. Okay? Now we move to the next rising clock edge. And I see here that my d2 or S3 is a 0 and it stable for setup and hold type. So that means that now I can go to a 0 and I stay but until the next edge. Now on the next page again, my S3 or D2 is stable and is a 0 around the clock edge so I can remain stable and a 0 argument. Okay? So everybody hopefully so far. Ok. Now we make it to S3 has a delay of 50 picoseconds. So this NOR gate is 50 picoseconds. But you also have 50 picoseconds delay of getting through the flip-flop. So that is what may cause the overall delay from S3 changing to the actual output of flip-flop will end up being 100 picoseconds. Hopefully that answered that question. Okay, so I'm going to move on to y. Notice that this will change 75 picoseconds after S3 and S4 change. Now, OR gate is going to give me a logic one unless both S3 and S4 are 0. So as long as one of them is a one, this will give me. And if one of the inputs is one, the output will be one. Otherwise it's whatever the other input this. So here, up to here, I'm in a situation where both are 0 and this 0 is going to be 075. Pico seconds later because he types that long for the output to change after S3 or as for change. So in this example, S3 changed from 0 to a one. So now y is going to be a logic one. And it'll remain a logic one for sure until it's at least here, which is 75 picoseconds later. But notice at this point, S4 is a logic one, so we stay in a logic one all the way until S4 goes to, don't care, and S3 is a 0. And it's going to do this for 75 picoseconds. So it goes all the way to here. At this point, we have a situation in which IS three's a 0, but thus far is a don't care. So in this case, don't cares are going to dominate up until we get this blip off one, there's, the reason why one dominates in the or gate is because it's long and it's one of the inputs is a one you're going to end up with a one out. Because of the way the OR gate, this design that the transistor level. So what will happen here is this will dominate with the logic one, but it's going to happen 75 picoseconds later. So you will effectively have, don't care, so up to here, and then you have this blip that occurs. So this is where the don't cares happen. All the way up to this edge right here. And then it goes to a logic one. It stays or the logic one for very little bit of time. And then because both inputs are 0, you will go to 0 and remains 0. Okay. Any questions on this one? Or would it stay as illogical for 75 seconds? It would stay is logic one only as long as the logic one, but it ship it by 75 picoseconds. Ok. Ok. Good question. So we have, let's see, is there is 0 between exists, there might be a 0. Oh yeah, you're right. There is this piece where we have a 0 that I forgot to draw. So let me see. I should then. Thank you for catching that. So that again is going to be 75 picoseconds later. So it will be halfway through this. So basically this is what it would look like. Thanks for catching that. Okay. Any other questions or comments? Hopefully, I didn't forget anything else. Now remember our transistors. Remember that NOT gate, these two transistors NOR gate is going to be four transistors or gate there's going to be six transistors. And remembered that minimum delay in, for example, NOR gate is different than maximum delay. And that's a function of how transistors are oriented, but then the gate, okay? But in this problem we decided to simplify because it really would have been a pain to draw this with minimum and maximum delays. I gave. I don't have any questions on this. I'm going to move on to high level state machines. High level state machine, that is called that because it allows us to express a little more complex values as compared to what we can do with finite state machines. So here's a nice example, and this example, excuse me, in this example, I have a soda dispenser and the soda, this Spencer actually has single bit input that detects a coin that was dropped. So this is one bit, a single bit output that basically left the gate. Then let's me get to my soda. But these guys are eight bits. And notice as 8-bit inputs that this something that we normally don't have in our normal finite-state machine. You can think of them as eight bit integer or 8-bit binary value. And what happens in this soda machine is we can program it to how much the soda costs. So in this example, I've programmed it so that the soda costs exactly 50 tons. This is since cost. And now I can see how it actually runs as I dropped my coin. So if I drop a quarter in my coin detector, well, signal one because it has detected that there's a coin then, and it has decoded that coin. It knows that it's $0.25. And at this point, it updates. It has to update its knowledge of what is inside the machine, how much money I've dropped. So what it does is it stores this either register value called total. And it basically says I now have $0.25 stored, but that's not quite enough yet in order for me to give you soda, right? This is less than the cost of the soda machine. So it's not going to open up the output. The output will remain at 0. The next step is going to be to see whether you dropping another coin. And sure enough, since you're motivated to get your soda, you drop another quarter. And this quarter is detected by my coin detector. It's decode it. We know that there is additional 25 sets. This additional 25 senses add that. Now notice that here we are going to do total plus whatever they say is, this is an add function. And now we have updated the total value. Now we do a comparison and we see that in fact, it is the same as the cost of the soda machine. So in this case, we want to give output 01 because you deserve your soda, you've just paid enough, right? We could have also provided the change output. This change output would be 8-bit, Not one bit. Because presumably if we had dropped $0.25 and then $0.10 and then dropped a quarter. We would've wanted to output $0.10 as the change to you. Got any questions on this? Okay? So looking at this, we clearly have a little bit more complex types of data that are at play. So let me see what you guys think about what makes this design their friend and more difficult. Then the standard finite state machine design. So is it the fact that we now have more complex data? We have 8-bit input and output. Isn't the fact that we have to track whatever the current total is, is it that we have multi-bit comparison between total and so that is a total debuff or perhaps none of the above. So what makes the FSM design of this problem more difficult here? Okay, I'm going to give you ten seconds. And 543210. And let me share results. I think you guys did a great job. We all figured out that it is in fact a combination. It is that we have 8-bit input and output that would make FSM design more complicated. Also, the fact that you now have to have a whole register that tracks the total and that has to be updated using addition operation. But you need the multi-bit comparison in order to figure out if the total is matching equal to or greater than the amount that the soda costs. So you guys are majority is correct. The correct answer is in fact, all of the above. So let's look at what are some of the benefits of high level state machine. So here, the high-level state machine extends the normal finite state machine with the ability to express the multi-bit over so larger size inputs and also outputs. Now in this case, I then show larger size output, but it kind of added change. For example, in this what I've been then a larger size output you would've had changed. That is an 8-bit function, right? You could still have your standard one bit inputs and outputs. And here is an example of a single bit input and output that now we have also local storage, which in your Verilog would be declared as register style storage. And notice that you've got more complex operations here. So here you have an addition. Here you have compare. Okay? So for my convention way with Express single bit numbers with single quotes, integers with no quotes, multi-bit with double quotes. For ECL comparison that we would use two equal signs and multi-bit outputs would have to be registered beer local storage. So this is pretty standard convention for coding in verilog or any other register transfer level language, okay? So we also here is an example of a comment. So this is an example one of the common might look like that. Ok. So getting back to our happy pulls, the question is how this high level state machine differ from the finite state machine that you may design for this problem. So what is the difference between the two? Okay, I'll give you 543210. And here the results majority likes answer A, which is that high level state machine stores multi-bit date up, but finite-state machine does not. And that is actually definitely true. Let's see if any other answers are true. So let's see what happens with answer B. So we know already that a is, oops, sorry. That day is definitely correct. B answer says that finite state machine stores the state, but high levels tape machine doesn't. That is definitely not true. It is true that finite state machine store state, but it is not true that high level stick machine doesn't. In fact, you see that here we have state. So you have to be able to store that state. Obviously, implementing high level state machine and finite state machine requires multi-bit. This is the key data registers. Finite state machines do not require data registers. They require state registers, right? So if I am worn on the single bet where I store state, then I have a state register, which is a multi-bit register. High level state machine does require all often multi-bit data. So this is not true simply because finite state machines do not require multibeam data registers, which means that these not true and he is not true and a is the happy answer. Okay, thanks guys. Good job. And moving on, the question is what are the similarities between the high level state machine and the finite state machine? So here is the new poll. Ooh. 543210. Here is how things look like. Majority likes answer a, but I actually am very close. Second would be answer C. So let's see what makes sense. First of all, I answer a says the transitions happen at the edge of the clock. That is definitely true. And that is true whether you do high level state machine, our finite state machine, because you're going to use flip-flops to store your data. And they can happen either the rising edge or the falling edge depending on what kind of flip-flop you're using. But they're definitely on an edge. So that is definitely true. B says they both have external complex data. It is definitely true that high level state machine has complex data. It is not true that finite state machine has, so this is then not true, which means that C is not true. This is not true because a is correct. Ok, any questions on this? We would like to get started with register transfer level design process. Rtl stands for register transfer level. And the reason why it's called register transfer level is because you would have some sort of register, so say state register and maybe some other registers. And you have some logic which essentially load the data into those registers. And we'll take data from those registers to generate the next state and perhaps some outputs as well. So you're continually moving data into the registers. Taking data out of the register is computing something and moving data n. Now notice that this process matches exactly how your processor works. And in fact, when we think about the processor and also register transfer level design, we often think about these two different components, the controller component than the data component. The controller component would implement the finite state machine and a state register. And it would use simple control inputs and any control inputs and outputs that relate that connect controller and the data path. All of these would be one bit. In contrast to that, you would have potentially complex external inputs and outputs into datapath. So datapath would have components such as ALU type components or registers in which you store intermediate data, or maybe even the whole memory that you may score. So if I'm thinking about this as my, my processor design, then the finite state machine would implement the control of how you fetch an instruction. How you would control the decode process of the instruction. It would control how that instruction is analyzed in datapath. It would control the operation that happens. So it would activate the ALU controls needed to make that operation happen. It would also return the result of whatever ALU has done, either into the register or it would store it into the memory. So basically the controller would control all of those operations. And then he would move on to the next instruction. And for that, it would also need to use datapath to calculate the address of the next instruction and then initiate the fetch of the instruction from memory. So effectively what we are going to be doing starting today is we're going to be designing systems that can be split into the controller component and the data path component. And then we'll design each of those components. The material we have covered up until now prepares you to actually take the components you already know. So you already know how to do finite state machines. You already have information about all of the possible datapath components that we may do. The only exception to that is memory. And I won't cover that a little bit later. So you're basically ready to put these pieces together and design a little bit more complex design. And what we'll do in the next set of slides is we're gonna start with, start with a relatively simple high level state machine. And then we're gonna step through the process of designing both the data path control and connecting those two together so that you can see how you would go from a high level, oftentimes Verilog level description down into the circuit. Now, having said that, today's processors and today's systems are normally designed by starting at Verilog, behavioral level description. And then we use synthesis tools, automated systems to actually map them into gates. Now it turns out, when you do processor design, very large majority, 95% of the processor design will be done using starting higher level description. So high level state machine or verilog style description will be used and automated tools will be used for synthesis. But there is still a small percentage that's actually done by hand. Because it is that part that gets you that extra performance. You need to get really good clock frequency for your processor. And therefore to hopefully get low power, high performance and to kill and the competitors in the marketplace. Ok, so let's revisit our soda dispenser. Remembered that we have a high level state machine. So that actually design of the high level state machine is our first step. This here is H and that is m and h, okay? And it'll look kind of similar. And I just put this high level state machine here to remind you of what we had there. The second thing is to design what we actually need to have in our datapath. So the very first thing that we're going to need to have is a register which is going to store whatever. The current amount of money is, so this is where our register total this. Now notice that here I want to 0 out or I want to clear this register. This is why I have a clear control on it. The second thing I need is I need to update this register after addition happens. And this is what the load signal, this. Now remember when we looked that register, so this register is going to be eight bits because my data is eight bit data here. Okay? What that means is that I'm going to literally have eight D flip-flops, right? All connected together into a single register. And this register, each of these flip-flops is gonna have control. So here's my, here's my Q. I'm going to have a level controller here that is controlled by total load signal. And if total load signal is 0, I'm gonna adjust re, load the same date I had. If total signal is a one, at that point, I want to have a choice of loading the data into my D input. Or I'm going to clear, and this is where I'm going to have total clear signal. Okay? So I've taught a clear he's equal to logic one, then I'm loading as era. If total queries that equal to a logic 0, then I'm learning whatever this oneness, as long as the load is a logic one. If load is a logic 0, then I'm just holding whatever state I had in my register. So in this this you guys should know this is something that can appear on this exam because we covered that during this loss. Since time we had covered the exam number one. Okay. So this is a quick review of it. Okay, so now that we know how total register works, we need to implement the other two pieces in other pieces, addition. So here's my 8-bit adder. Now remember, we talked about different kinds of adders. We talked about the RCA Either. We talked about carry, look ahead adder. So in this example what we would be doing because implemented using either of those two others. And once we get to actual datapath implementation, you, I could ask you what kind of delay do expect given that this is say, RCA or what kind of delay should expect given that this is carry look ahead that those are fair questions, but not on this exam, on the next homework and on the next exam. So bonded, but here is the value of the coin. The other input is whatever I currently have in the total register. So however much money I had dropped, S is the cost of soda. Okay, so my ad or I'm going to take whatever amount you dropped, value of the coin you dropped them. We're going to add it to the total register. And then I want to take whatever I had to edit and I want to load it into my register. So this, these valleys effective will be the inputs into my register so that they will each be input into one of these, the D inputs to the flip-flops, individual flip-flops. Okay, now what about the load tap on the mobile happened? Why aren't the load signal is one and if clear signal is not one, right? Okay. The last piece we have is this comparison. So how do we implement the comparator? This is something that you also have to know for this next exam. How do we implement the comparator? How will I know that total is less than cost of soda? Exactly. I'm going to implement the subtractor. So this is effectively subtractor and I'd look at them as B. So what I'm gonna do is I'm going to say total minus S. Is it less than 0? So this is where I look at the MSB. If it is less than 0, that's going to generate total less than 0 signal because the result will be negative. Otherwise, if this total less than 0 signal is not equal to one, then I know I got a 0 or a, or something that is greater than 0, which means that I deposited enough money and you are lucky, you get your soda out. Notice this is where my soda out happens. Ok. Any questions on this? So far? I'm going to move on to the next stage, which is, what are the signals that we're going to have? If you look at this, I have. And let me relaunch polling pod to end high level state machine on top. I also put in our current data path design. So this here is data path. And what I'm asking you is according to the current design, which are the conditions, does the register output total change and the rising clock edge? So here is my register total. Give that a little bit of a thought, then then we can talk about it. Okay. I'll give you a 543210. Let me share the result. Majority thinks the answer is E, which would mean both C and D. Let's look at. But the answers are, so here. Part day, it says Whenever devalue of coin inserted changes, this would be this value here. So this value will change the output of an ad or for sure, because add there is a combinational logic. So whenever inputs to the other change, the output is going to change. The tonal register doesn't change when a changes. And the reason why doesn't changes because it's controlled by these two signals. It's controlled by load signal. So it isn't until load is equal to one that it could load anything that's this input. Right? So this definitely is not true. B, whenever the cost of soda changes. Notice that cost of soda has nothing to do with the tonal register. It's not even connected to it. So B is definitely not true. C we know is true because we know when total signal goes high, we're gonna load whatever the result of the subtraction this C is true. Then He says, when the signal of a clear becomes high, so if this becomes one, tonal register is going to become 0. So that is definitely true. And that means that answer a is correct. So that is the happy answer. Great work majority. Congratulations. And let's move on to the next slide. So now we want to connect datapath to the controller. Now notice the datapath, how's this one bit signals that actually will either come from the controller. So this is output of controller. And this here is input into controller. Okay? And that is how we connect the two pieces together. Notice that controller also has one bit input and output than it controls. And notice that in this example we have more complex input. And we don't have complex output. What we potentially could have 8-bit change. Just in this current example. I don't have something like that. Okay. So let's move on to the next stop. So here I took the original high level state machine and I use these new signals to replace the complex operations with simple signals. So remember over here, I had before total equals 0. Over here I was doing addition, total equals total plus a. And I now replace that with a single binary value, because now I'm good to go and create the finite state machine over here. So anything that's more complicated should be replaced. But a simple binary control. Over here, I replace it with the result of my comparison. So instead of saying total less than soda, I'm now just using the result. This is that most significant bit of comparison, which is a single binary value here, showing not of that most significant bit. And as I said, this is just a single bit that tells me that total register will be cleared. So this here now is an actual finite state machine. There's nothing complicated about it. So let me ask you a few questions here. First, how many states does my Finite State Machine half? For? That is correct. So this has four states. So my first question to implement this, how many bits do you need? A, one, B, two, C, three, D, None of the above. Okay. This is going to be a well, sorry. Just a second. Let me start a pole and then go backwards just a minute. Wow, I really went there does. Okay. I think I got it. This is the question. Sorry about that. So the question is, in order to implement this finite state machine, how many bits am I going to need to do? I need one for a, B to C is three, and D would be none of the above. So that would presumably mean either 0 or more than three. Okay, I got 543210. Okay? Majority says we need only two bits, which is true if I have four states, all I need is just two bits. So the correct answer is answer B. The other ones are not happy. Okay? Now that I have the finite state machine drawn, my next step would be to create the state table. So step number two, this was my step number one, draw FSM. Step number two is a state table. So this table, I will have current state inputs. Next state outputs, right? And on current state, I will have names of the states. So example would be in it. And then it changes to say wait state on some condition and I would fill that out. Okay. My next question for you is, how many inputs do I have? In my FSM? A says to B, says three. C says 0, D says None of the above. Or depth. At a little bit of thought, I'm gonna launch a poll. Ok, five seconds, 43210. Majority says that the correct answer is a. Let me remember a was two bits in that term, sorry, two inputs. And that turns out to be correct. So the two inputs are, one of them is C over here. So one input, this see, the other input, this total less than, less than S. Those are the two inputs. So those would go under the input column. So I would have combinations such as this in here for those two inputs, okay? And you can kind of guess what my next question is going to be calm. Many outputs. Do I have an answer? A, yes. One answer B is to answer C is three, D is 0, N0 is none of the above. And let me relaunched the pole right here. Okay, so think about how many outputs do we have? This, by the way, is a great example of the type of problem you might have on the exam where you get a finite state machine and you have to take it from the diagram or even from the word description to a diagram to state table and figure out how many bits do you need for the state to figure out how many inputs, how many outputs? And then finally design it. Okay, I got 543210. And here is the result. Majority says three outputs and majority I believe is correct, excellent work. It is three outputs. Let's talk about which outputs may just. Label them. So here are two out of the three and here is the third one. Ok? So it is three outputs. That is the happy case. Okay, so I've done the state table. What is my next step after the state table? And now that I know I have two inputs, three outputs, and I need two bits of the state. So effectively I know that in here, I'm going to have two flip-flops that are going to represent D1 and D0 out there are going to represent the state. There'll be jointly estate register. So what is my next step? In order to implement this finite state machine, I need to figure out how to design the circuit. To design the circuit, I need to go from state table. And instead of having these names of the states, I need what? State assignment? Correct. So that would be my next step after state assignment, what am I going to do? What is my fourth step? Excitation table? Exactly. And your next a patient table, I will have current state. So for example, I may want to do the state assignment very niche state, the 00, wait state is 01 at stake, this 1-0 and dispense state is 11. That would be a great example of what they might do. And in that case, instead of a knit, I would write 0040 inputs. I would still have various combinations like before. But, oops, but now for the next state, I would encode in this example, wait state to 01. Good, I have columns for the outputs, whatever they might be. Those are my three outputs. Ok? And since I don't have space to write that out, I decided to cheat and I put it on this slide. So in this slide you can see that my next state is a sign 0-0. Wake state is assigned 01, AD status designed 1-0 and dispense state this assigned 11. Here, my two inputs. Here is my current state, here's my next state, and here are my three outputs. Okay? Everybody, okay, what's what we have so far? Now you know what the next question would be on an exam. And that is I would want you to implement the logic for the next state and 40 outputs. So for the next state, we already know we're going to have two flip-flops. And in order to figure out what should I be loading in here. So here's my next state, one next state 0. I need some logic which is going to depend on both the current state and the inputs. And inputs where c and this total less than s. Okay? And then I also implement logic for the outputs. So here's my question for you. My question is, how many k maps do I need to design this? A, two, B, three, C, for the five, E, None of the above. And let's do a nice pole. The second, relaunch it. Okay, so the question is, how many k maps do I need to completely designed this finite state machine? In my mind I say completely, I literally mean, I want you to draw all of the circuits to generate all of the outputs and the next state. Okay, I got 543210. And majority says that it is going to need, we're going to need five K maps, which turns out majority is bright. We need 5K maps because we need to for the next state. And we need three for the outputs. It'll be one came up for next state, most significant bit, want for the next tape least significant bit. And then these three to generate the rest. Ok, so the last question, I believe for this, or maybe last question is going to be how many inputs to the K map? To each of these k mapped, a, two, B, three, C for D. None of the above. Let me launch. This should hopefully be super quick. So the question is how many inputs does my K map have? Okay, I got 543210. And here are the results. Majority says answer C, which is four inputs to each K map. And majority is correct. Great work. So you guys did learn. And I'm very happy about that. So four inputs, low, sorry, did not mean to go there. We got four inputs and in fact, what we'll each K map look like. And let me kind of quickly draw what we should expect to see. So we will have something that looks like this. Here. You will have Q1, Q0, which is basically a current state. So these are q one, q 0. And then you will have these two inputs. So C and total less than S. I kind of shortened. And here is the combination 011110. And you're going to have five different sets of input. So this May 1 actually implement next state one, which is basically d one the input to the flip-flop. Then you would have one for next state 0, which is the D input to the flip-flop. And then you have one for just d. You will have what bitches the output rate. Let me write the small one. You will have one for total load and one for the total clear. These are all came maps. Okay. Now, once you have the K maps, what are you going to do? Well, you're going to minimize object can, depending on how many ones or zeros you have, you will choose either sum of products or product of sums. Your goal is going to be one of two fault, either minimum number of gates, in which case you're going to get du net, you're gonna do AND, OR, and NOT gates. So if it's men gates, you will do and or not. If it's men transistors, then you're gonna do NAND. Nor, and not. Okay. Any questions on this. So I assume that this you could solve beginning to end. You would have no issues with this guy. They're not questions. Are there any questions on anything I covered today? Okay. If there are no questions on the slides, I'm gonna stop here. Next time on Tuesday, I will be going through a bunch of examples from previous exams. I will be posting those slides, likely a Monday late, and on Wednesday next week the review session is going to go through both the exam to sample. And it will cover some additional sample questions that are similar to the next exam. And as I said, the exam number two, they tried to make problems a little bit easier. But as I also said that this material is a bit harder. So I would definitely encourage you very strongly to do lots of practice problems, to review all the material that we've covered since exam one, especially. And I would strongly advise you to look at how to do ALU example problems. How to do finite state machines, look over the latches, flip-flops, make sure you understand the differences. Because all of that, this fair game for the exam. I will not put anything on the RTL and I will not put anything on timing. So no set up an old times, no timing of the gates or flip flops, so don't worry about that, but that will occur on the next homework, homework number five, and on the next exam. And does anybody have any other questions? Before I create a big breakout room for one of the students? Can I ask the question on the homework? Yes. By all means, go ahead. So suffer question three on Piazza, the instructors are saying that we are not supposed to have any other input besides the clock and plan is a great question and that is completely incorrect. So, and I actually sent an email right before this class to my TA to fix that. Questions should really look exactly like the homework question. The last question, I think it was slide 28 that you guys were appointed to. Let me get a wrong number and let me share it so I can clarify that again. Sorry for the confusion. Here is what that looks like. So the question was really meant to be similar to this question where you have a singlet but you have four flip-flops. I don't remember if it's four flip-flops in question three. And now you're recognizing a pattern. Now in this slide, the pattern I recognize as 1-0-0 one, in your case, you're recognizing a different pattern, okay? Okay. So can we assume that will be given and a sequence of inputs? And whenever our input is a multiple of six, will output a one. Exactly. That's exactly. Yep. Thank you for clarifying. Yeah. And thank you for reminding me to address this. Sorry, a bumpy. Okay. Any other questions for everybody who's still on the line? Alright. So my office hour next week is still on Monday. I will hold my normal office hour, but we will we will have additional office hours from TAs and Tutors on Wednesday, and that will be posted on Piazza. And what I am going to do next is create the breakout room. Let me create one. Just the seconds. And let me right there. Like that.