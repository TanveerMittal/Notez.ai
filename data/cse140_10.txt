 Hello everybody. Welcome back to class. Glad to see you again. I have some good news for all of you. And news are that we have in fact, just about finished grading the exam number one, that the exam was curved because the average was below 75%. So the results after the curve are the averages. 75, standard deviation is 17, maximum score is a 110, and minimum is 23. The exam will be released later today, just last night, they found an error in one of the probably one of the I think versions of one of the problems. So we're fixing that and that should be done at a minute. Once it is released, you will all have 24-hour regrade period to request regrets for any issues that you see. Solutions, as I said, are posted on Canvas. So feel free to take a look at the solutions and let us know if there are any further issues. And O and B also, I also looked that what happened, that various technical issues that had come up and it turned out that most people that had some technical issues related to upload were able to get everything done within 15 minutes of the end of the exam. So the plan for exam two is that the exam would still be 60 minutes, it would still be 110 points for questions. You would have to submit it still upgrade scope. So same set up as this last time, but you will have 15 minute period after the 60 minute end of exam two uploaded and turn it in. So that should hopefully deal with any technical issues that people may have. If you are more than 15 minutes late but less than 20 minutes, your exam will be worth 50% of the overall grade. And if you're more than 20 minutes late, you will lose 80% of the score. So as I said this last time, it seemed that everybody was able to upload but 10-15 minutes except for maybe one or two people. And those issues we're dealing with, are there any questions regarding exam one or anything regarding exam two that's coming up next week. So the exam will still be on canvas. So the problems will be provided on canvas. You'll need to download them and you'll need to turn it in on great scope. So you download on canvas, you upload them. Great scope that unfortunately we cannot do it. Just don't grade scope. It's just a little too complicated to create all the versions. The question I'm, Could you get five minutes to download the problems? This 15 minutes that you half gives you the flexibility to spend time downloading if you need to and uploading. So basically, the exam will be designed to last exactly 60 minutes. It shouldn't take you longer than 16 minutes. You have on top of that extra 15 minutes to deal with download and upload issues. Okay. Any other questions? Okay. So just to remind your homework number four is due this Thursday. What we're covering is little more finite state machines. I'll go through a detailed example today and I'll cover timing that basically will finish the sequential section of this class. And after this, we're going to move into the register transfer level design, which is the last big section of the class. So once we've covered is memory slouches, flip-flops, registers, counters, and design problems with counters and finite state machines. So let me get started. A problem that I would like to walk through with you today is a design problem where your job is to design a super vending machine where candy costs only 15 sentence. So you're very lucky, it's a really cheap wending mushy you. The negative of the machine is it only takes nickels and dimes. And on top of all this, it gives you no change. So this is simply to keep things a little bit easier to have less states. So again, $0.50, where can they only nickels and dimes and no change. Now in this example, we're going to first step through designing this machine using the more finite state machine approach, where output is associated with state only, output is not a function of the input. And then I approach these design problems. I always start with the initial state. In this example in my bending machine, my initial state is a state in which there is no money. So that's why the initial state would be called a state of $0.00. And the output in that state there's going to be 0 because I'm going to give you, gave me for free right? Now notice that here I have nickel input and dime input. And I have also this funny reset signal, which basically tells me that reset is going to be used only when I'm either starting up. So this is at startup that I'm gonna reset everything and set all the flip-flops to Zara. Or I'm going to reset after I have given youth candy. The rest of the time, recent really doesn't play a role. So I'm going to focus primarily on my two inputs, nickel and dime. Notice that also this is my initial entry point into the finite state machine. So I start by pressing a recent button. And basically at that point, nobody can input in nickels and dimes. So that's why nickel and dime are primed. And that gets me to my state where there's 0 money in the machine. If I don't put any money in, I'm gonna spill. Stay in a state where I have 0 money. So, so far so good. If I put the McCullin, I'm going to move into a state in which I have $0.05, but five zones is not enough. So I'm going to output the zeros still. And in that state, if I don't have that anymore money, I'll still stay in a state where I have $0.05 hopefully waiting for somebody to drop some more money. And on the other hand, if I input then the dime, I'm going to enter into a state in which I have ten sentence and I still produce a 0 output because again, I don't have enough money. I can't really give you any candy yet. If I don't add any more money, I'm going to stay in this state of ten sense until more money arrives. More money can arrive in two forms. One, we already talked about, and that is if a dime is dropped when I'm in a state with $0.00. The other is if I drop a nickel when I'm in a state of $0.05. At that point, I'm going to go into again Tencent stake, but still not enough money. So the output is still 0. Now that doesn't mean $0.10 state. I can transition into the $0.15 regardless of whether I get nickel or a dime. So this is where it matters that there is no change. Because if I add the dime, I will have put in $0.20 by the machine is not going to know this, it's not going to care. It'll just keep your dime. On the bright side, you will get your candy out. The candidate will be given out because the output, either $0.15 state is a logic one. Now notice that this candy they will stay, will be provided and it's going to wait for the reset signal to be, to turn to one. So it was designed so that if I have a vending machine that has a hole and I have the gate that has to be opened. The reset signal will turn to one when the gate is all the way out. That basically tells us that you fetched your candy. And now I can go back to the 0-10 state and try to wait for the next person to come along and dropped in money. Okay, so that's the function of the reset. Again, this is very simplified from the real vending machine, but honestly it's not that far from how the actual controller would be designed. Any questions on this? Notice I forgot this particular edge, right? If I start in 510 steak and I add the dime, I end up in a certain state. And again, I provide you with the output. Okay? Now that we've looked at more state machine, and again, you can see that it is more by noticing that we have the output as a function of only the current state. So I have a question on whether real vending machine would carry over if you either diamond the tents and state. And so if I had that in a real vending machine, what would happen is you will get change. There would be an additional output which is change. In this case, I didn't bother with additional output because additional output would get more complicated. You will have to be able to handle both 105 change, which means more K maps which get super busy on slides. So for right now, no change. Okay, moving on to the mealy machine. Notice it merely output is associated with transitions. So you would have input slash output on an edge. Ok? So here, same story, I start than zeros on state. Notice that here outputs are associated with the transition sooner. If I'm in 0-10 state, then nobody put money in. But the output is going to be a 0 and I'll stay back in zeros and state. If somebody puts a Nicola and I get 2510 state, but the output is a 0. If somebody puts a diamond, I get to attend said state, but output is still a zara. If now I go out of a nickel state, a dime is dropped. Output is a one because now I have enough money. Same thing happens out of a 5-10 state. Whether I get sorry, same thing happens out of ten said state. If I get either a nickel or a dime. So this is my no change situation. Okay? All the rest of the situations, my outputs are going to stay a 0 because I don't have enough money. So in this case over here, I'm transitioning from state to state and outputting a 0. Notice that in the fifth intense state, and I'm gonna keep output of 01 as long as reset is not equal to one. The moment that reset is equal to one, output is going to be a 0 and I'm back into my state 0. And I have an excellent question. And this is a question if I, if I input both nickel and a dime, so if Nicol equal dime, equal one at the same time, that is a don't care state. Because it's impossible. You cannot drop two coins at the same time into this machine. So it will never happen. And why his nickel plus dime in the tents and state when b add either nickel or dime. So this is or why that, does that say to signify no change because if I add a dime, I have $0.20 in the machine. But I'm registering only $0.15. I'm not and I'm not giving you a change. So this is what I mean that this is where this idea of no change applies. Okay. Any other questions about this? All right, I'm going to move on to the next slide. Here. I'm going to focus first just on the Moore machine. So the first step we already dead embed is draw a state diagram. What is my second step that I should do? Excitation table is going to happen a little later. The second step is a state table. So for present state here I would say 0-10 state. What is my next state if I have input 00 and what's going to be my next state? Also, $0.00, right? If I drop a nickel, what is my next state? It should be out 5-10 state. If I drop a dime, what is my next state? Then said state exactly what I've been saying. Both nickel and a dime or one. Don't care precisely. Notice that the output is a 0 in all of these states until I get to $0.15 state. So I'm not going to worry about this. I can just put zeros. Okay. So far so good. The next state is my 5-10 state. And if I'm in get 00, I'll still be in my 5-10 state. If I get the nickel, what state them I got to be in. But then sudden state, exactly. Again a dime, which state them I gotta go to $0.15 state. And the last one is a don't care. And now mean attempts on stage. So initially I'm in $0.10. If I drop a nickel, I go to $0.15. If I drop a dime, what state am I going to? So I'm inattention state and I add a dime. There is no 2010 state. It is a fift intense state. Exactly. So this is my don't change condition. No change. Okay. The last pieces, MY $0.15 State, fifth incense state, does it care what the inputs are? It doesn't care. I'm gonna stay and $0.15 state as long as reset. Not right. When output is going to be a one. In fact, what am I just put the bar so it's obvious. Now, how am I going to handle this reset thing is I'm going to create a separate table to make my life a little easier. If reset is a 0, then what I'm going to have is the finite state machine up here. If reset is a one, then my next state is going to be a 0-10 state. And that's it. Okay? So, so far I've created a state table. Is everybody OK with my state table? So the question is about my no change state. So if I'm in a state of $0.10 and I drop a dime. And I wanted to keep track of the fact that they have extra money. I would need to either have an extra output that would immediately provide nicole back out and move into the state in which I give candy also. So I would have to have separate stated more state machine where I can give both a candy out and $0.05 out because I've just overpaid. If I have both dime and nickel equal to one. I said in my original problem description that that is impossible. So that is why it's a don't care state. And I had one more question. Oh, the recent questions. So the reset signal works, varies in a very simple way. As long as reset is a 0, we have normal next state as described in this table. If reset is equal to a one, the next state is a 0 state. So that's what I mean by a separate little reset table. I put it over here so I don't have to create additional rows in my table. And in the 15th and state, I would still treat the condition of two inputs being equal to one as a don't care. I just didn't bother writing it. Ok. So everybody okay. Okay. Now the type state table, what is my third step? What do I need to do? And this should be on your homework assignments and on your exams. So I have state diagram, I have state table. What do I need to do next to get to my excitation table? I need to do state assignment. So I'm going to assign 00 up to state 0's sentence 012, state of 510 to state of $0.10. Now notice that I could have assigned also something like this. This would have worked also 000111 and say 1-0. This is effectively gray code and this might smaller implementation because it would allow me to minimize. The neighboring states. But this time I decided to kind of keep things simple and just use a Steiner, a standard binary encoding. So this means that in my excitation table, I would want to replace Europe's and state with 00, $0.05, state with 01, $0.10 with 10. And this is a don't care, so just space of them care. And then hearing the next one, I will again have 5-10 state the 01, $0.10 as 1-0, 15th sent as 11, and then a don't care. So here I have 101111 and don't care. And then 11 is the last one. Okay. So that would give me my fourth be switches excitation table. What is my next step in this story? What do I want to do next? Came up, how many came up? So am I going to need? So I'm gonna need that came up for the output, right? Output is just a single bit. So here is my came up. For the output. Let's first remember the present state we're going to have, because it's two bits, it'll be Q1 and Q0, right? And then I have these two inputs. So total of four inputs. So my key map will have four inputs. It's going to look something like this. Q one, q d, and n. 0-0, 0-1, 1-0, oops, I must stop. It's not 1-0. It's 11100011110. Okay? One of these is going to be output. So for output, I would want to take this whole column and put it in a K map. Now notice that output is one only as a function of being in a state 15. So this is super-simple. I'm in a state 151, Q1 and Q2 are equal to each other. So this, I almost don't have to even think about how I'm going to implement. I know it's going to be an AND gate. The other thing is I have these two inputs, D1 and D. That is my next state, right? So I'm going to need how many flip-flops to implement this? Two. So two is the minimum number of flip-flops because I have four states. So to encode for states, I need at least two flip-flops. Now could I have done something like this? Good? I have assigned states like this, zeros, zeros 0001010 and 1-0-0 shrimp, i cutoff. But this would have cost me a lot of transistors, 46 transistors, extra. So that's bad. We don't want that, right. Okay, so I know I'm gonna need one came up for my output. How many key maps do I need for next state? I'm going to need to K Map for next state for a total of three K Maps. Guy. So one K map is going to be the one, one came up will be the 01 came up will be open. Okay? And then I'm gonna have my flip-flops, D1, these ERA, here's my Q1, Q0 era. And these the next states are going to be generated using q one, q 0, and then the and n as inputs. My outputs, on the other hand, is going to be, we have already figured out just an end gate between Q1 and Q 0 because of this encoding. Okay. Everybody, okay, so far, any questions on this guy? If no questions, note also that Mealy and Moore state machines will have exactly the same. Next state K maps. They're key maps do not differ. So what I'm going to do on the next slide is I'm going to look at D1 and D0, C0 maps, which will be exactly the same for Mealy and Moore. The bought. The top flip-flop here said is a D1 Q1 flip-flop. The bottom flip-flop here is a D flip-flop. So one implements the most significant bit of the state, that b1 is most significant bit, and that is the least significant bit of the state. Okay, moving on to the next slide. So here I actually did an excitation table for you to just make life a little easier. And I put two K maps. So these came, I first finished for this era and it has Q1, Q0, and d and n setups. So here's 001110, and the same thing here, but for D1. So I have q one, q 0, and D over here. And same thing for the column 011110, okay? And here I circled the sum of products. So they circled the implicates in red. But it turns out that really I probably should have done product of sums because I half-lifes zeros. So let's do first this one. I have only two zeros. And these two zeros can be implemented using product of sums. So D one will be equal to. And because I have only two combined together, I'm going to have three terms in this. And let's see. The first one is going to have Q1, let's say the vertical one, q 0, and then the other one is d. The second one is going to be the n and Q1 get. So that is what my d1 equation would be like. An effectively what I will be drawing S two OR gates, sorry. So I will draw two OR gates 123, q, one q is 0, D, and a second OR gate would be the same thing. 23, and it will be d And, and Q1. Now notice that these are the flip flops and these are the inputs. So this is the current state and D and then D inputs, those two would be combined in an AND gate, which produces a D1 logic of my flip-flop right here. Okay. So far so good. Okay, I'm gonna look at the next flip-flop, and this is going to be my d 0. So for this 0, I'm going to first do this edge here. Like that. That edge is going to have two terms in it. So if I'm doing product of sums and that is what I'm doing in green. I am going to get d n. And I will also have this third one which is q 0. Then the next one is going to be this vertical one over here. So that is going to give me q one or the second one is accused 0, but it's not because Q0 is a one in this column. And the last piece is going to be an n prime, because n is one. And then the last one is this bottom one. Oops, this bottom one which is going to come down here. So for this one, I'm going to have Q1, Q0, or, and then in this case I have D prime. Okay? So what I'm solving in this case is the product of sums, believing some of products for you guys to figure out what terms to do. But you can really do either of them. Ok, so now I have a solution for my d 0 and I can draw my D flip-flop. So here's my q 0. Here is the input. I know I'm going to have an AND gate that's going to have three inputs on it. And then I'm gonna have three OR gates each with three inputs. So first one is d, n and q 0. The second one. Is q one, q 0 prime, and N prime. Now for n prime, I definitely have to put an inverter because I don't get n prime for free. And the last one is an OR gate that has an inverter for the D prime. And then it has Q1 and Q0. And I connect this, this, and this, and that generates my logic for the next state for the least significant bit. So this is LSB of the state. Okay? Okay. Now looking at this, let me ask you one simple question. Do I need an inverter for Q0 prime? Correct? I do not need an inverter because I got it here. It comes for free. Okay. So here I did not bother drawing my little feedbacks because he would have been too messy. But this is affect a label thought would ask you to do on a homework assignment or on an exam. Normally on exams I ask just one of these bits to be implemented. Either most or least significant bit. It doesn't matter because the procedure is the same. It just gives you more practice basically to do one versus the other. Okay? Any other questions related to this? We're going to get to the output on the very next slide. I do want to address the question of Reset. How would you implement three set? What you will do is, with every one of these flip-flops, you would add. Remember that synchronous reset gate. That is what you would have. So every flip-flop would look something like this. This would be the input, and here would be the reset. And how do I know how many flip-flops to use? I know because of how I did my steeping coding, because my state encoding uses two bits. I need one Flip-flop per bit of the state, because I need to save that bit to remember it until the next time when I update it. Okay, moving on to the output. So here's a key map of the output. And in this example, the result is super easy. I simply find that open is equal to q one and ended with Q0. Which basically means that if I have two flip-flops, D one, D 0, Q1, Q0, all I'm gonna do is put an AND gate and produce Open output. Okay? Now the next state is produced over here and it's a function of the n. And it's a function of q one, and it's a function of q as well. Okay. And that stuff we did on the previous slide, Any questions on this one? Okay. I have no questions. Let's do the Mealy state machine. Now, as I said, for Mealy state machine, this present state and next state are exactly the same. So I'm not going to repeat what I did because the result would look exactly like this. And we can basically say Mealy and Moore implementation of next state logic. Okay? But output will look different. So here is the Mealy output. And in this example again, I just that I circled in red your sum of products. What I'm going to do in class is a product of sums. So for product of sums, I'm going to start first with this column. And for this column, I have q one ord with q 0. The second thing I'm gonna do is this square over here, and that is q one or duit. This is the ord with D. And the last piece is this little two sum over here, which is, let's see, what do I have? I have D or N, or this is going to be Q1, right here. Ok. now no excuse Zara. This is a QO. Okay? And now I'm ready to draw my open circuit. So notice that in this example, my output is going to have an AND gate. So here's open bug that then gate, there's going to be connected to three different OR gates. First d, n, and q 0. Then I'm gonna have an OR gate that has Q1 and D. And then I'm going to have an OR gate that has Q1 and Q2 Zara. Ok? And actually for simplicity, I'm going to write it a little differently. I'm going to put q 0 here, and then, and, and D here. And then down here I have a D and I have a Q1. So notice that this here depends on the input. The other stuff, this, and this is the current state. Okay? So notice that the output is a function of input and current state, which is what you would expect on merely implementation. You would expect it to be a function of current state and input. Notice also that this implementation is much bigger than the previous implementation. So in fact, here merely is bigger than more. So you would want to pick more implementation. The other variety that I might ask them, these kinds of questions, and this was especially also apply to this next state. I might tell you that instead of ands and ors, i want minimum transistor. In which case I want NAND NOR and not. Okay. So what you would do is you would get the equation, say boys, we got it here, but then you would move it into the NAND NOR, and not the implementation. Ok. Any questions on any of this so far? So great question on how do I know which is smaller, merely or more? As I said, there is no easy way to answer this generally in exams and in homeworks I tell you do merely or more. If I don't tell you, start to add more because almost start sorry, start with merely because almost always merely is smaller. So most the time Mili as less states, but not always. So i will generally start with merely And then I will double check whether more happens to be smaller. But generally if you had implemented merely And it turned out that it wasn't the minimum, you would still get a lot of the credit on either homework or an exam. Okay. Any other questions on this? Okay. So I'm going to move on to the next slide and to the new topic, which is timing constraints and sequential designs. So for sequential circuits and for combinational circuits, we have so far behaved as if it takes 0 time for signals to propagate back to narrow that signals do not travel in 0 time. For example, we know when we have a circuit like this, sorry, this is a little messy. We know that this circuit will have different delay depending on what is the input. For example, we know if both transistors are on at the top, the total resistance will be half. We also know it both transistors are on at the bottom. We know the total resistance will be twice as much. So up here we're going to have smaller delay. Down here, we're going to have faster delay. So there is this variation between the delays. So this is why we are going to be looking at timing constraints for both combinational and sequential logic in order to figure this out. And in fact, we're going to look at both this minimum delay of a gate and this again, going back to this example that I just showed, where minimum delay of the gate would be occurring because I have two transistors in parallel. That would be the minimum and maximum delay would be happening because I have two transistors in series, minimum delays called contamination delay, and it's labeled as TCD. Maximum delay is called propagation delay and it's called TPB. And the reason why they have this is because again, they have cmos transistors. Whose delay ranges from some small amount when all the parallel transistors are on to some larger amount with all of the serious transistors are on, okay? Any questions on this? Okay, so here is the first poll of the day. So what I would like you to think about is looking at the circuit above, wedge it, a beach lime is a contamination delay of the circuit. So is it red, blue, or neither, or both? So which of these lines represents contamination delay in this circuit? Okay, we got 543210. That's close. I have majority for b. Next up is a. I guess it's hard to remember b state and thought. Self-contamination delay is equal to the minimum delay. So now that I've told you that word contamination means minimum, which path is the minimum path here? Red or blue or Neither. Bread Exactly. So red path is the minimum path because it goes through only one gate. Blue path on the other hand. And this can be either from a, from B signal, that is propagation delay. Because it is slowest. This takes 123 gates to get out. Any questions on this. Okay? So let me talk a little bit about timing constraints, some flip-flops. So remember when we first designed the flip-flop, we talked about the fact that there is this inverter here, which still take some small amount of time to change value from 0 to a one or vice versa. And that for that small amount of time, we still have a chance of SNR both be equal to one. And I told you then that we're going to deal with this later when we start talking about the sequential circuit design. While it turns out that later has come. The way we handle this problem is by defining constraints around the clock edge. So when clock rises, sometime before, which is called the setup time, the input D has to be stable, so it has to hold IT, whatever YOU, it's going to be. Whether it's a 0 or one, it doesn't matter. It needs to stay either 0 or one, but not change. Ok? And some time after the clock edge, which is called hold time, the also needs to stay stable. So here is the whole time, here is the stable. The total amount of time is called the aperture time, which is basically the time that these should not change the input to the flip-flop. And this basically guarantees that we'll never have this situation where S and R latches that are inside of the flip flop will have one at the input at the same time. And for some reason we violate this constraint. Then the output Q, F set up or hold violated. Then q is equal to or don't care. We just don't know what it is. So this means that the input is not allowed to change between this time. So before, sometime before the rising edge and sometime after rising edge D is not allowed to change. So from here on out for the rest of the class, D, whenever set up and hold times are specified as being non-zero, d has to be stable during the setup, an old-time, otherwise the output is a don't care, okay? Okay. The other thing that happens in the flip-flop is it actually takes some amount of time. And this again is non-zero time for the output to change as a function of the clock. So as the clock goes up, it will take some time for output to change. And this can a minimum amount of time, or it can take some maximum amount of time. It's a function of how the flip-flop is designed. So that is what we call either the contamination delay over here or Flip-flop propagation delay down here. The propagation delay is called TPC Q contamination delays. It is called this TTC q. So C stands for contaminations. The second C is clock and Q is output. So basically it's telling you, in this case, propagation between clock and the output or contamination between clock and the output. Okay? So those are the four parameters that flip-flops have, right? That the design time and that will determine how well your circuit beaks. So here is my next poll. Now that you understand the setup time, I would like you to tell me the timing of which of these signals will cause a set up time violation. So remember when we talk about set up and the whole time, whoops, sorry. When we talk about setup and the whole time we're talking about sometime before, in, sometime after this signal. This is setup. And here is hold. And remember that the logic that we are talking of, the flip-flop we're talking about has an input, D has an output Q. And this D input is generated using some combinational logic that will often have Q as an input to it. Won't give you a few more seconds. 54, 3210. And let me show results. So most of the people think that the input is the one that can cause a set up time violation. And it turns out that majority is correct. Great Work majority. It is this input signal here that we defined the setup and the whole violations for. So input signal can change up until the setup time, and then at that point until the whole time has to remain stable. And then after that it can change again. It, even though the input is affected by how the output of the flip-flop is, it is actually the timing in the changes on the input that the effect, the setup and hold constraints. The output may or may not affect the combinational logic and then the folder and put them into your flip-flop. Okay? Okay. Now you're ready for a far more difficult question. So here is a question where we have two different sets of flip-flops. So here's a register one. Here's a register two. In this case because it's a register and we have a bunch of wires. So for example, this might be 64 wires, and it may be a 64-bit register. And this register, the outputs are fed to combinational logic. And then the output of combinational logic produces inputs to the register R2. So it basically produces inputs D2 to all of the flip-flops in register R2. So here the question is which of the following violation occurs if maximum delay of R1 is 0. So this means that whatever comes at the top are one will propagate to the output in 0 time. And maximum delay of the combinational circuit is equal to the clock period. So delay through the combinational circuit is going to be this long, exactly this long. Okay, so now that I've explained the question, I'm going to launch the poll. So give this a little bit of the thought. I know this is not easy. And make sure to ask yourself which flip-flops, inputs and output will be affected by this, okay? Oh, okay, I think we're just about converged to this. Here is the result of the poll. And actually I just realized my video is off. So majority of the class thinks that the correct answer is answer B. And it turns out the majority in fact is correct. Let me actually share results. I kind of forgot to share results. So here is what it looks like. We have a few people who, who have voted for a, C, and D options. But the correct answer in fact is b. And let me discuss why. So here. First of all, when we talk about the violations and we talk about timing, the maximum delay of combinational circuit will not affect the input to the register r one. So this is why the R one is definitely not the correct answer. On the other hand, it would affect D2, the input to the register R2. And the fact that it's taking such a long time for the data to propagate means that at the next rising edge, we're going to be in a situation in which we're violating. So let's say that here is you're using it. You're gonna be violating the setup constraint of that rising edge. So this is why setup violation is in fact the correct answer here is not correct and that he is not correct. So your new inputs will arrive right at the rising edge of the clock, which means that you have violated for sure the setup time. Ok. Any questions about this? So this basically means that the two would not be stable during the rising edge. It would be, it would be stable right after the rising edge. So he will not violate the hold constraint, but it would violate this constraint. Okay? The diagram B basically just shows you these transitions. So it shows that the after the clock, there is a little amount of time that it takes to, for the output to show up. Now notice that I said that this time was 0, so it would have been, oops, sorry, exactly 0 time. The second piece that it shows is that it takes some amount of time for D to stabilize. However, in this case, D will take the whole clock cycle to stabilize. So that means that you're gonna be violating this setup constraint over here. This diagram was just there to remind you of these constraints are moving on to the next slide. So here we define the setup constraint. The setup time plays a role in defining the minimum period. Minimum period obviously happens when we put equality here instead of greater than or equal to. And it does affect friction up, set up constraint and maximum delay of the flip-flop. And these are function off flip-flop design. And there said that the time that somebody designs a flip-flop, you can't change on. So generally, all flip-flops in your circuit would be exactly the same. The second piece is this maximum delay of combinational logic, which is this thing. And this you can change. And you want to change it, you want to minimize it. Because then it gives you a faster clock period, which means you're going to get much faster frequency. My maximum frequency, my best frequency of operation is one over the clock period. So the smaller the period, the higher the frequency. Ok? So generally setup time constraint problems are, are normally worded than as either. I want to have, for example, a frequency of one gigahertz. Design a circuit that meets that frequency. What are, what is the maximum frequency of operation that this circuit can go? And then in that case, you would look for the longest delay between any two flip-flops and that will tell you what is the maximum delay. Okay. I have a next question for you guys. So same set up register R1 and R2, but now you have minimum delay of R1 0. So again, this goes super-fast with 0 delay. And there is actually no combinational logic. It's just the wire right here. So the question is, what might we violate here? I'm gonna launch a poll again and give you a few minutes to think about this. Now here we are assuming that Y or delay is a 0. Wire has no delay, even though in reality wires actually. Okay, I'll give you five more seconds. 543210. And let me share results. So majority of b Paul say answer C or whole time violation of R1. So let's discuss this. They can look. So first of all, notice that here I said that there is a wire between R1 and R2, which means that the signal will propagate super fast to the input D2. I gave you no information about propagation of signal that the inputs to the d1. So that means that either seed nor D are not correct because I gave you no information to inform you of what happens at the input of the register one, I only told you that the propagation through it is 0. So that basically implies that if D2 is, has just changed. For example, in this rising clock edge, if D2 just change from 0 to a one, and D2 is influenced, but whatever is at the B1, it is very possible that D1 changes again from one to 0. And because there's 0 delay, the two my drop down to 0 almost instantaneously right after the edge. So you're gonna have a situation in which you do not have a stable D2. Where D2 right after the clock edge may change instantaneously because of the 0 delay due to a wire connecting these two registers. So this will not cause a setup violation of R2. It would cause a whole violation of R2 because of signal going too fast. So that kind of brings me to specifying hold violations. The hold violation is specified by just looking at the comparison on minimum delay through the flip-flop. So this would be the flip-flop that feeds that next Flip-flop. So this minimum delay. And minimum delay through combinational logic. So that would be this combinational logic. So that flip-flop and this combinational logic, if the minimum delay is bigger when added together than the whole time, that means that the two will not be overwritten again during the whole time. Okay, that's the issue. So the hold constraint release concern about not overwriting. Okay. After edge. That's the concern. So what we don't want to have happen is that on the rising edge, both of these flip-flops load something in. So this one load something in and this one load something in. So, so far things are good. The problem happens right after this guy R1, both something again, that if it has 0 delay and wire is connected to the D2, whatever it has loaded then will immediately appear at DTU and it will not actually obeyed the hold constraints. So it could overwrite whatever we had just loaded. So that's the issue here. Okay. Any questions on this? Okay. So let me move on and remind you that we have fixed design parameters for the flip-flop. So set up the whole time. Have to do with clock edge. Here is the setup. Here is to hold. Okay? Tcc Q and TPC Q, this is the minimum. This is the maximum time it takes me to propagate through the flip-flop from input to the output after the rising edge. Okay? So those are all fixed. They will stay fixed for all of your designs so there's nothing you can do about it. The only thing you can deal with this, this combinational element in here. So this combinational element, you would want to minimize for better period or higher frequency. And you would want to make sure that hold constraint is met. So in that case we're cold constraint. You may want to add some gates to make sure that the constraint is met. Now in all of this discussion, we assume that clock will arrive at exactly the same time so that the clock edge will happen at the same time to all places in your CPAP. And this simply is not true. It does not arrive at the same time to all locations on the chip. And in fact, the chip, chips currently have billions of transistors. So it's sort of like saying the, that I could in fact be in San Diego and in San Francisco at the same time. It's simply not possible. It in fact, takes me quite a long time to drive from San Diego to San Francisco. It's on the average say about eight hours. If I'm not completely crazy driver stub. This is basically what we mean by clock skew. So if R1 is San Diego to San Francisco, and I am the pluck, then and the amount of time it takes to drive between the two is the clock, then it would. The deference is in fact eight hours. Now on your particular design, clock skew is defined as the worst possible difference between when to clock edges arrive anywhere on the chip. So in my example in San Diego and San Francisco, that's eight hours in example of a chip that's usually in less than a nanosecond, much less than a nanosecond. But it does affect the operation of your circuit, then it affects it in a negative way. So when we design a circuit, we need to be aware of the maximum clock skew. And we use that maximum to change our parameters for setup in the whole time. And we use them in a way to make it the worst possible case, because that means that regardless of what happens, the circuit will always work. So this is why your processor's work just fine even though they have this crazy SR latch inside of them. Okay? So here is how we make a change. In case of the setup time constraint, we add clock skew in because this gives us a higher period. And which means lower clock frequency, which is one over the period. Ok, so this will guarantee that under even the worst clock skew, our setup constraints will be met. Now obviously this whole story always want to optimize or get, make your delay of combinational logic as small as possible because that gives you a better period. It minimizes the amount of period you need to have. In case of the whole time constraint, we're actually making things worse for us. So here we're subtracting the skew, which means we have even less time. Basically means that the clock edge arrives earlier. So we're looking for a situation in which clock is super fast. Because that gives the highest chance that hold constraint might be violated. And if even in that case called constraint is not violated, then we're in business, then all is, well, gap. Any questions on either a whole time constraint or a setup time constrained. Okay? But I have no questions. I'm going to walk through and a design example. So here, these are flip-flop timing characteristics for all of the flip-flops in our design. And these Flip-flop timing characteristics, these, this is the minimum delay. Here is the maximum delay. And this delay is from clock to Q. That's why it's CQ here or set up and hold constraints. And here is per gate delay. So you're lucky this is the maximum, this is the minimum. Here. I don't care whether it's a NOR gate OR gate or AND gate. They all have the same delay, even though we know that they are basically different, right? So how would I calculate the gate delay? I already taught you how to do it at the beginning of the class, we looked at resistances and capacitances. That's how you'd get gate delay. How would you get these delays? You would look inside of the flip-flop and calculate all of the gate delays inside of the flip-flop using the same resistance and capacitance calculation that we learned that beginning of the class and set up and hold time really comes from the design of the flip-flop there you would also look inside of the inverter and its relationship to the rest of the gates in the flip-flop design. So actually you guys know how to calculate all this if you wanted to. And now, luckily for you, I am not going to ask you to look inside of the flip-flop and calculate these delays. But I will ask you to know how to estimate delays of gate, combinational gates outside of the flip-flops. And I will provide you with the set up and hold constraints and also the flip-flop minimum and maximum propagation. Okay? So now that I've done that, we still need to figure out what is our slowest than what is our fastest path. Let's start with the fastest path. Which path is fastest? So the starting point, our registers a, B, C, and D, the ending point or register x and y. So which path or paths or the fastest in this design between which two registers? Yeah, d two y. This is one. So the fast pass would be d2y. The, the other fast passes, which one? Given that we're saying all gates take the same amount of time. And this is 25 picoseconds if they're being passed, which other path is the fastest? See 2x exactly. Both the two y and c 2x. So in this case, the fastest delay is 25 picoseconds. And the fast this time through my input flip-flops. So this would be C and D flip-flops would be 30 picoseconds. So that's why Thursdays in here and 25 is in here. So when I add these two together, I get 55 picoseconds, which is most certainly not greater than 70 picoseconds. So how would I fix this? One way would be to just add buffers, right? That would be a simple way to do it. Now let's talk about our slowest possible path. What is my slowest path here? So how do I figure out my clock period? A2 y is a slow path because it goes through all these gates. Or notice also b to y. So the slow paths or a or b to y. Ok. And on this way I have 123 transistors, sorry, three gates. So that is why it's three times 35, five seconds, because here I'm looking at the slowest possible delay. And that gives me a total of a 105 picoseconds. So I put that into my clock period, the equation. The next thing I do is I look at the slowest delay in my a and B flip-flops. And this would be 50 picoseconds. This comes from Flip-flop specification. And then the last piece of this, my setup constraint. So when I add all this up, I end up with 215 picoseconds, which gives me a frequency of 4.65 gigahertz. So this is the fastest possible time bed my clock could run in order for this circuit to work. Now if I wanted to optimize this further, how would I optimize it? How could I make this smaller? What I would want to do is I would want to somehow make this path faster. And the way people make a path faster is usually by adding additional registers, which is called rate timing. So what they would do, for example, is though just stick or registering here. And that breaks up a path because now you have one gate here and two gates here. So now you can run even faster. The problem is that it takes you two clock cycles to rising edges instead of one to finally get an output loaded, something loaded into y. So effectively, you can have faster clock period, but it takes you to clock periods to get there. So it's a tradeoff, which is why people normally try to minimize gates. They tried to make a small gates as possible and as efficient gates as possible. Ok. Any questions on this? Okay, now let me get back to when we fix the path. So if I add the buffer on here, I'm assuming that the buffer takes also 5025 picoseconds. But in reality, we know that this is two inverters. So, uh, probably more realistic way, this should be 75 picoseconds. But either way, it now meets the hold constraint, which means that this circuit will run correctly at 4.65 gigahertz. Now notice I have two inverters to both pass. And notice that if I was in a position in which this particular path happened to be a slow path. For some other reason. You know, let's say that this also fed up here. So let's assume that this also feeds up here. I would not want to put this in here. I would want to put it right in here. So you want to be really careful where you add gates. You don't want to add gates in the way that will cause a longer delay for your final output. Okay? So the question is, how do they decide when to use the slow register? Sorry, I'm circling the wrong version. Went to use the slow versus the fast. We're using the slow one when we do set up constraint and fast when we do hold constraint, that's the only difference here. And we know which is a setup constraint because we know which is the slow path. So only a or b registers are on the slow path. Only C or D registers are on the fast path. So C and D are related to the whole constraint. A and b are related to the setup constraint. Okay? So if you have to account for clock skew, you would definitely be given a value. Safety skew was gamma, and I will tell you that at, say, 25 picoseconds. And then you would add it here and you would subtract here. Okay? So if I add two inverters, even with clock skew of 25 picoseconds, life would be fine. Any other questions on this one? Okay, so to summarize what we've covered so far, we talked about static RAM memory. Remember this is a memory in which you have a six transistor design. It's two inverters back to back, connected with some n MOS transistors as switches. Okay. I'm not doing a very good job of drawing. Sr latch, had to do a two back to back NOR gates. D latch. We added the clock to i star latch and an inverter between the inputs. And then the flip-flop had a master and a slave configuration. All of this allowed us to then Bill registers. It allowed us to Bill shift registers. It allowed us to Bell pattern recognizers. It allowed us to build counters. And because we now have registers, weekend started designing finite state machines which provide control for your ALU. And we'll get to exactly how it works for you a little bit later in the class. So if we design a finite state machines, we often start with a world problem. So 0 would be word problem. Then you capture a finite-state machine. Usually that's a state diagram. Then you create a state table where you write names of states as 0, S1, S2, blah, blah, blah. Then you look at how many states you have for the number of states. And you try to pick up minimum number of flip-flops to represent those states. So that gets you to the state assignment, state assignment in this class, we usually keep it simple. I usually tell you to use something as simple as just binary combination, such as this. There are many different heuristics for state assignment. There is no optimal way. So it's heuristic. Then once you have assigned the states, you can build an excitation table from state table plus assignment of states that gives you your excitation table. Once you have, say patient table next you're going to key maps. Then you pick optimize to get the SOP or pos as a function of current state and inputs to get the next state and output. And then you are ready to implement combinational logic. In this combinational logic will have both feed whatever inputs you need. So you're gonna have big combinational logic and it's gonna use whatever outputs of flip-flops you, huh? Okay, and in it, you will have inputs to the function itself. And you're going to create some outputs, which also may use inputs from the outside. So that's the general procedure. And today we walk through both Melian more examples for the fifth intent vending machine that gives you a nice, cheap and hopefully super tasty candidate. We talked about Mealy versus more finite-state machine. So a Mealy state machine, we have a situation in which output Y is a function of the current state and the input, more output Y is a function of only the current state, and it's not a function of m, but the rest is the same. Normally merely tends to be smaller. But this is not always the case. And in fact, I'll give you an example where it wasn't the case today. And then just now, we talked about non-ideal properties of flip-flops, the setup and the whole time constraints, and how a setup constraint gives you the maximum clock frequency and how cold hold constraint. We just need to be concerned about meeting it. If we don't meet it, we fix it by adding gates. You basically want to add buffers. And the last piece we talked about this clock skew. It just makes your life worse. So for setup constraint, you would add clock skew. For hold constraint, you would subtract the clock skew. So on this next exam, everything up. Two non-ideal properties of flip-flops will be included. This means you need to know K maps. You need to know how to minimize product of sum. Sum of products. Need to know how to do an end snores inverters. If I asked you for minimum transistor implementation, you should know how to do that. You need to know all of you. I will use stuff. I almost always put the nail your problem on an exam. Merely more finite state machines. All of this is fair game. Any questions? Okay? If I have no questions, thank you guys so much for your attention today. It's been a pleasure as always, and I look forward to seeing you next week. I hope DA homework number formal go really well. And hopefully this next test will be less stressful given that we just gave a little more time for people to download problems and an upload results next week, same as before that Wolpe already on Tuesday. If there are any particular questions you have that you would like me to solve for the review, by all means, bring it by. I would be very happy to add them. What I will do in the meantime, it's our pool bunch of questions from old exams. So that way you can have some examples to work the work through. And I'll follow the same pattern in the 930 class, also part of the problems and in this class also the rest. So that way you have answers above. We will also post the solutions from previous exams. I'm hoping to post that at some point by next Tuesday. So that way you can take that previous exam and work through it before the review section on next Wednesday, that this review session this week will primarily focus on homework that's due or focused already. Next review session is going to focus on the exam. Any other questions that you have? My professor said, Can I talk to like privately about my situation? Yeah, sure. We can talk privately. No problem. Let me actually I need to create a separate room and for the rest of you. Thank you so much. I'll be seeing you very shortly. That cat let me create them back. And there you go. Did you have a question for me?