Okay, I want to first I forgot to do this last time is to share the results of the. Colonel blotto competition so here it is and just to kind of let you know how to read this thing because it's not in the most beautiful presentation, but. It is it gives you all the information, now that the. I didn't really want to share everybody's name, because I don't know if you didn't want your name to be associated with I don't know whatever so I gave everybody a number ID is, essentially, just like the order in which you filled in the. filled in the form, you can find your number ID in your grade report on grade scope so whatever you have there, then you can find it on here, and you can play around with the. You could download this spreadsheet from pizza and play around with it and find yourself there and see you know who you be and who you didn't be and what kind of strategies we're. Good which kind of strategies were not so good, you know which are the people at the bottom are generally the people that you know. This is not the best strategy to put 101 Castle right because you're you're most likely going to win that Castle for sure, but then the other castles you may not win and the. The best kind of strategies that you see you know if you look at the top five. They all kind of have this same sort of idea where they have like around 16 or 17. spread out between how many cancels six. right because they're looking to kind of win those six so they're spreading them out kind of evenly and putting ones or zeros in the other cancels and I think most of these top ones, I mean even the even the next one, putting eight teams down there and twos. One a lot of them right or got a got a good score. I guess, these are all ties, so I should probably extend the. The points to these guys to i'll do that later anyhow. it's interesting like you know this this person who got the the best score. Right this this same arrangement may not have given him the best score in a different class right or a different set of castles and we're going to play this again after the second midterm. And you know that there could be sort of a a strategy or some sort of line of thinking, where it's like oh that guy one i'm going to. mimic his thing, but then another person's thinking like oh everybody's going to try to mimic that guy so i'm going to try to. Change mine, so that I can beat that one right and then it's like i'm going to beat the guy who beat the guy right and this kind of gets you into the whole thing of game theory. Which we're not really going to cover in this class, but I do think is a fascinating topic to explore, you know how can you. I don't see what your opponent, is going to do, and make the best move it's it's a it's a important. it's an important topic for just playing games right but it's also you know they use it a lot with warfare and trying to predict what you know the opposing country might might do to retaliate or this and that so okay any questions. alright. You do a new share. hey we're gonna do some stuff about graphs today I think we're gonna start out with. With. More recursive algorithms want to show you one more recursive algorithm works anything called carrot super multiplication and then we'll do some graph stuff. Jason what's this Jason see matrix Jason C list common graph vocabulary degree and then we'll get to our first algorithm, which is in general graph search, but really this. encompasses. Many. Other graph algorithms. dfs bfs. dykstra has. Space so things that you may encounter in your other classes like CSC 100 CSE one on one these kind of. graph algorithms that you're going to learn about and implement and prove and all that stuff. Okay, so let's get into multiplication because I think that this is a really neat use of divide and conquer and you can kind of see. How using divide and conquer is only really helpful if you're very clever, at least with this particular problem okay so multiplication of have to have ended two and digit integers right, how do you do it well there's the grade school method where you. You line up everything and you do a bunch of single digit multiplication right. And you you add up all these things right. So how many single digit multiplication do you have to do and all together how many operations are there. I guess in like a big O notation. squared. Okay, good n squared. Right just doing those single bit multiple occasions you have to do n squared of them, but then. takes linear time right takes no time and you have to add n numbers together so that addition part also takes n squared amount of operations, or at least Bingo of n squared. Okay, so this is kind of like what we're trying to be because we have a great algorithm for doing multiplication the grade school method right it works really well and N squared isn't a terrible runtime but let's see if we can improve on it. Okay, so um divide and conquer how are we going to divide well why don't we just take the number itself and split it in half, right to the left side and the right side. Now, instead of multiplying those two numbers together we're going to multiply those those parts together Okay, so if I split a number in half. Then essentially what i'm doing so let's say a was 12345678 then splitting it in half really what that is doing is saying a is equal to 12340000 plus 5678 and another way to write that is like this right with it with attend to the for. You kind of shifting it over. Okay, so now, when I multiply A and B together there's this uh well the way that I learned, it was that I use this for letter F word that was very helpful in memorizing. What operations to do does anybody know what four letter F word i'm thinking of. Oil good for. First. outer inner last so notice that we're doing for. Multiple locations. And each multiplication is smaller than the original. And it's a multiplication that's what that's what the algorithm is supposed to do so, why don't we replace each one of those multiple locations, with a recursive call and have faith. That the recursive the recursive call will give us the right answer, and then we just do a little bit of cleanup. So one eight digit multiplication turns into four digit multiple locations plus some shifts and some sums like these multiple locations are not. it's not necessary to use the algorithm for those because those are just actually shifting they're basically like padding the right side with zeros so that doesn't take as long. Okay, so. Okay, so. If you were to code this up and build it, you know the recursion there Chris of algorithm What would the recursion of the runtime be. St Louis. we're almost halfway okay we're halfway that's fine okay so let's share results were mostly saying see but be in a close behind that and D so. Maybe a little bit of confusion there. The answer is C. Right, remember that a is the number of recursive calls. You know, an over be right and over to is the size. Of. recursive calls. In this case, we started with two eight bit or eight digit numbers and and the recursive calls were four digit numbers so that's half the size and then D is one because it's linear linear. I should say. let's go up here non recursive part. Is linear. Now, why is it linear it's because. Of these additions here. Now I know I said in the beginning, that addition and multiplication or both constant time operations that's only if your numbers are small enough to fit into. Word size, so if you have really, really big numbers edition now takes linear time right, and you can kind of think about it, as the grade school method with edition you put one number on top of the other and you just kind of do these you add the columns together like that. But if we're multiplying with 10 to the fourth will still be linear so these multiple locations here. These multiple locations are actually bit shifts or. You really just padding. The right. With zeros so you can certainly do that in linear time right because you're just kind of putting zeros in. The real you know the real part that's going to take a lot of time is the recursive calls, but how long do they take well they take how long the algorithm will take, and you have to do that recursion the recurrence relation. Okay, any other questions. Well bit shifting be constant um I guess it kind of depends on what. How you implement it. You know the these big shifts might not be very small right they're going to be in bigger than word size, so you kind of have to imagine that you need to allocate more memory to hold them or. You know I don't know. But um you're not losing any as i'm Tata runtime but but by considering them as linear time operations, because you're the addition is already linear so it's not going to. Okay, so we plug everything into the master theorem we have a is for be as to D as one so for is bigger than two to the one so that means we use the bottom heavy. And you get to event is big of an to log base to have four, which is just bigger events squared so at this point, you might say, well, I guess you know divide and conquer it was a cool exercise, but it didn't really give us anything better than the grade school method. So that's where carrot subic comes in and the. The insight here is to replace one of the for multiple occasions with a linear time subtraction. And how do you do that well um the idea here is that of course. These two multiple locations that you know they're kind of like locked in place and you can't really like mess around with them too much, but. notice that these two. are both multiplied by 10 to the four so you can kind of like think about this whole thing is like a big chunk and try to manipulate it that way. Okay. I mean that's that's not exactly what's happening, but that's kind of how I think about is that you know you, you only have three terms, so you should be able to only do three. Three recursive calls and the three recursive calls you do are well, you have to do these two unchanged, but then the third one, you do is going to be. A combination of subtraction right so first you subtract these two things, then you do the recursive call and the the nice thing about this is that the subtraction you're doing is linear time already. So that'll kind of get consumed into the big of into the D term and it won't really change the. The acid tonic runtime of the non recursive part. Okay, so i'm carrot soup is the mathematician or computer science who who developed this. And that's why we call it that, so the carrot super multiplication we're going to basically replace this four with a three now that doesn't see might not seem like you're really doing that much but you're going to you're going to drastically improve the runtime. kayla's plug it into the master theorem we have a s3 be is to D as one, so we have three is bigger than two to the one. Which is this, which is the same bottom heavy thing, but now, instead of and to the log base to a four we have end to the log base to have three. which turns out to be around and to the 1.258 so before we had n squared now we have entered the 1.58, and this is a ask them topically better runtime. Okay, this is good news. And now the progress since then is. From there. Tomorrow cook or able to kind of take that same idea and instead of splitting it up into two. halves they'll split it up into thirds or fourth or fifth right and keep on splitting it into more and more. More and more parts to achieve better and better and better run times and you could get kind of very, very close to linear but not actually linear. And then in 2007 fewer use number theory to achieve the best known time for operation for multiplication at that time, which was. Using something called the fast fourier transform fast fourier transform. And finite fields. And then in 2019 just two years ago. There were there was an n login algorithm for multiplication I should have put the the mathematician who did it. But that was kind of like big news and. it's on Wikipedia. Fast multiplication for large inputs oh there's carrot soup on their cook to fourier transform. David Harvey and George van der hoeven. joris. Okay, so pretty cool any questions or comments. alright. let's get into graphs Okay, what is a graph there are two main types of grabs that we're going to study director graphs and undirected graphs. And they are similar in a lot of ways right we both we call them both graphs they both have vertices and edges, and all this stuff but they really are quite different. In a lot of ways, can I freeze. They are kind of different, but we are going to kind of learn about them in parallel so let's let's think about it okay so where Am I here. Okay let's start with directed graphs a directed graph is a non empty set of vertices V also called nodes. And a set of directed edges, he where one edge points from one vertex to another each edge in this case is ordered pair you come a V. Where you, is where the edge comes from envy is where the edge goes to and sometimes you could call it, you is the tail and V is the head of the edge, then you can think about like an arrow right and arrow has a tail and ahead arrowhead right in its tail so tales of the head and. it's directed right so it's only going in one direction. undirected graphs just like they're saying is undirected, which means that the edge, the only information that's contained in the edge is which two vertices are connected by that edge so there's not really like one. direction overcomes the other direction it's just that they're just connected or they're not and so that means that for an undirected graph each edge is a pair it's a set right. set of two vertices. Because order doesn't matter right. Okay, some variants so we talked about undirected graphs when you draw them all, that really means is that you're not putting arrows on the edges they're just lines. And the it's an ordered pair of vertices a directed graph when you draw it has arrows and each edge is an ordered pair of vertices a multi graph. Is a graph that has several edges, but that may have several edges between a pair of nodes. Sometimes they're called parallel edges sometimes they're useful sometimes they're not kind of depends on what you're doing with the graph. And oftentimes especially like in this class and in computer science in general graphs are mainly used to model other types of things it's like I want to solve this problem. let's turn it into a graph first and then kind of do some analysis of the graph and start depending on what problem you're doing, you may want to have the multiple edges. Or the multiple edges might not make sense for you, you may want to have an undirected graph but that might make might not make sense for the problem you might need a directed graph so the. reason that we have all these things is because we we want all these different properties to fit with which problems we're doing. Okay, a simple graph is a graph with no self loops no edges that go to a verte from a vertex to itself and know parallel edges, this is generally what we're going to be dealing with in this class and what a lot of graph theory deals with is our simple crafts, been. Okay graphs are everywhere, so this is a. This is the metro map of. I think Tokyo. So in this map the vertices so you say grass can help form an algorithm for a given Program. Sure yeah. So the vertices here. Are. The stations right. The edges. Are the. The. What do you call those train lines. is directed or undirected. undirected. But i've never been to Tokyo, so there might be like maybe one of the sides of the trains is broken or that is under construction and you really have only one way to go. Right so. See, this is the kind of thing where it's like what what type of problem, are you asking and it'll determine which one you are doing. um Is this a simple graph. I think it's not because there are, for example. Like between these two things, these two stations, there are two edges, but I don't know because I never been to Tokyo, maybe that's just like one track, but two lines kind of use the same track track. So. yeah so good there's like all these kind of questions that you know we don't know exactly the answer to and it depends like what I was saying before it's it's going to depend on what type of problem you're asking. Okay here's another graph, it has to do with map coloring, this is a the United States, and here is a graph. Now the vertices here. In this graph. Are states. edges our. Borders right is this directed or undirected. This is undirected, how do you know well, I guess, the first clue. Is that there's no arrows on the on the edges, but think about it a little bit deeper. If you have two states that border each other that it's not like one state borders, the other one right it's not it's not a directional relation, this is more of like a mutual relationship between two of the objects and so when that happens, you usually want to use undirected edges. Is this simple. Yes, right for, and you can kind of think about the same somebody said no. I guess, can you border a State twice can two states border twice, I guess, they can border in two different. locations, but generally when we're talking about two states bordering it's really like a yes or no right it's a they are bordering or they're not and there's no in between, and so. This is going to be simple, in that regard, can a state border itself not really right it's not that doesn't really make a lot of sense with you know with this. With bordering as the relationship so. Like I said before, the the type of graphs that you're going to build is sort of dependent on the problem and you can kind of get clues on what you should do, based on the nature of the relationships. yeah so so This brings us to something called map coloring, and so the idea behind map coloring is like. If you have a map like this and you have a bunch of regions in the map, then that will call countries but really they're just states in this particular example, but you can think about like the map of Europe with a map of Africa with like countries. If you're looking at an atlas it's kind of confusing if to bordering states or to border and countries. share the same color right, so you want to make sure that if two countries are bordering they are colored in different ways. And the question becomes an optimization problem what's the fewest number of. what's the fewest number of colors that you can use to to to color the entire region or the continent or the country or something like that yeah that's the four color theorem and the four color theorem says that for. For planar graphs. You can always. color. With four colors. Which is pretty cool. And it's a. This is. This is a pretty big result I feel like this was kind of like. Most of the work was done, like in the 90s, but this was kind of like one of the one of the first results that relied heavily on computer software to prove. And the way that they did that was they use a computer to generate thousands and thousands and thousands of edge cases and basically prove that every single edge case can be colored in four colors or fewer, and so it was. It was proven that way i'm not sure if they're there has been something called an elementary proof, something that doesn't need all of these different you know case analysis but but has been proven, and it is true. But that's for planar graphs. But I should probably tell you what a planar Rafa a planar graph. Is a graph. Is it under it's a simple, I should say it like this, a simple. undirected graph. That can be drawn. Right. In the plane. Without crossing edges. I need to like you know move the vertices around, is it possible to draw that graph in the plane without crossing the edges, then it's a planar graph so you can already kind of see that any region with any continent graph with countries and stuff. Where the graph is the with edges, are the borders that's going to be planar right because you're never going to have borders crossing each other that's impossible for that type of relationship. It doesn't apply to stage with multiple parts. Why not. Wait why doesn't it apply to states with multiple parts is it that you can you can kind of build something that's not planar anymore. I guess so. have to look into that. Okay, how about this one graphs are everywhere, this is a. Methane molecule, what are the. vertices here are the atoms and the edges, are the. The bonds right yeah the bonds. And so, this is going to be a I think undirected graph but I don't know. Any chemists in here is it does it make sense to have the bonds have a direction, maybe it does, since the since the atoms are are different. But maybe the problem you want to ask you don't care about the direction you just want to know something about the bonds right, and so you know again it's all about what problem you're trying to do. Okay let's talk about encoding everybody's favorite topic we're coming back to encoding, how do you encode simple directed graphs recall that simple director graphs or Director grass, with no cell loops and no parallel edges, how many bits are required to encode directed grabs with an. versus vertices how many simple directed graphs are there with an vertices well well and is equal to one, there is only one. I should actually call this. symbol. labeled. directed graphs. And label just means that each one of those vertices has a name and we're just going to name them with the numbers one through in. Oh Nice, you have a counterexample here. 12340 I see right, I see. If you're allowed to kind of put it in two different ways okay so that's pretty cool. Okay, so how many different simple director graphs are there with two vertices well. there's this guy. there's this guy. Well let's start with this one there's the empty graph i'll i'll put a box around them there's the there's the graph with no edges. there's this graph. That last graph, how can I can have that last graph those edges are not a parallel edges parallel edges, have to be going in the same direction. Okay, so for and is equal to one there's one for n is equal to two, there are four for and is equal to three does anybody have any guests on how many there are. To the N times N minus one. Which is why. Right, the reason is because. Each. Each graph is really a subset of all the possible ordered pairs right so really what we're doing is we're saying how. Many ordered. pairs. Are there. For the set one, two and three. Number order pairs really are just permutations right and permutations to count the number of permutations. You just basically do three times two right, so there are three times two is equal to six. We could even write out what they are. Right there's one two there's one three. there's two one. there's two three. there's three one and there's three two. All right, there are six order pairs. Each graph is a subset of this six right the empty set gives you. The right the empty set gives you the graph and no edges, the the set itself gives you the graph with all the edges right, and so you could kind of. Think about how every single subset of this set corresponds to a different graph and every graph corresponds to a subset alternatively, you can think about each graph as a binary string. Right. Like, for example, you can kind of think about it as a binary string like. like this. That would correspond to the graph. One goes to three to goes to one and three goes to two that have correspond to that particular graph Okay, so there are in total. into a different color here. There are. Two to the 664. Okay questions or comments. Okay, each vertex could potentially have a directed edge to each other vertex right, so there are n times N minus one potential edges that could either exist or not, so there are two to the N times N minus one different director graphs on, and I should say different labeled. Simple. Simple labeled director graphs on and vertices so the theoretical optimal encoding uses n times N minus one bits. Where does the N times N minus one come from. So there are n vertices right each vertex. Can you can you can have a directed edge from each vertex to every other vertex right So if I single out a particular vertex there are N minus one other vertices that you could. You connect it to right so then it's just n times N minus one. Or you could think about it in terms of permutations or you can think about it in terms of edges okay So how do I encode or decode these. i'm here i'll just say. You could. You could list out all of the pairs and then make a binary string out of those right for based on the subset right you could. list out all pairs. and make. A binary string. Out of each subset. Which is good, which is fine and it works and it's a valid way to encode decode but. What what most people do is use something called an adjacent see matrix so even though. We only need n times N minus one bits. let's just let's just round that up to n squared bits and now we have this nice square matrix where the bits are in each cell. And the. The advantage of doing this is now each cell has a a better. kind of significance right the the the cell in the ice row and jade column is zero or one depending on if there's an. edge from it Jay from. vertex I divert text J so now we're kind of using the structure of the matrix to encode the information so that we can. figure out and ask questions about it a lot easier, you can even do some matrix algebra to answer questions about the graph which, I might ask you some homework questions on. OK, so the entry in row I column J is the number of edges from vertex vertex J, so this actually takes care. Of multi. Multi multi graphs. Right. With parallel edges. Okay, so here is a graph. I haven't I haven't. filled in the graph yet so. This is a graph of what happens when in my family. Somebody get some like. or my mom hears some gossip and she wants to tell everybody so she calls me and tells me. She calls my brother and tells my brother and she calls my aunt who's like her best friend. And she tells her aunt now how do I know to draw those three edges well I look at my mom's row and the there's a one in the column, that means she calls that person. Okay, how about me well i'm going to call my brother, because I want to know what he what she told him, you know I want to know his side of the story, and then i'll call my mom back. and tell her what he said, you know and kind of get get everybody's story straight that's my role right, and you can see that I called my mom and my brother all right, how about my brother Well he does the same thing he calls me back. And then he calls my mom back. know if that really makes sense okay my aunt she doesn't call anybody back she's probably telling her kids about it, you know. And then my dad he calls me just to say hi poor dad he didn't get any of the any of the gossip. He was just like hey sudden what's going on, you know and i'm like oh dad you didn't hear huh he's like know what's happened, you know and it's like I don't know somebody. got into some trouble or. it's probably not him yeah exactly. um so yeah That gives you a sense of. of how an edge case I mean this is not the best example, but it gives you a sense of how the adjacent see matrix works, and you can kind of ask questions about it, and you can say like look at dad's column, nobody called him right if your column is all zeros nobody called you. Right and you can kind of think about the number of ones in your column is the number of people that called you, the number of ones in your row is a number of people, you call right, so you can kind of. turn these properties of the matrix into graph properties so that's why the Jason see matrix is pretty. it's pretty interesting right and Okay, so there are zeros down the diagonal. And in this particular example in a lot of simple graph examples we are going to have zeros down the diagonal and that just means you can't really call yourself. doesn't really make a lot of sense for this example, sometimes it will make sense to have self loops, but this is sort of like the extra information that we're holding and the the advantage that we get out of it is, is this nice structure so it's kind of like we're. we're holding a little bit more information to get this nice structure where we could have ignored it and then our structure would have you know not been as Nice. alright. So, how would this accommodate self loops I think we just talked about this right will be ones. Along the diagonal. And how would this accommodate parallel edges it's instead of. Only holding. The zeros and ones. You can hold i'm. You know other integers larger integers. Okay let's talk about. let's talk about simple undirected graphs. And I should say labeled right. Okay, how many different symbol undirected graphs are there within vertices for and is equal to one there's only one right for and is equal to two. there's this guy. And there's this guy. And that's it so for as equal to one there's one friend is equal to two there's two how many do you think there are for and is equal to three. Then Kevin is on top of it. Right, because now, remember that undirected graphs you're talking about the the edges, are an ordered pairs so how many pairs are there, out of a set of size and it's an choose to right, so we have. two to three choose to which is eight we can actually draw them all. Right there's that guy. there's this guy. there's this guy. This guy. 12345678. You can think about right it's kind of like there are half of the possibilities of the directed graph right because there's two directions in the director graph where there's only one. Okay, so that's good. um. Okay, so there can be a potential edge between every pair of vertices, so there are n choose to potential edges that could either exist or not, so there are two to the end choose two different simple labeled. undirected graphs on and vertices so the theoretical optimal encoding uses and choose to bits. Just to kind of a side note here is that a harder problem. is to count. The number. Of unlabeled. Simple. undirected graphs. Right, for example. For for three vertices you don't have labels, so you can have the graph without any edges, you can have the graph with just one edge right, but since they're unlabeled right that this is really the only graph that only has one edge right. Then there's the graph with two edges. And the graph with three edges. Right, so there are four but, once you start kind of getting into bigger and bigger grass this problem becomes much, much harder and you know people have done it I should I need to look it up to see what the. What the closed form is, but I think it's something like n plus one to the N minus one. plus one to the N minus two maybe. So for the one something like that. it's pretty crazy. it's a pretty crazy theory anyhow we're gonna we're going to stick with labeled. grass Okay, so what happened here. So encoding undirected graphs again we have and choose to bits but we just come in, have we just say let's use the JC matrix since the structure is so nice, even though we're going to be. Basically copying the information two times for undirected graphs right. So. If. You encode. undirected. graphs. In this way. You. will have a symmetric graph. Right, meaning that the. upper. triangle. and lower triangle. hold. The same information. let's look at what it means in terms of like a border graph, which is the graph that is naturally undirected right so here is the graph of New England. Right in here all the edges and we draw it like that. Okay, good so, how does the. What does the Agency matrix look like well notice that. The upper right triangle is a mirror image of the lower right triangle, I mean lower left triangle. And that's because, like, for example, for example, Rhode island is bordering with Connecticut So if I look in the row of Rhode island, I see Connecticut if I look in the row of Connecticut I see Rhode island and why are we, why are we wasting so much information, and the reason is because. It just makes a few of the graph algorithms easier to work on something standardized right as like at a Jason see matrix and again. If you have it in matrix format, then you can use matrix algebra to answer some questions about the graph, so we are sacrificing memory in order to kind of put our information in a really nice form that we can play around with a lot easier. Okay, so memory efficiency here's another kind of way to think about it when is it a Jason see matrix in an inefficient way to store graph. When the graph is very dense has a lot of vertices excuse me, it has a lot of edges and there's a high density of edges or a sparse graph when there is a very low density of edges. sparse right because there's going to be only very few ones and the rest are going to be all zeros. So, in order to kind of compensate for that we have a different data structure that we can use something called an A JC list. Jason see list is nice, because it really only holds the information that you want so in a Jason see list. For a directed graph is going to be a list for each vertex it's really a list of lists. And lists for each vertex and it's a list of all of its outgoing neighbors so. What is a neighbor in a directed in undirected graphs a neighbor is just a neighbor of a vertex V is just a another vertex that's connected by an edge okay. An a directed graph you have two different kinds of neighbors you have outgoing neighbors and you have incoming neighbors outgoing neighbors are all the vertices that you can get to buy one directed edge incoming neighbors or vertices that you can get to get from to that. neighboring vertices are called a json so it's just another word that we use in terms of those kind of things Okay, so this isn't a Jason see list, right here. it's a nice little compact form to store information right and i'm going to use it to draw the graph so just like we were doing with the encoding, and all this stuff you need to have enough information in your encoding to in order to. Read reconstruct your original object. So this adjacent the matrix is telling me that a has a directed edge from A to C D and E so let's draw those C D E alright be has a directed edge to see and a okay good see as a directed edge to de. De as a directed edge to a. B and he. He has a directed edge today. So that would be the. The graph corresponding to the Jason see list, and then you could build the JC matrix out of it to a few like. All right. How about the Jay Z list for an undirected graph. well. you're going to notice that. For example, you'd like the same example Rhode island is in the list of Connecticut because Connecticut borders Rhode island. But Connecticut is in the list of Rhode island, so you you basically have repeated information, but you put it in there, because you want to have easy access, you want to say you know if I asked you what are the borders of Rhode island. You want to be able to just pull out the list for Rhode island and read them off, rather than trying to search for Rhode island and other lists so it's kind of like. you're you're repeating information so that you can find it easier. Okay So what are the pros and cons well the pros of the Jason see list is that, then the amount of memory you're using is equal or it's proportional to the number of edges. Right. The cons here is that it takes time to look up an edge right because, for example, if I want to know a Vermont where if Massachusetts has Vermont in its list, I have to kind of look through the entire list until I get to Vermont. Right, so, in the worst case, you might have to do. The on the order of the amount of work to see if an edge exists or not. So, if your graph is sparse, then there are few edges in relation to the vertices, and so the amount of memory use is on the same order as the number of vertices so that's nice to us and a Jason see list. Okay Jason see matrix. On the other hand, has different pros and cons, how does the memory required grow based on the number of vertices V and the number of edges, he so. So for an agency matrix the memory. is always. equal to big O V squared right because you just you have that structure and you just kind of fill it up with zeros and ones, whereas the Jason seem list the memory, he. is bigger of he. Right. Now. The number of edges can vary right, you can have zero edges, or you can have you can have a lot of edges, you can have an edge between every two vertices so. Just kind of think about that, when you're doing these when you're when you're thinking about these different data structures, they have their pros and cons. Okay. All right, let's move on oh question. edges, are the lines and the vertices or the nodes. Okay, the degree. The degree of a vertex and undirected ground is the total number of edges incident with it, except that a loop contributes twice so, for example, this has degree or right, this has degree 233 and two just to kind of number of edges coming out. This kind of takes us to a kind of a nice property of graphs that you can think about the sometimes called the handshake lemme if there and people in a room. And each, this is not very covert friendly but. This is what we, you know we used to do when you go into a room you shake hands with people so. And people in a room and each person shakes hands with D other people how many handshakes themselves take place. Right well if you kind of looking at the perspective of each person, there are n times D times somebody put their hand down right and times D this motion, but each hand if you do that each handshake is counted twice, so you divide by two. And so, this, how does this relate to graphs we can think about the people in the room, as the vertices and if two people had a handshake That means that they are connected by an edge so really we're counting the number of edges, where the degree of each vertex is D. Okay that's called a D regular graph the simple and directed graph has an vertices and each vertex has degree D, how many edges, are there. Number of edges is n times D over to which means that two times the number of edges is n times D and it actually. suggests this stronger property, which is that two times the number of edges. is equal to the sum of all the degrees. Right, for example. Here we have degree four degree for degree for free for 234 so the some of the degrees. is equal to four plus four plus four plus four plus four which is 20. And the number of edges. is equal to 20 divided by two, which is 10 and you can count them there are 10 edges right and it's exactly because of that fact that if you count up all the degrees. You counting every single edge exactly twice from one from each endpoint. Okay So what about this one will we have two degree two degree of two degree of four degree of two, so how many edges, should there be, while we have four plus two, plus two, plus two divided by two is equal to. 10 over to which is fine, this should be five edges and there are, you can count, you can count them, so this is always going to work out. So what is this fact imply. Is it that does this mean that every degree in all graphs have to be even doesn't mean that the number of edges has to be even does it mean that the number of vertices with odd degree is even doesn't mean that the number of self loops or even or none of the above, like we can't. We can't determine anything. Okay let's see. Okay, most of us are saying see okay so see this is the correct answer the number of edges sorry, the number of vertices with odd degree, has to be either. It it's basically saying that the sum of all the degrees has to be an even number, and the only way that you can get an odd number is, if you have an odd number of odd numbers. it's kind of a funny funny way to say it, but. It means that the the odd degree vertices have to come in pairs because an odd plus an odd isn't even. If you just have like a single odd number kind of hanging out it's not going to it's good if it contributes to the sum is going to make the some odd. yeah so a self loop we count those as to as because it's it's a it's an edge coming in and coming out right so. Okay, what about in a directed graph. Was relaunched the pulling. In a directed graph you have two different kinds of degrees, you have the industry, and you have out degree in degrees and number of edges going into V, the out degrees and number of edges coming out of the So what is the sum of all the industries of a. directed graph. For the sake of time just going to stop this soon, maybe I can wait till it gets to 50% okay good all right. Sure results okay good so a so in a. In a directed graph if you add up all the industries you actually get exactly the number of edges and. This should make sense if you think about what you're really counting the industry you're counting the arrowhead of each one of the edges right So this has an industry of three. This has an industry have to that says it in degree of one this as an industry have to this is an industry of one this as an industry have one, and this as an industry have one she have one plus one plus one plus one plus two so that's 56789 1011 1213. Account that right. 2345 678-910-1110 11 right. But you can see that you've counted every edge exactly once because you're counting the, the head of every edge and it's the same thing, if you want to count it by the out degrees. Okay, so a few more things of vocabulary a walk is a. Is a route from one vertex to another, where you only are allowed to go over edges and if you could talk about a walk in a directed graph one undirected graph. The idea here is that each he has to be equal to the. I comma VI plus one right there has to be an edge that connects every. consecutive for text in there, a path is just a walk that doesn't repeat any edges, the length of a path is the number of edges in the walk or in the path. And there's always a path of length zero from a vertex to itself whether or not it has a self loop, we always just consider a vertex to have a a trivial path is called a trivial path. Okay, a simple path is a path that doesn't repeat vertices okay. A circuit. This should be a walk actually a circuit is a walk. I think. Right. Now a circuit shouldn't repeat right it's a pad that starts and ends at the same vertex, but you can repeat vertices right now, you can repeat vertices. And a cycle is a CERT circuit, that does not repeat vertices so this should be like a it's more like a simple. circuit. A loop or South loop is the edge from a vertex to itself Okay, a few more minutes, what does it mean to repeat edges, it means you go over the same edge more than once. Like, for example. let's say this was my graph. Alright i'm a walk on this graph I can i'm allowed to repeat edges here, so I could go like I could start here and then go. over here and then down there and then back up and then back over and then over there and then over there right, so you can kind of walk around you can you can go back and forth, you can repeat edges, a path you're not allowed to repeat edges. Okay, so maybe we'll. have some types of graphs and we have graph readability all right well. I guess this shouldn't i'll just go through these types of graphs just because you might encounter them. In the next few minutes, so a complete graph is a graph is a undirected graph. Where every single pair of vertices are connected, and so you have the complete graph on one vertex is just a single vertex it's just a line for two a triangle for three and then, as you get more and more vertices. You know the number of edges gets bigger and bigger Okay, the edge of this graph is a graph without any edge right, so we call it K bar because it turns out, it is the compliment. where's the compliment graph compliment graph of g to note a G bar is the graph where all the two vertices are connected by an edge in G than there, and if, and only if they're not connected by an edge in G bar. Okay, maybe I should just. continue this it looks like we're running out of time here so we'll look at some types of graphs I just kind of wanted to give you some more vocabulary, if you if you ever hear these terms but. we'll do that Thursday okay i'll stick around for some questions or comments. Professor. Yes. Could you explain the character multiplication again. Alright, so. Here let's maybe just start from scratch, so that might be a little bit easier to see okay so. let's say we have X is equal to. X and y right now we're going to split them up so X is going to be equal to X l. Times 10 to the. Well let's just use let's just use for but, in general, this will be like half of the size of the original right plus x are so this is just splitting it up, why is equal to y l. Plus y are right Okay, so what i'm going to do is. Is do these three different multiplication so let's call it. And one is going to be. X times y El. And two is going to be X are times y are right, so this is kind of like the first and the last if you're doing foil so now what i'm attempting to do. Here, or with my next multiplication is to figure out a way to get all the information, so I can reconstruct the inner and the outer the in the foil. Okay, and I claim that what I can do is just this. X minus X. Times y minus y. Okay, what i'm trying to get to down at the bottom is this X El y El. Times 10 to the eight plus. X, Y are times 10 to the four. plus x or y El times 10 to the four plus x are, why are right that's kind of my goal so, is it possible to get there, using this information is this where we're going to attempt to do right here. Okay, so, first of all, this guy is easy right, this is just me one tend to the. Right. color this guy is also easy right, this is just. All this sorry this should be in three, this is just me to just him to write so i've gotten like the first and last terms how do I get that middle term choose a different color. Okay well let's take em three and multiply it out in three is equal to. X El y El. minus. X our. y El. Am I subtracting them. Before. minus. X. y. plus x or. y. Maybe I should have had traction somewhere in there. Oh, I did it wrong. I did it wrong sorry. that's why. I mess this up. This should be X minus X are and then. Why R minus y El. So it will be X El y are minus X are, why are minus X El y R l. plus x or y El. Right, so now what am I what am I trying to get i'm trying to get this thing turned to get X, Y or plus x or y El and I can use the other a. recursive calls. And three plus one plus two is equal to one. it's going to be X El y R minus X or Y or. minus X, Y l plus x or y El so that's am three plus am one says and three plus and one is X, Y El right plus two, which is X or y are so those cancel with these middle terms and you're just left with X El y R plus x or y now, which is exactly what you want, in that middle term. That makes more sense thanks Professor. See you all on Thursday, then.