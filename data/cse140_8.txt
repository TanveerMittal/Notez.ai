 Yes. Hello everybody. Welcome back. It's good to see you all again. I feel like a lot of time has passed because the Lester's get to see everybody. So let me kind of go quickly over. But where we are, what we've covered so far is all of the combinational logic. And it's called combinational logic because the inputs, the outputs just depend on the inputs. There is no memory and combinational logic. Let's, we're going to do starting today is we're going to start talking about sequential logic. Where the inputs and the current state or the, whatever he's remembered inside the circuit, determine what the next output this. And we're gonna do that by covering memories. Today is gonna be sram, Static RAM, and dynamic crime. I will mention non-volatile memory, but I'll cover that much later in class, towards the end of the class. And then we'll go through latches and we'll cover flip-flops. So there is a lot to be covered today. I also wanted to touch base on exam one. I got a bunch of questions on Piazza asking whether I'm going to curb exam. So I just want to confirm that I always curve exams in this class if the averages below 75%. I have currently no idea what the hub bridges we haven't finished grade again. I'm hoping to have it graded by Thursday. There is a chance that it may take a little longer than that. So no later than next week on Tuesday, I didn't get some issues with download. They think one student had issue and downloading parts of the exam. About 1415 students had issues with uploading, which relatively speaking is a very small number. Again, considering how many people there are, we are actually looking at how to deal with those issues. And right now, we're focused on getting everything graded as if everything was perfect, no problems for anybody. And then we're going to revisit all of the situations where there were some issues and tried to figure out what is an appropriate way to adjust. And obviously, you know, if there are problems, I will definitely adjust the format and the timing of the exam going forward. Nothing is set in stone. This is my first time giving exams online. And while I didn't actually ask a bunch of faculty for how they're handling it, that what works and what doesn't work. And did my best to set up a system that I thought would work well. You know, things sometimes don't work out the way you hope. So. I will definitely do my best to make sure that you guys are tested in a fair and flexible enough way given the craziness of the situation that we're all in. So I do need a little bit more time, as I said, to get the grading done. So that way I know kind of where things stand that we can come up with a good strategy to deal with exams, both this exam and exams going forward. Now, having said that, you do have a homework number three that's assigned its due this Thursday. Three of the problems you should be able to do already had their own combinational logic. And one problem is unlatched design. This is something that we're going to cover today. So let me get started with that. If there are no questions on logistics, does anybody have a logistical question at all? Right, I don't see it. So what is a sequential circuit? As I said, sequential circuit is the circuit that has some form of memory sites. Output is gonna depend both on the inputs and on some past outputs or some data that you've stored before. That is the big news of today. He'd be in class. And having said that, let's get started with a super simple circuit. This is the simplest memory element and it's actually our static RAM. Sram cell. Sram stands for static RAM. And RAM is read and write memory. So in static cram, you have this two inverters that are connected to each other. So this behaves sort of like buffer that we already learned about. And it won't be just a normal buffer if we did not have this feedback loop that we have in here, the feedback loop actually has a switch that controls it. And we also have a switch that controls the input. In both cases, the switches are actually implemented using n MOS transistor. So in the first example, we have data input control by the Load button to produce the input to the two back to back two inverters. So if my data is a 0 and the load is equal to a logic one, what will happen is that 0 will appear at the input of the first inverter. There'll be a one at the output of the first inverter and then 0 at the output of the second inverter. So effectively all I've done is I've propagated data from input all the way to deal with that. Same thing happens if I had a situation in which data was a one, except now one would be propogated through the NMOS transistor. In the middle, I will have a 0. And then at the output that will have a logic one. Now remember when we talked about the NMOS transistors, we thought about what value. Nmos transistors not pass well, so they do not pass. Wow, what zeros or ones? You guys remember? Exactly, they don't pass one. So my second example, if theta is a one and it goes through this n MOS transistor, output really will not be exactly a one. It'll be something that's close to one, but not exactly a one. And this is why we have two of these inverters. This allows us to effectively recreate a strong logic one, add the final output. So this kind of is a refreshed won by the buffer or by two back to back and murders, okay? With a 0, we don't have that problem because n months will actually pass and 0 really well. Now notice when load is equal to a one normally remember, will be equal to 0. Right? However, why do we want to switch load? Lets say that load is now a 0. Remember will be a one. And in this case, we have an open circuit at the input. And the last value we had Steward was a one. So this logic one will go back to the input of the first inverter. In-between will again have a 0 and again a logic one out. So effectively, Wide remember is equal to logic one. We keep remembering the logic one that is, that has been stored in. So it keeps going around. Got same thing happens with a 0. There is no difference. So if I originally had logic 0 stored in here, and remember is a one that 0 would go back to the input. One would be in between and 0, what come back out. So regardless of whether I had started one or a 0, I would always be able to remember whatever it is I stored. And in fact, this memory will stay indefinitely. I remember as long as there is power to my circuit. And that is because inverter needs power to operate. Right? So here's my VDD power. Okay? So this is super exciting. Now I have a memory element, and this memory element has two transistors for first inverter, two transistors for the second inverter, and then two transistors that act like switches. So it is a six transistor cell. So if you were to look at even recently published papers and the top circuits conference IS FCC. You will see titles that have 60 for the static RAM cell in them. So to this day, Static RAM or sram. Uses six transistors. And in fact, if you think about our l u, l u in today's processors is usually coupled with registers. And this you can remember crime, you're CSE 30 registers we used to load the data from memory and kind of keep the data than parallely so that they Liu could operate on an registers were also used to store temporary results that they owed you had calculated today and on Thursday we're going to talk about exactly how to build these registers. What I told you about just now is what sits right below and that it's sram. So that's this cell that you see right here. And the best sale is a six transistor cell and its normal use for building cash. Cash is relatively fast memory that uses a special way of finding data in it that allows you to find data a little more frequently. And how cache works will be covered by csc 140, which is the next class in the series. They'll bid me fast sram, stance, dynamic cram, dynamic Quran. Dynamic cram is built very simply by just using a single transistor. In this single transistor, Uganda, a load data we control when it's loaded over here, data is going to come at the input of the transistor. Now the interesting thing is that we're going to hold the data use and just the capacitance of this transistor. And this is where the problem lies with dynamic RAM. Because when you look at how dynamic RAM is designed, let's imagine that this is our silicon. Inside dynamic RAM is this humungous capacitor that holds the tiny little data that gets loaded right then the transistor on top, it's this capacitor that is helping us retain memory. The problem is that these capacitors aren't that great. They tend to leak. So whatever I have loaded tends to disappear. Which means that they have to kind of keep writing, have to refresh, which is essentially equal to rewrite whatever data stored. I have to read it and write it back again. Otherwise I'm going to lose that data. So dynamic cram has refresh cycles of usually a hundred, two hundred milliseconds, because that's about how long it takes for the capacitor that is trying to store data on to lose it. Now the nice thing about dynamic RAM is that it's one transistor memory. And this is why dynamic RAM is in gigabytes. Because you can fit a whole bunch of this memory all in one little chip. Sram or cash is in megabytes. It's not than gigabytes normally because it's organized in a way and it uses six transistors per single bit, so you can't really fit as much. Okay, so I think now that you guys know how memory works, and beneath dynamic cram, normally you would have non-volatile memory. Non-volatile memory works quite similar to dynamic crab. The differences is that it uses specialized transistors, which can hold the state regardless of whether you have power or not. So dynamic RAM and sram lose data as soon as you turn off power. But non-volatile memory can hold that this is what we like about it. Then your solid state drive is built out of non-volatile memory. For example. I'm going to move on if you guys don't have any other questions on this to my super exciting example of a flight attendant called button. And this is a very relevant example because I actually love traveling. And in fact, the picture you see right behind me is a photo of my backpacking trip in Sierra Leone. It was beautiful. I totally loves heroes. So when I travel, I will often take actually my kids with me. And since I have four kids, you can imagine that flying on the plane, especially with four little kids, can be super exciting. They always find a button to press. And the call button of an attendant is one of the favorite toys because not only does it like the light, but it also rings the bell. If you keep pressing it. It can ring the bell many a time and it can flashlights. So that's super exciting, which obviously is great for a little kid, not so great for attendant or for the parents. So I'm going to give me an example today. A little bit more complicated Call button. This call button than fact has two buttons. It has call m cancel. And my goal with the call button is basically, if you press call, the light should shine. If you press Cancel, the light should turn off. And if Coval and cancel or released, if you're not pressing them, then the light should hopefully remain on, all remain off depending on whatever you did last. That's the ideal state. Now let's first think about the logic of pricing a call button. So if, if Karl is equal to one, i want my light to be equal to one. At the same time, I want cancel to be equal to 0, right? So if I were to implement this, actually a super simple gate, I will take a NAND gate out feed call to it. I would feed, not cancel. And I would get the logic that tells me that light is equal to one. So that's a great example of the situation in which I can take co-equal one, cancel equals 0, I turn on the light. There is obviously a small problem with this. What is the problem with this circuit that I drew? Build a circuit to address all of the questions that I have here. The fact that I want to turn on the light and that I also want the light to be turned off. Yeah, exactly. The light does not stay on and that's the basic problem. The light doesn't stay on because as soon as I lift my finger, so as long as it's called is one and I'm holding my finger on the button. All is well, but the moment I left my finger, the light turns off. So this is definitely sub-optimal, but it makes for happier paren, because a kid would really have to be holding the bell. But it doesn't make for a happy solution if you really urgently need an attendant, because then you're holding a kid at one end and a button but the other hand, which is super unhappy. So one solution to this would be to use a memory element like an sram cell that I just showed you on the last slide. One possible solution. And then I got the question, is the RAM the one that they suddenly had this thought? Dram is the one that they sell. You had the star sram is usually built into the processor, so you would buy as a part of the process or so I guess, yes, it is. The memory came by the store cell to make life a little easier. Because remember, sram cell has six transistors. And when I add to that, i got two transistors here. And I got six transistors here. I end up with something that's actually pretty big. There is, it turns out a simpler circuits that can implement this. And that circuit is shown right below here. It's a circuit because it requires only four transistors in every gate. So this particular latch, which is called SR latch set, reset latch. It requires a transistor switch is much smaller than my logic gate together with sram cell implementation. And it in fact does implement the function that I'm interested in. So let's start first with the call button, big breast and cancel button being not suppressed. So if S is equal to one, my first inverter, let's called this inverter number one. It's output is going to be equal to 0. That 0 he's gonna feed to the input of the next inverter, inverter number two. And this inverters output because both of the inputs are 0, its output, there's gonna be a logic one. This logic one goes back to the input of the first, sorry, not the inverter NOR gate. And because NOR gate has two inputs that are one, its output will still be a 00 goes back down. Both inputs are 0. So this basically is a stable situation in which the output is a logic one. So I have effectively set the output. And what I mean by set is the output is equal to a one. Okay? Let's do the reset. So now that call is a 0 and a camps to lizzy one. That means that set is equal to 0 and reset is equal to a one. If reset is equal to a one, the output is going to be q will be equal to a 0 regardless of what the other input, this, that's how our NOR gate works. So here, reset, because q is going to be equal to 0. Now that 0 goes back to the input of the NOR gate number one, and the output of the NOR gate is one. Notice that this output is basically Q bar. It's just the opposite of what Q is. Okay, everybody so good so far. Now I'm gonna do this again, except now I'm going to catch my kid and keep their finger away so neither cold nor cancel button will be pressed. Both are going to be 0. That means that both a set and reset are 0. But notice this then means that I fully depend on what is that second input at each of these NOR gates. So I depend on what the amber the previous output was. So because previously I had done my reset, my input here was a 0 and then put them here on the NOR gate number two is a one. So that means that the output will again be a 0 of the queue and will again be one at q naught psi. Effectively, I'm holding this state, okay? I'm holding whatever was there before it. Lets imagine that previously my output was a one. Let's imagine that the output was one and the output Bar was a 0. So now if Akbar was 0, that would come down here. And then my second input is still a euro. I'm still holding. That means that the output will be one. So I still hold the same state, right? In both cases. In first case I'm holding a 0. In the second case I'm holding one. That logic one is going to go to the second input. That second input will produce an output of 0. So I'm still holding. So basically if both call and counsel or 0, I have a whole state. Okay? So far, so good. Let me kind of recap. If set is equal to one and reset is equal to 0. So I imagine that set is always one. The output on the first NOR gate will always be 0. And that means that the output of the second NOR gate will be one. This is when we set, okay? The second case, when reset is equal to one, what happens is, is we produce a 0 at the output. And this then provides one adult put Q bar. So this is reset. I can write it correctly. So, so far so good. In the first case we have a set, in the second case we have a reset. Now I'm going to move to a little more complicated case. And this case, we have a situation in which both set and reset our 0. And now we depend on whatever was the previous value. So let's say that the previous value was a 0. That means that the 0 comes down to the NOR gate two. If both inputs are 0 to that NOR gate, the output will be a one. That means. Then comes the input NOR gate number one. And because single one input is a one, the output will definitely be a 0. So here we're holding AS era. So whatever was previously there were holding still I'd be out but those two values are the same. Now let's look at what happens if previous output was a one. So here it means I have a logic one. That logic Huang appears at the input of the N2 NOR gate and the output to then event to NOR gate, there's going to be a 0. That means Q bar is a 0. That becomes an input to N2 NOR gate, because both inputs to N2 NOR gate there are 0, output is a one. Again, I want to spend back down to n2. So effectively here, we're holding a logic one. Previously we had the one, and we keep holding that logic, wanted the output. Ok. So this is a place where we have memory, or it also can be called up hold state or remember state. Okay. Alright, so far, so good. The next one is the not so happy state. This is a super unhappy state. We don't like it. Why don't we like it? Well, set than receptor one. So far, Life is easy. It means that the output of both N1 and N2 will be a 0. So there's no problem here. 0 comes back down as an input to output. This della 00 comes up as an input to N1. Output is still 0, so it's a pretty stable state here. The problem is over here, that q is equal to q bar and that we don't like, we want the situation, so this is not happy. We want the situations in which Q and Q bar are not equal to each other. So this is why we call this an invalid standing state. Because Q and Q bar end up being equal to each other and they really should not be equal to each other. So just to recap here, rehab situation and set and reset latch, in which we set the state. They'll remake output equal to one. If set this one and reset is 0. That is this first case. It is reset. If reset there's one and set is 0. So this is the second case and the last cases or hold state, where the output will be whatever was stored inside hat of this gate. This is Q previous, ok. And the symbol folder latch has two inputs and two outputs, both Q and Q bar. So don't ever put inverter to generate the Q bar. That's bad news because you already get it for free because of the way we designed the circuit. Ok, so now let me get to the one remaining problem on your homework assignment that you don't know how to do, because we haven't done the characteristic equation. So remember this is our set reset latch. And the In recent latch has this feedback path, feedback from Q0 to input S. I just redrew exactly the same feedback path here. Notice that I didn't bother redrawing the second feedback path which goes from q bar to the input of N one. These two are actually complimentary to each other and I can analyze both. I just chose to analyze only one, this particular slide. So if I want to get a characteristic equation, all I need to do is just break this feedback path called the input to the NOR gate, that this is input n, So this is input into a NOR gate. And two, call that Q sub t and realize that the output NOR gate then one will be same qs of t but with a slight delay. How long he said delay its delay of two NOR gates, right? And we already know how to estimate that using resistances and capacitances. So effectively by just looking at the circuit, I can see that I have a situation in which I have a NOR between R, which is an input to NOR gate number one and another nor riches snored with q of t. Okay? This is just by looking at the circuit. This further I can write in this way, this can be r naught and that weight S ord with q of t. And I can also further kind of multiply it out if I like. And it would look like this. Is everybody okay so far on this, in this example, all I did is I got characteristic equation for q by breaking a feedback loop of q in order to be able to analyze it. And I fully realize that Q of t plus delta t will be equal to q of t, as long as we've had enough time to propagate the data through. The other way that I can also analyze this is by looking at these various input combinations and trying to find out what exactly my output is for those input combinations. So let's start with the simple ones. Let's start with 01 over here. So if S is 0 and R is one, I know that in that case, output of one gate will be a 0 and match regardless of what happens at the output, the event to gate, I actually don't care what it is because as long as one of the inputs to N1 is a, one, output of Q is a 0. So this is why I call this a reset state. Because all end up in a situation in which regardless of what Q is, the output will be reset. So to make a little bit simpler table, I can do this. Okay? So this is q at some time plus if set this equal to 0 and reset is equal to one, the output is going to be a 0. I don't care about it. About the other input. Okay, let's move on to the next input. And the next one is my set state. So here S is equal to one, R is equal to 0. So if S is equal to one, I still don't really care what the other input 22 is because the output tough and two will be equal to 0. And sets reset is a 0, the output of N one will be equal to one. And that means that the output over here will be of the next state will be one, which means I am in a set state, so this was reset. The next one is a set. Okay, so, so far so good. Now let's look at the first state when S and R are both 0. So if I have a 0 here, and now I have a 0 here, what will happen is it will matter what my Q sub D is. Because whenever q of t is the input B, it will affect the output of this next gate. Now, what happens if I have a NOR gate and I have an output queue to it and another input of a 0, what's at the output of my NOR gate. So otherwise, this output, let's call it N2. Output will be q Nord with the 0. And Q Nord where the 0 is just not q, right? So here I have not q. And that means at the next output I'm going to, I'm going to be back to Q, but it's going to be q. That is a slight delay. It will be Q plus the little delta that it takes me to get through these two gates. Ok? So this is why I end up in a hold state because Q that they had stored previously, we'll be back shown at the output. So the first state, basically Q plus is equal to whatever Q is, because I'm just holding my data. We've got the last pieces, the 11. And here I'm going to call it not allowed because I do not want the situation in which if r is one, S is one. The outputs are both 0 and they're both equal to each other. That's bad news. So this is why I put the don't care in here. And this is why I'm gonna put the don't care in here because this is invalid. It's a state I want to avoid. Okay. So, so far so good. Now I can take the next step. I can create a key map that has S and R in it and also has a Q of D in it. And this is a K map where I'm going to calculate t plus delta t. And here I can combine the two ones or zeros. So let me start with ones. Here are the ones. The first one is just an s. The second is r prime Q sub D. Let me know if you don't see that for some reason. Okay. Now I'm going to do the same thing, but they'll do zeros. With zeros, I can do 0 is this way and this way. And let's do the first combo. The first set is when I have my R equal to one. So because I'm doing product of stumps here it is r prime. And then the second one, which is this two sum, happens when my S is equal to 0 and also happens when Q of t is equal to 0. So both of them are represented, those themselves. Notice that this is exactly the same as what I did when I analyzed my circuit. Okay? And in fact, logically speaking, both of these equations are equal to each other. They will give correct result. And all of these are called characteristic equations. So if you look at your homework, you have the same problem. The only differences is that here you have a few more gates. And instead of Norse, you have in your homework assignment nouns. That's the only difference between this. But in order to analyze it, all you have to do is break the feedback loop between Q of t plus delta t and Q sub t. And figure out what that characteristic equation is and what are the states that you have in your particular latch? And you will likely find very similar states to what we actually have already done. Okay. Any questions on this? Okay, so let me move on. There's a question that what about Q bar? So q bar, you can analyze the same way we analyze q mu will just end up with a slightly different feedback loop. You do exactly the same thing. Normally, we don't ask you about Q bar because basically q bar ends up being just not q. So as long as you analyze queue, you're home-free. You could definitely is a K map for Q bar. There is no difference between how you would treat one versus the other in this coincidentally is exactly the reason why I say in this class that all exams are cumulative. Because you can't possibly solve these kinds of problems without knowing came apps and without knowing your product of sums, in sum of products, it just doesn't work. Okay? And okay, moving on. So how to avoid the S and R being equal to one? This is part one. So one way we can try to avoid that is by adding a clock signal to the input. So what happens with a clock signal? Clock signal is a 0. Then outputs of these AND gates will be 0. And effectively, we will be in hold state. Which means that our SR latch, which is right in here. Just hold whatever was previous data. So if c is equal to 0, we're just holding. So Q Next is equal to Q previous. So qa minus we call Q previous, And this is next. Okay? Now let's see what happens when clock is equal to one. Clock is equal to U1. Then S1 becomes equal to S, R1 becomes equal to bar, say clock is equal to one, S, one is equal to S, R one is equal to r, and you have normal SR latch operation. This means that you also, when clock is one, you also have chance still for SNR to be equal to each other and equal to one. So the problem isn't solved. The problem, it's just reduced because now the clock is hopefully equal to one only part of the time. And you can hopefully avoid setting SNR both equal to one during the time that clock is one. Do you guys have any questions on how this circuit works before I go into more details about the clock. Okay, well, let's go into clucks them. So when I talk about clocks, I'm generally talking about the oscillating signal. And this is a signal that oscillates between 01 period of the clock is the amount of time it takes for the clock to go a single oscillation. So in this example, I spent ten nanoseconds being a 0 and has spent another ten nanoseconds being a one. So my time period, this 20 nanoseconds night, my time period, 1 second. My clock frequency would be one over time period, which is one over second, which is the same thing as one hertz will go. This is just the definition of what I've heard this. So that is definition of a clock period. Clock cycle is one such interval. So here I have one clock cycle. Here I have one more clock cycle. Here is another clock cycle. So this is 123 clock cycles, and here is a half a cycle. So here, this is why I have 3.5 clock cycles. When we talk about clock duty cycle, what I mean is amount of time that the clock is logic one. So here, clock is logic 150% of the time. If I forever to design a clock that looks like this, this clock right here would be 25% duty cycle because it's logic one only 25% of the time. Okay? I already talked about clock frequencies. And here is the conversion between the clock period and frequencies in gigahertz. So this effectively told you that if you want to have a clock of one gigahertz, your clock period should be one nanosecond for clock periods and they're greater than a gigahertz, your clock period is less than the nanoseconds, tells you how super fast your logic gates that actually are running in your circuit. Which is pretty amazing. When we call circuit synchronous, really all we mean is same circuits that are synchronous, that depend on the clock. They respond or they change as a function of the clock. That is really what bird synchronous means. Ok. So any questions on clocks? Okay, let's do a second improvement on our latch. And this is going to get us to a super cool level sensitive D latch, where D stands for data, and c stands for clock. Okay? Yes, so the question is when I say CPU is one gigahertz, that effectively refers to exactly this. It diverts to how fast the clock in the CPU is running. What is that clock period? And in your CPUs, you normally generate these clock by using crystal that the oscillates naturally. And then some circuits that create a predictable level of oscillation where the period that you need, because natural crystal does not oscillate that every single period that you would like. Okay, so getting back to my D latch, the only difference between a level sensitive latch, SR latch that we talked about few slides ago. I go. And a D latch is this little inverter. This inverter effectively ensures that the S and R are always opposite of each other. And it in fact ensures if clock is equal to one, then S is equal to d and r is equal to D naught. Do you guys see that? Say if I have a logic one here and my S is equal to not of D ANDed with one, then S is, sorry, it's not, it's not a NAND gate, then S is equal to just a logic, just the d. Okay? Now notice what happens when clock equals 0. If clock is equal to 0, then S is equal to r is equal to 0, and you are in a whole state. So q will be whatever Q was before. Again, everybody, okay, so far. Let's walk through these funny-looking waveforms. So let's start first with my clock signal. This here is my clock. The clock signal, if it's a 0, it means that I'm just holding whatever was at the output already until pluck goes to a logic one. So here is when the clock is going to be a logic one. So this means up until now, I'm just holding, I'm not doing anything else holding whatever was there before at Q. When clock goes to a logic one, at that point I start worrying about what's on my data. Because at that point, whatever my data is going to be copied to my signal. So notice at this point, when plop turns to one that's at this edge here, I'm going to copy whatever he said the data back to the output. It's going to take a little bit of time. So this time here, because I have a gate over here, so it takes some time for the data to pass to the output. So this is why my.'s. Inputs to the SR latch will become a logic one. And it will stay a logic one as long as the clock is equal to one, the moment that block goes back down to 0, S is going to go back down to 0. And it's going to stay at 0. Because until next time, when next time clock is one, my D is a 0. So S is not going to change the rest of the time here. Okay? In the meantime, when S became a logic one, r 1s a logic 0. Since our goals or our head to be a logic 0 during this time? No, since it was already a logic 0, nothing really changed. Now notice at the second clock period, because d is a logic 0 when clock is one some amount of time later. Again function of this delay here that we have, you're going to end up with r. That is a logic one. And it'll stay on logic one until clock goes back to 0, at which point r is going to goal so to 0. So when we're down here, when clock is a 0, right here, we're back and hold state. Ok. Notice that the during the time that S is equal to u1, we're in a situation when S is one, r is 0, and that puts us in a set state. And then as soon as claw goes to 0, which is right over here. And some small amount of time after that, we're going to move to hold state, except now we're holding a logic one. Then when clock is back to logic one, we're gonna go here into a reset state because R is a logic one. After we exit out, we're back into a whole state because clock is a 0. So in this case, we have dramatically reduced the amount of time when set and reset could be equal to each other to just the time that it takes for this inverter to work. And that only affects the circuit when clock is equal to one. So the odds of this happening a very, very small now, because inverters are super fast, remember we said the clock period was in nanoseconds. So inverter is sub nanosecond speed. It's really incredibly fast, but the probability is not 0. It still exists. Ok. Everybody, okay with level sensitive latch so far. So the big thing to remember is that in the level sensitive latch, the data at the input will be copied exactly to the output as long as clock is equal to one, otherwise it's going to hold whatever was there right before Clock turned to 0. So here's a nice truth table for the latch. If clock is equal to 0, does not matter what data is. It's going to be in a hold state. So Q previous will be copied to the output. It will just hold whatever was there before. And this is here what my D Latch looks like. The other possibility is that I have a situation in which clock is a one, and then d is maybe a one. If these are one, that means D not is a 0 and I have set equal to one, reset equal to 0. That means that my latches in a set state. So the output will be a one. Notice that this output is the same as the D input. Ok, let's see the next one. So here I'm going to have a situation in which clock is one, but D is a 0. That means that said this is 0. Reset is a one. And that means I have a reset state. And that is why the output is a 0. Notice that over here also, the output matches the input D. So to make a simplified table, if I have a clock and the input, if clock is 0, D doesn't matter. Q output will be with them, or Q was before me, clock of one. And I have some value D at the output, at the input, then the output will be exactly the same. Okay? Is everybody okay with this? Okay, moving on, this is a quick summary here of exactly what I just talked about. So in clock is equal to one, the passes directly to q. So the latch is said to be transparent. It just copies whatever is at the input. You know, however, this looks like if clock is equal to one during this time, it's going to copy exactly that out. Okay? When clock is equal to 0, it will hold its previous state. So if the last state was a 0, then output will be held at the 0 as long as clock is equal to 0. Ok? And this mostly, so not always, but mostly whites, the case where Q is equal to Q prime. Now notice that the symbol for lacZ can be drawn also like this. Whoops, sorry. Here's my Q and Q bar. It can also be drawn like this. Ok? All of these are the same thing. They're all D Latch. Any questions on the line so far? There are no questions. I'm going to give you a super exciting poll. And this I'm going to have to warn you, is a hardball does is not an easy question. So this question is asking you, assume that the data in all latches is initially, oops, sorry, is initially 0. So we start with all zeros in the here. And the input goes to a logic one, and clock transitions from 0 to a one. Notice that I have two clocks here, pluck a poppy, pluck a last longer than clock be. The question is when clock goes back to 0 again, so here's 0, here's one, here's 0. So one search cycle over here. And why just remains at one? So assume initially was at 0, now it's at one. What's stored values will I haven't latches. Ok, so give this a little bit of thought. Okay. And I have only 13% of people who voted. So let's kind of converge on a good answer. I'll give you 30 more seconds. We got 20 more seconds. So the key to this question is the difference in these two clocks. That's the key to this question. And remember deal actual copy, whatever is at the input to the output, as long as clock is equal to one. Notice that all of these latches are connected together. So here is my Q1 output, here is my Q2 output, here's my Q3. Here's my cue for output. They're all connected to each other. So whatever is at the input of the first one, when clock is one will be copied to the output of the first one and will become the input of the second one. Okay, I'll give you five more seconds. 43210. And here are the results. Everybody seems to like answer B, but we have fair number of people in other categories, especially dy. So let's look at what is the actual answer. This is, as I said, a hard question. It's not an easy question. Okay. So looking at this now, let me change the color for a second. Really the secret to this question is how long is the clock equal to one? And this is something that I did not tell you. What is this length of time? Because we know if clock is equal to one, the y that is equal to one at the input will be copied to the output. So let's assume initially that each latch takes tau amount of time to propagate data from input to output. And let's assume for simplicity that the first clock, so the period a is much, much greater than four times tau. So it's long enough for the data to propagate what would happen in that cases. We will first take the one into the first latch. That one would appear as the input to the next latch, which would then go to the next sludge, next latch, and then to the output. So if this length of time over here, it's very long, long enough for today are to propagate all the way through. Then we're totally fine. Then we're gonna have all once. So then this in fact would be true. However, if the time is too short. So for example, if this time is so short that it's like thought of only one clock period. Then you could end up in a situation where one makes it through one single latch, but zeros remain in all other latches. The problem is, I never told you how long the these clocks are. I just said that one is longer than the other. I don't tell you how long it is. So there's no way for you to know whether option B happened, the option they happened, or something entirely different. You cannot know. The only thing you know is that you need more information. So the correct answer was answer the and this is really the key to the latches and why we don't like to build circuits with latches. Because you're dependent on having to predict how long is the clock equal to one, so that you can find out what exactly appeared at the output of the latch. So try to create a register. Olive latches is really a huge pain because you're really dependent on the timing and trying to align signals just flipped, right? Any questions on this level? Sensitive the latch combination. So this circuit is not something that you would see in today's processors. I do have a question from before that that's how does Q equal to Q Not in a D Latch? And that actually I can answer by just looking at this little inverter. This inverter has some small amount of delay. May know it's short, but it's not 0. It's more than 0. So in a situation in which I had the, that changed from a 0 to a one. And let's say that before this, then when D was a 0, S would have been a 0, right? When D was a was a 0 and our would've been a one. But now B changes from 0 to one. This one will appear at this input, but it'll take some amount of time for inverter to cause are to go to 0. During this very short amount of time. We have a situation when both S and R equal to one, which is no good. And I have one other question. How do we determine the value of tau? That can be a homework assignment, that's gates. You just look at what is the delay of all of the gates and you guys know what's inside of the SR latch is NOR gates. You know that you have the end gate here and you know that you got an inverter. So you could calculate what is the delay through all these gates. And that would allow you to figure out what is the delay off a single latch. So this is why we learned how to do resistance and capacitance calculations. Simple transistor base gate cmos transistors. Because these circuits are really built out of knots nans indoors. That's it. Okay. Okay. I'm going to move on to an improved version. Off our design. Now this improved version that actually brings us a flip-flop, which is super exciting. Flip-flop consists of two latches, master march, Anna, Slave latch, or a servant. These latches are connected to each other. The input D is connected to the master. The output of the master becomes an input of the slave. And notice the interesting thing about the clock. So clock, as it is, is connected to the slave and not clock is connected to the master. So when clock is equal to a 0, not clock is going to be equal to one. And master, he's gonna be loading data. But slave is going to just hold whatever it got previously at the input from our master. Okay? Now if we have a situation in which clock is equal to a one, not clock will be equal to 0. Master will hold whatever was there before. So notice that now it's going to hold whatever it had. Add this output that is going to be held for the input of the D Latch. D latch will load that. So the load, and it happens only when my clock goes from 0 to one. That's the only time that the slave will load new data from the mastering to the slave. And it'll load whatever data was right before this clock straight into the slave and provide output at the output Q. So this is why they call this a rising edge. We can make it the falling edge just by moving the inverter to a different position. So I've inverter went on the slave clock instead, then you would have a falling edge, but they would operate the same way. Notice that this is pretty big. D latch already has plenty transistors. In fact, how many transistors does it have? We can revisit this. The match has eight transistors each, AND gate has six transistors, and an inverter is two transistors. So we have 12 fraying gates and ten for the rats. So that's 22 transistors for my D latch. Right? So here I have 22 transistors, and then I have an inverter which has two transistors. So 44.5 transistors, blues two, which is 46 transistors. These things are huge. So the only reason why we bounce flip-flops is because b like this predictability of the rising edge. So we like the fact when plugged goes from 0 to a one. That is the only time that I'm going to see a change in my final output thought the slave, which is Q Slave, which is also the Q out. Okay? Now let's step through this particular waveform so you guys understand this fully. Notice that CM is same thing as not clock or pluck of the master. And notice that CS is the same thing as clock. So initially I started with a clock at 0, the clot goes to a one here. At the same time, masters clock is a one that's right over here and eventually it'll go down to 0. Okay? While masters clock is a one, I'm going to, my master, he's going to copy whatever is at its input to the output. So this is why you see this copy happening down here. The copy happened slightly delayed because I have some gates. It takes me some time to propagate through the latch. But effectively I'm just copying this down here. And I perform this as long as master clock is at a one, the moment that I plug goes to 0. Now I'm going to be in a hold state in master. That means that I'm going to hold the logic one. So effectively, what the advert, the master was, is now the input that I'm holding steady for the slave. Notice that this is pointing time a twitch slave goes from the whole state to the loaded state. Right? So now it's kinda loved whatever the masteries, but it's kinda low that some small amount of delay after, which is a function of how long it takes for the slave to transmit the input, you know, dS to the output gap. Then notice that this will be held at one all the way until clock goes to 0 because now and all the way continual, it will continue to be hold that one because now slave is holding. So effectively the only time I loaded the data in the data and load it was whatever the D was right at the edge of rising clock. Right at this edge, either loaded whatever D was and I provided it at the output of the final output. Okay. And notice that in this particular combination, well, the Avery's inside of the master. Whatever its holding in its output Q Master will be always at the input of ds. So whether it's a 01, it doesn't matter. Whatever q i minus is the same thing as ds. Now, if Master is in the holding state, Huo him will be whatever q i was at the last load. Okay. Okay. Any other questions on this? So I guess I don't quite understand. The lodge means digital Lodge. No, it means data latch. Where D is just data input. And the Flip-flop also means just data. Whoops. And the reason for that is because I'm loading the data, so load the rising edge. Yep. So let me kind of go over this. Here is the flip-flop. This is the symbol for the flip-flop. Notice a little triangle. This is how you can always tell the difference between a flip-flop and the latch. The flip-flop will always have a triangle four o'clock. Okay? And notice here that regardless of what the, so this is if clock equals, if clock is a rising edge. So if clock is rising, then the output will be whatever the input is. So effectively because upset on rising edge of the clock. If we have the 0, q plus will be a 0. If we have the one, q plus will be D1, but only if clock is at the rising edge. Okay? This is my characteristic equation, although it is super easy, a queue at the next time instance will be equal to whatever d is at the current time instance. Now notice if the clock is not at the rising edge, so if this is not true, then q at t plus one is equal to q, whatever it was at the T. So this is the whole state. And here we have load. Okay? Now we talked about the fact that we can have a rising edge or we can have a falling edge. And this inverter, where this little bubble is effectively the falling edge, it represents an inverter. Add the input to the clock here. Okay? And the difference is, is that the rising edge we load here. So only on these rising edges cubed plus would be equal to d. And here, only on the falling edges. Well, q plus b equal to d, That's the only difference between the two. There is no other difference. Okay? Okay. And this brings me to my enabled D flip-flops. So the enable Flip-flop is enabled F, we have multiplexer, oops, sorry, connected to the D input. Use again enable signal. So notice that here, hue shows up again at the input of the multiplexer. So now if enable is equal to 0, what will happen? This q will just be copied to the, sorry, that's not as era, Hugh will just be copied to the input D, and it will appear again at the output. So when enable is equal to a 0, basically hold state. If enable is equal to one, what will happen is instead D will be connected to the D input of the latch. And then it behaves like a normal life, normal flip-flop. On the rising edge of the flip flop, Q will be equal to D if enable equals one. Okay? So that's really all I mean by unable. And here is a symbol for the enable, enabled D flip-flop. Any questions on this? Okay, and the last piece that I would like to cover today is this particular example. And this, oops, sorry, is some additional features for the D flip-flop. So we can have a def reset on the D flip-flop B, either synchronous or asynchronous. So in this class we're going to focus only on the synchronous presets or resets. And in case of a reset, that happens if we have the following situation. So here's my clock, here is my queue. I always have Q bar, so sometimes I'm going to be lazy and not write q bar, but it always exists because of the way that this is designed. And if now I put an AND gate here and I put the input to it and I put not reset. What will happen is when reset is equal to a logic one, the output of this will be a 0. So this will guarantee that reset will always reset regardless of what the yes. Okay. You can see also what a synchronous preset might do. So here is the same thing, except now I'm putting an OR gate here and I have a set signal and d instead. So I've set this equal to one, the output of this gate, this one, which means that Q is one regardless of what ds. So this, this is what I mean by synchronous set or precept. And then I can have both reset then preset. Then they can be either set or reset dominant depending on what combination of logic gates you use. So I'm going to go through one of these examples. Here is d, q, here is my clock. And let say that I have set dominant. So I'm gonna put an OR gate with a set signal here. And then I'm going to put an AND gate with a reset signal here. And here is my b. Notice that here if set is equal to one, I don't really care what's on top. Input will be a one and output will be one. So this is what I mean by set dominant, because it set is one, then reset doesn't matter. Okay? If I implement this logic equation, the opposite will be the case. In the last pieces, this enable signal, and that is the multiplexer at the input. That was what they just showed you a second ago. So that's this circuit here where de multiplexer decides whether you're going to provide the D input or you've been, uh, provide the q input to your lacZ. And always remember that these latches half both the, sorry that these flip flops and latches have both Q and Q bar are available. So even if I draw something like this, never, ever do this, do not do this to generate Q bar. Remember that Q bar exists down here. Okay? So to do a very high level summary today we talked about SR latch, wedge. If psi plus one and reset was Zara would provide output of one. If reset once one set was 0, it would reset the output to 0. If both are 0, it held or it kept memory of what was stored there before. Any Arthur one which said that's bad news and we're going to avoid that. We try to avoid it by, oop, sorry. We tried to avoid it by adding a clock of equal to o, by adding a clock signal bit 2n gates. But that wasn't that perfect because it's still possible when clock is one for set than recent to both May 1 day. And he said, yeah, we can add this inverter because in that case, only when clock is one and only for a very tiny amount of time that inverter is switching from one to a 0. We'll set and reset B1. The problem but D latch that we designed in this way is that we cannot create a nice register out of it because shifting data in the register depends on the delay through the D latch and the length of time that clock is one. So that is what motivated us to create a D flip-flop that loads the data only if we have a rising edge of the clock. So here, the only time that data makes it from inputs, sorry, not the Pew bar, but really to cue is when we have a rising edge of the clock. But this comes at a cost of 46 transistors, which is really a lot of transistors. So this predictability is expensive. But it's so important that this is why people actually use the flip-flops to build registers. And we'll go over that in the next class. Okay, do I have any questions on anything I've covered so far in the class. So the question, so again, this is really nice overview. Remember that latch is level sensitive latches. They copy input to output when clock equals one. Whereas in the case of the flip-flops, so this is latch. In case of a flip-flop, it happens only on the rising edge. That's a key difference, okay? Here you did not have a pluck, so you're basically dealing with whatever set and reset signals. Okay. So if I got no questions on the lecture material for today, what I'm gonna do is I'm going to stop here for a second. And I am going to share just quickly the homework assignment. Because I wanted to clarify something. I got a question during the office hour about this. The question was about the multiplexer at the output. So this particular multiplexer, you can see here, has two inputs. It has an input, F2 and F3. And because these inputs are connected to, F2 is connected to a logic 0 here and a three is connected to logic one. This means that F3 is the most significant bit and F2 is the least significant bit. So if F2 is equal to one and F three is equal to 0, then the combination we have is 01, which corresponds to input one. So input one will be connected to G, Ip a 0, and I3 is a one that corresponds to combination 10, because f three is the most significant bit, which is equal to the input to being connected to the output g. Okay? The other thing I'm going to clarify is how to deal with this design. Again, in this design, same as what we did in class. You're going to break the feedback loop between Q output and Q as an input here. And you will analyze the circuit as if there is no Q bar. So you don't need to worry about this feedback loop. And that should, that should give you everything you need for the column on Q, you can do. And the same thing then put a Q bar. So effectively you end up with a situation in which you have two characteristic equations. Or you can simply just fill out the table that tells you what Q and Q bar are gonna end up being. And ask yourself as a function of these inputs x and y, what states do I have to have state set? Stay? Do I have recent spade? Do I uphold state, invalid state? Notice that in your case you have a little bit more complex inputs. So instead of just connecting a single inverter between the two inputs, now I have combinations of x and y showing up at the input of these two back to back NAND gates. So that's it for my clarification. Do I have any other questions from anybody? And again, I want to thank you all for being patient while we grade the exam one, as soon as I have the grades, I will bring the results to class and we can discuss kind of where to go from there at that point. So if there are no other questions, I'm going to thank you all I really appreciate all of the great work and great questions that you have asked. Good luck on the homework. And I'll see you on Thursday. I